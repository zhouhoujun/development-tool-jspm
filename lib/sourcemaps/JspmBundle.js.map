{"version":3,"sources":["JspmBundle.js","JspmBundle.ts"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","_typeof","decorate","i","defineProperty","__metadata","k","v","metadata","_","require","development_core_1","path","fs_1","chalk","globby","jspm","source","vinylBuffer","chksum","mkdirp","JspmBundle","info","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","call","name","runWay","RunWay","sequence","manifestSplit","_inherits","_development_core_1$P","_createClass","value","config","option","ctx","setPackagePath","dirname","packageFile","jsbuilder","Builder","separateCSS","builder","Promise","resolve","then","jspmConfig","loadConfig","undefined","dist","gulp","_this2","bundles","all","map","getbundles","loadBuilder","bundle","defaults","groupBundle","groups","flatten","console","log","cyan","getSrc","files","getRelativeSrc","createBundler","join","mainfile","src","_this3","toModule","baseURL","isArray","s","filename","relative","replace","toModulePath","fn","substring","extname","extend","dest","file","systemConfigTempl","relationToRoot","bust","jspmMates","*.css","loader","*.json","*.jsx","sfx","minify","mangle","sourceMaps","lowResSourceMaps","toRootPath","_this4","_get","prototype","calcChecksums","checksums","updateBundleManifest","manifest","writeBundleManifest","green","initOption","pipes","output","_this5","bundleName","bundleDest","bundlemap","shortPath","modules","push","uniq","env","gb","split","keys","filter","f","bundleGp","_this6","bundleStr","bundleItems","minusStr","exclusionString","exclude","items","combine","getBundleDest","str","exclusionArray","_this7","minus","forEach","item","group","concat","builderCfg","bundler","buildStatic","getBundleShortPath","parse","base","bind","sync","stream","write","process","nextTick","end","pipe","chksums","isObject","reject","filepath","err","sum","error","red","getBundleManifest","each","_this8","root","template","maps","css","json","n","test","first","jspmMetas","JSON","stringify","jspmMeta","paths","getBundleManifestPath","includes","readFile","data","mainfilePipes","url","existsSync","content","readFileSync","idx","indexOf","writeFileSync","e","fullPath","getDist","spath","min","PipeTask","task","oper","Operation","release","deploy","exports"],"mappings":"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","file":"../JspmBundle.js","sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nconst _ = require('lodash');\nconst development_core_1 = require('development-core');\nconst path = require('path');\nconst fs_1 = require('fs');\nconst chalk = require('chalk');\nconst globby = require('globby');\nconst jspm = require('jspm');\nconst source = require('vinyl-source-stream');\nconst vinylBuffer = require('vinyl-buffer');\nconst chksum = require('checksum');\nconst mkdirp = require('mkdirp');\nlet JspmBundle = class JspmBundle extends development_core_1.PipeTask {\n    constructor(info) {\n        super(info);\n        this.name = 'jspm-bundle';\n        this.runWay = development_core_1.RunWay.sequence;\n        this.manifestSplit = `/*------bundles infos------*/`;\n    }\n    getOption(config) {\n        return config.option;\n    }\n    loadBuilder(ctx) {\n        let option = ctx.option;\n        // console.log(path.dirname(option.packageFile));\n        jspm.setPackagePath(path.dirname(option.packageFile));\n        let jsbuilder = new jspm.Builder({ separateCSS: option.builder.separateCSS });\n        return Promise.resolve(jsbuilder)\n            .then(builder => {\n            if (option.jspmConfig) {\n                return builder.loadConfig(option.jspmConfig, undefined, true)\n                    .then(() => {\n                    return builder;\n                });\n            }\n            else {\n                return builder;\n            }\n        });\n    }\n    sourceStream(ctx, dist, gulp) {\n        let option = ctx.option;\n        if (option.bundles) {\n            return Promise.all(_.map(this.getbundles(ctx), name => {\n                return this.loadBuilder(ctx)\n                    .then(builder => {\n                    let bundle = option.bundles[name];\n                    bundle.builder = _.defaults(bundle.builder, option.builder);\n                    if (option.builder.config) {\n                        builder.config(bundle.builder.config);\n                    }\n                    return this.groupBundle(ctx, builder, name, bundle, gulp);\n                });\n            })).then(groups => {\n                return _.flatten(groups);\n            });\n        }\n        else {\n            return this.loadBuilder(ctx)\n                .then(builder => {\n                console.log('start bundle all src : ', chalk.cyan(ctx.getSrc()));\n                if (option.builder.config) {\n                    builder.config(option.builder.config);\n                }\n                return Promise.resolve(globby(ctx.getSrc()))\n                    .then(files => {\n                    files = this.getRelativeSrc(files, ctx);\n                    console.log(files);\n                    return this.createBundler(ctx, builder, 'bundle', files.join(' + '), option.mainfile, option.builder);\n                });\n            });\n        }\n    }\n    getRelativeSrc(src, config, toModule = false) {\n        // console.log(option.baseURL);\n        let baseURL = config.option.baseURL;\n        if (_.isArray(src)) {\n            return _.map(src, s => {\n                let filename = path.relative(baseURL, s).replace(/\\\\/g, '/').replace(/^\\//g, '');\n                return toModule ? this.toModulePath(filename) : filename;\n            });\n        }\n        else {\n            let fn = path.relative(baseURL, src).replace(/\\\\/g, '/').replace(/^\\//g, '');\n            return [(toModule ? this.toModulePath(fn) : fn)];\n        }\n    }\n    toModulePath(filename) {\n        if (!filename) {\n            return '';\n        }\n        return filename.substring(0, filename.length - path.extname(filename).length);\n    }\n    initOption(ctx) {\n        let option = _.extend({\n            baseURL: '',\n            mainfile: 'bundle.js',\n            jspmConfig: '',\n            packageFile: 'package.json',\n            dest: '',\n            file: '',\n            systemConfigTempl: '',\n            relationToRoot: '',\n            bust: '',\n            bundles: null,\n            jspmMates: {\n                '*.css': {\n                    loader: 'css'\n                },\n                '*.json': {\n                    loader: 'json'\n                },\n                '*.jsx': {\n                    loader: 'jsx'\n                }\n            },\n            builder: {\n                sfx: false,\n                minify: false,\n                mangle: false,\n                sourceMaps: false,\n                separateCSS: false,\n                lowResSourceMaps: true\n            }\n        }, ctx.option);\n        option.baseURL = ctx.toRootPath(option.baseURL);\n        option.jspmConfig = ctx.toRootPath(option.jspmConfig);\n        option.packageFile = ctx.toRootPath(option.packageFile);\n        return option;\n    }\n    execute(ctx, gulp) {\n        this.bundles = [];\n        return super.execute(ctx, gulp)\n            .then(() => {\n            let option = ctx.option;\n            if (option.bundles) {\n                if (option.bust) {\n                    return this.calcChecksums(option, this.bundles).then((checksums) => {\n                        return this.updateBundleManifest(option, this.bundles, checksums);\n                    });\n                }\n                else {\n                    return this.updateBundleManifest(option, this.bundles);\n                }\n            }\n            else {\n                return null;\n            }\n        }).then(manifest => {\n            if (manifest) {\n                return this.writeBundleManifest(ctx, manifest, gulp)\n                    .then(() => {\n                    console.log(chalk.green('------ Complete -------------'));\n                });\n            }\n            else {\n                console.log(chalk.green('------ Complete -------------'));\n                return null;\n            }\n        });\n    }\n    setup(ctx, gulp) {\n        ctx.option = this.initOption(ctx);\n        return super.setup(ctx, gulp);\n    }\n    working(source, ctx, option, gulp, pipes, output) {\n        let bundle = source['bundle'];\n        if (bundle.sfx) {\n            console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\n        }\n        else {\n            console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\n        }\n        return super.working(source, ctx, option, gulp)\n            .then(() => {\n            let bundlemap = {\n                path: bundle.shortPath,\n                modules: bundle.modules\n            };\n            this.bundles.push(bundlemap);\n            return;\n        });\n    }\n    getbundles(ctx) {\n        let option = ctx.option;\n        let groups = _.uniq(_.isArray(ctx.env.gb) ? ctx.env.gb : (ctx.env.gb || '').split(','));\n        if (groups.length < 1) {\n            groups = _.keys(option.bundles);\n        }\n        else {\n            groups = _.filter(groups, f => f && groups[f]);\n        }\n        return groups;\n    }\n    groupBundle(config, builder, name, bundleGp, gulp) {\n        let option = config.option;\n        let bundleStr = '';\n        let bundleDest = '';\n        let bundleItems = [];\n        let minusStr = this.exclusionString(bundleGp.exclude, option.bundles);\n        if (bundleGp.items) {\n            bundleItems = _.isArray(bundleItems) ? bundleGp.items : _.keys(bundleGp.items);\n        }\n        console.log(`-------------------------------\\nBundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(bundleItems)}\\n-------------------------------`);\n        return Promise.resolve(builder)\n            .then(builder => {\n            if (bundleGp.combine) {\n                bundleDest = this.getBundleDest(config, name, bundleGp);\n                bundleStr = bundleItems.join(' + ') + minusStr;\n                return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleGp.builder, bundleGp);\n            }\n            else {\n                return Promise.all(bundleItems.map(key => {\n                    bundleStr = key + minusStr;\n                    bundleDest = this.getBundleDest(config, key, bundleGp);\n                    return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleGp.builder, bundleGp);\n                }));\n            }\n        });\n    }\n    exclusionString(exclude, groups) {\n        let str = this.exclusionArray(exclude, groups).join(' - ');\n        return (str) ? ' - ' + str : '';\n    }\n    exclusionArray(exclude, groups) {\n        let minus = [];\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\n        _.forEach(exclude, (item) => {\n            var group = groups[item];\n            if (group) {\n                // exclude everything from this group\n                minus = minus.concat(this.exclusionArray(group.items, groups));\n            }\n            else {\n                // exclude this item by name\n                minus.push(item);\n            }\n        });\n        return minus;\n    }\n    createBundler(config, builder, bundleName, bundleStr, bundleDest, builderCfg, bundleGp) {\n        let sfx = builderCfg.sfx;\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleGp);\n        let filename = path.parse(bundleDest).base;\n        return bundler.bind(builder)(bundleStr, bundleDest, builderCfg)\n            .then(output => {\n            mkdirp.sync(path.dirname(bundleDest));\n            var stream = source(filename);\n            stream.write(output.source);\n            process.nextTick(function () {\n                stream.end();\n            });\n            return stream.pipe(vinylBuffer());\n        })\n            .then(output => {\n            output['bundle'] = {\n                sfx: sfx,\n                path: shortPath,\n                bundleName: bundleName,\n                filename: filename,\n                bundleDest: bundleDest,\n                modules: output.modules\n            };\n            return output;\n        });\n    }\n    calcChecksums(option, bundles) {\n        let chksums = {};\n        console.log('Calculating checksums...');\n        return Promise.all(_.map(bundles, (bundle) => {\n            if (!_.isObject(bundle)) {\n                return null;\n            }\n            return new Promise((resolve, reject) => {\n                let filepath = path.join(option.baseURL, bundle.path);\n                let filename = path.parse(bundle.path).base;\n                chksum.file(filepath, (err, sum) => {\n                    if (err) {\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\n                    }\n                    console.log(filename, chalk.cyan(sum));\n                    chksums[bundle.path] = sum;\n                    resolve(chksums);\n                });\n            });\n        })).then(() => {\n            return chksums;\n        });\n    }\n    updateBundleManifest(option, bundles, chksums) {\n        chksums = chksums || {};\n        var manifest = _.defaults(this.getBundleManifest(option), {\n            bundles: {},\n            chksums: {}\n        });\n        // console.log(manifest);\n        _.each(bundles, bundle => {\n            if (bundle.path) {\n                manifest.bundles[bundle.path] = bundle.modules;\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\n            }\n        });\n        return manifest;\n    }\n    writeBundleManifest(config, manifest, gulp) {\n        let option = config.option;\n        if (!option.mainfile) {\n            return Promise.reject('mainfile not configed.');\n        }\n        console.log('Writing manifest...');\n        let output = `\r\nSystem.config({\r\n    baseURL: '${path.relative(option.baseURL, config.env.root) || '.'}',\r\n    defaultJSExtensions: true\r\n});\r\nSystem.bundled = true;\r\nSystem.bust = '${option.bust}';\r\nif(window != undefined) window.prod = true;\r\n${this.manifestSplit}\r\n`;\n        let template = '';\n        if (manifest) {\n            // try {\n            template = option.systemConfigTempl;\n            if (!template) {\n                template = (option.bust) ? `\r\n(function(module) {\r\n    var bust = {};\r\n    var systemLocate = System.locate;\r\n    var systemNormalize = System.normalize;\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var chksums = module.exports.chksums = \\${chksums};\r\n    var bundles = module.exports.bundles = \\${bundles};                    \r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n    System.normalize = function (name, pName, pAddress) {\r\n        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n            var chksum = chksums[name];\r\n            if (chksums[name]) { bust[address] = chksum; }\r\n            return address;\r\n        });\r\n    };\r\n\r\n    System.locate = function (load) {\r\n        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n            var chksum = bust[address];\r\n            return (chksum) ? address + '?' + chksum : address;\r\n        });\r\n    };\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n` : `\r\n(function(module) {\r\n    var bundles = module.exports.bundles = \\${bundles};\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n`;\n            }\n            let maps = {\n                css: 'github:systemjs/plugin-css@0.1.20.js',\n                json: 'github:systemjs/plugin-json@0.1.2.js'\n            };\n            _.each(_.keys(manifest.bundles), n => {\n                if (/css.min.js$/.test(n)) {\n                    maps.css = _.first(manifest.bundles[n]);\n                }\n                if (/json.min.js$/.test(n)) {\n                    maps.css = _.first(manifest.bundles[n]);\n                }\n            });\n            let jspmMetas = option.jspmMetas;\n            output += _.template(template)({\n                maps: JSON.stringify(maps, null, '    '),\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\n                paths: JSON.stringify(config.option.builder.config ? config.option.builder.config.paths : null, null, '    '),\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\n            });\n        }\n        let mainfile = this.getBundleManifestPath(option);\n        let includes = option.includes || [\n            './system-polyfills.src.js',\n            './system.src.js'\n        ];\n        return Promise.all(_.map(includes, f => {\n            return new Promise((resolve, reject) => {\n                fs_1.readFile(path.join(option.jspmConfig, f), 'utf8', (err, data) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(data);\n                    }\n                });\n            });\n        }))\n            .then(data => {\n            data.push(output);\n            mkdirp.sync(path.dirname(mainfile));\n            var stream = source(mainfile);\n            stream.write(data.join('\\n'));\n            process.nextTick(() => {\n                stream.end();\n            });\n            return super.working(stream.pipe(vinylBuffer()), config, option, gulp, option.mainfilePipes);\n        });\n        // if (!existsSync(mainfile)) {\n        //     mkdirp.sync(path.dirname(mainfile));\n        //     writeFileSync(mainfile, output, { flag: 'wx' });\n        // } else {\n        //     writeFileSync(mainfile, output);\n        // }\n        // console.log(chalk.green('Manifest written'));\n        // return Promise.resolve(true);\n    }\n    getBundleManifestPath(option) {\n        var url = option.baseURL;\n        return path.join(url, option.mainfile);\n    }\n    getBundleManifest(option) {\n        let data = {};\n        let path = this.getBundleManifestPath(option);\n        if (fs_1.existsSync(path)) {\n            try {\n                let content = fs_1.readFileSync(path, 'utf8');\n                let idx = content.indexOf(this.manifestSplit);\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\n                content = content.substring(idx);\n                // console.log(content);\n                fs_1.writeFileSync(path, content);\n                data = require(path);\n                console.log('has old bundle：\\n', chalk.cyan(path)); // , 'data:\\n', data);\n            }\n            catch (e) {\n                console.log(chalk.red(e));\n            }\n        }\n        return data;\n    }\n    getBundleShortPath(config, bundleName, bundleGp) {\n        var fullPath = bundleGp ? this.getBundleDest(config, bundleName, bundleGp)\n            : path.join(config.getDist(), bundleName);\n        let spath = path.relative(config.option.baseURL, fullPath);\n        spath = spath.replace(/\\\\/g, '/').replace(/^\\//g, '');\n        return spath;\n    }\n    getBundleDest(config, bundleName, bundleGp) {\n        let dest = config.getDist();\n        let min = bundleGp.builder.minify;\n        let name = bundleGp.items[bundleName] || bundleName;\n        let file = name + ((min) ? '.min.js' : '.js');\n        if (bundleGp.combine) {\n            dest = path.join(dest, file);\n        }\n        else {\n            dest = path.join(dest, bundleName, file);\n        }\n        return dest;\n    }\n};\nJspmBundle = __decorate([\n    development_core_1.task({\n        oper: development_core_1.Operation.release | development_core_1.Operation.deploy\n    }), \n    __metadata('design:paramtypes', [Object])\n], JspmBundle);\nexports.JspmBundle = JspmBundle;\n","import * as _ from 'lodash';\r\nimport { task, ITaskConfig, RunWay, IAssertDist, ITaskContext, Src, Pipe, OutputPipe, ITaskInfo, TransformSource, ITransform, Operation, PipeTask } from 'development-core';\r\nimport { Gulp } from 'gulp';\r\nimport * as path from 'path';\r\nimport { IJspmTaskConfig, IBundlesConfig, IBundleGroup, IBuidlerConfig } from './config';\r\n\r\nimport { readFileSync, readFile, existsSync, writeFileSync } from 'fs';\r\nimport * as chalk from 'chalk';\r\nconst globby = require('globby');\r\nconst jspm = require('jspm');\r\nconst source = require('vinyl-source-stream');\r\nconst vinylBuffer = require('vinyl-buffer');\r\nconst chksum = require('checksum');\r\nconst mkdirp = require('mkdirp');\r\n// const uglify = require('gulp-uglify');\r\n\r\nexport interface IBundleMap {\r\n    path: string;\r\n    modules: Src\r\n}\r\n\r\n@task({\r\n    oper: Operation.release | Operation.deploy\r\n})\r\nexport class JspmBundle extends PipeTask {\r\n\r\n    name = 'jspm-bundle';\r\n    runWay = RunWay.sequence;\r\n    private bundles: IBundleMap[];\r\n    constructor(info?: ITaskInfo) {\r\n        super(info);\r\n    }\r\n\r\n    protected getOption(config: ITaskContext): IAssertDist {\r\n        return config.option;\r\n    }\r\n\r\n    protected loadBuilder(ctx: ITaskContext): Promise<any> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        // console.log(path.dirname(option.packageFile));\r\n        jspm.setPackagePath(path.dirname(option.packageFile));\r\n        let jsbuilder = new jspm.Builder({ separateCSS: option.builder.separateCSS });\r\n\r\n        return Promise.resolve(jsbuilder)\r\n            .then(builder => {\r\n                if (option.jspmConfig) {\r\n                    return builder.loadConfig(option.jspmConfig, undefined, true)\r\n                        .then(() => {\r\n                            return builder;\r\n                        });\r\n                } else {\r\n                    return builder;\r\n                }\r\n            });\r\n    }\r\n\r\n    sourceStream(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (option.bundles) {\r\n            return Promise.all(_.map(this.getbundles(ctx), name => {\r\n                return this.loadBuilder(ctx)\r\n                    .then(builder => {\r\n                        let bundle: IBundleGroup = option.bundles[name];\r\n                        bundle.builder = <IBuidlerConfig>_.defaults(bundle.builder, option.builder);\r\n                        if ( option.builder.config ) {\r\n                            builder.config(bundle.builder.config);\r\n                        }\r\n                        return this.groupBundle(<IJspmTaskConfig>ctx, builder, name, bundle, gulp);\r\n                    });\r\n            })).then(groups => {\r\n                return _.flatten(groups);\r\n            });\r\n        } else {\r\n            return this.loadBuilder(ctx)\r\n                .then(builder => {\r\n                    console.log('start bundle all src : ', chalk.cyan(<any>ctx.getSrc()));\r\n                    if ( option.builder.config ) {\r\n                        builder.config(option.builder.config)\r\n                    }\r\n\r\n                    return Promise.resolve<string[]>(globby(ctx.getSrc()))\r\n                        .then(files => {\r\n                            files = this.getRelativeSrc(files, <IJspmTaskConfig>ctx);\r\n                            console.log(files);\r\n                            return this.createBundler(<IJspmTaskConfig>ctx, builder, 'bundle', files.join(' + '), option.mainfile, option.builder);\r\n                        });\r\n                });\r\n        }\r\n    }\r\n\r\n    private getRelativeSrc(src: Src, config: IJspmTaskConfig, toModule = false): string[] {\r\n        // console.log(option.baseURL);\r\n        let baseURL = config.option.baseURL\r\n        if (_.isArray(src)) {\r\n            return _.map(src, s => {\r\n                let filename = path.relative(baseURL, s).replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n                return toModule ? this.toModulePath(filename) : filename;\r\n            });\r\n        } else {\r\n            let fn = path.relative(baseURL, src).replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n            return [(toModule ? this.toModulePath(fn) : fn)];\r\n        }\r\n    }\r\n\r\n    private toModulePath(filename: string): string {\r\n        if (!filename) {\r\n            return '';\r\n        }\r\n        return filename.substring(0, filename.length - path.extname(filename).length);\r\n    }\r\n\r\n    private initOption(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>_.extend(<IBundlesConfig>{\r\n            baseURL: '',\r\n            mainfile: 'bundle.js',\r\n            jspmConfig: '',\r\n            packageFile: 'package.json',\r\n            dest: '',\r\n            file: '',\r\n            systemConfigTempl: '',\r\n            relationToRoot: '',\r\n            bust: '',\r\n            bundles: null,\r\n            jspmMates: {\r\n                '*.css': {\r\n                    loader: 'css'\r\n                },\r\n                '*.json': {\r\n                    loader: 'json'\r\n                },\r\n                '*.jsx': {\r\n                    loader: 'jsx'\r\n                }\r\n            },\r\n            builder: {\r\n                sfx: false,\r\n                minify: false,\r\n                mangle: false,\r\n                sourceMaps: false,\r\n                separateCSS: false,\r\n                lowResSourceMaps: true\r\n            }\r\n        }, <IBundlesConfig>ctx.option);\r\n\r\n        option.baseURL = ctx.toRootPath(option.baseURL);\r\n        option.jspmConfig = ctx.toRootPath(option.jspmConfig);\r\n        option.packageFile = ctx.toRootPath(option.packageFile);\r\n\r\n        return option;\r\n    }\r\n\r\n\r\n    execute(ctx: ITaskContext, gulp: Gulp) {\r\n        this.bundles = [];\r\n        return super.execute(ctx, gulp)\r\n            .then(() => {\r\n                let option = <IBundlesConfig>ctx.option;\r\n                if (option.bundles) {\r\n                    if (option.bust) {\r\n                        return this.calcChecksums(option, this.bundles).then((checksums) => {\r\n                            return this.updateBundleManifest(option, this.bundles, checksums);\r\n                        });\r\n                    } else {\r\n                        return this.updateBundleManifest(option, this.bundles);\r\n                    }\r\n                } else {\r\n                    return null;\r\n                }\r\n            }).then(manifest => {\r\n                if (manifest) {\r\n                    return this.writeBundleManifest(<IJspmTaskConfig>ctx, manifest, gulp)\r\n                        .then(() => {\r\n                            console.log(chalk.green('------ Complete -------------'));\r\n                        });\r\n                } else {\r\n                    console.log(chalk.green('------ Complete -------------'));\r\n                    return null;\r\n                }\r\n            });\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp: Gulp) {\r\n        ctx.option = this.initOption(ctx);\r\n        return super.setup(ctx, gulp);\r\n    }\r\n\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        let bundle = source['bundle'];\r\n        if (bundle.sfx) {\r\n            console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n        } else {\r\n            console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n        }\r\n        return super.working(source, ctx, option, gulp)\r\n            .then(() => {\r\n                let bundlemap: IBundleMap = {\r\n                    path: bundle.shortPath,\r\n                    modules: bundle.modules\r\n                };\r\n                this.bundles.push(bundlemap);\r\n                return;\r\n            });\r\n    }\r\n\r\n    getbundles(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        let groups = _.uniq(_.isArray(ctx.env.gb) ? ctx.env.gb : (ctx.env.gb || '').split(','));\r\n        if (groups.length < 1) {\r\n            groups = _.keys(option.bundles);\r\n        } else {\r\n            groups = _.filter(groups, f => f && groups[f]);\r\n        }\r\n\r\n        return groups;\r\n    }\r\n\r\n    protected groupBundle(config: IJspmTaskConfig, builder, name: string, bundleGp: IBundleGroup, gulp: Gulp): Promise<any> {\r\n\r\n        let option: IBundlesConfig = config.option;\r\n\r\n        let bundleStr = '';\r\n        let bundleDest = '';\r\n\r\n        let bundleItems: string[] = [];\r\n        let minusStr = this.exclusionString(bundleGp.exclude, option.bundles);\r\n\r\n        if (bundleGp.items) {\r\n            bundleItems = _.isArray(bundleItems) ? <string[]>bundleGp.items : _.keys(bundleGp.items);\r\n        }\r\n\r\n        console.log(`-------------------------------\\nBundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(<any>bundleItems)}\\n-------------------------------`);\r\n\r\n        return Promise.resolve(builder)\r\n            .then(builder => {\r\n                if (bundleGp.combine) {\r\n                    bundleDest = this.getBundleDest(config, name, bundleGp);\r\n                    bundleStr = bundleItems.join(' + ') + minusStr;\r\n                    return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n\r\n                } else {\r\n                    return Promise.all(bundleItems.map(key => {\r\n                        bundleStr = key + minusStr;\r\n                        bundleDest = this.getBundleDest(config, key, bundleGp);\r\n                        return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n                    }));\r\n                }\r\n\r\n            });\r\n    }\r\n\r\n    private exclusionString(exclude, groups): string {\r\n        let str = this.exclusionArray(exclude, groups).join(' - ');\r\n        return (str) ? ' - ' + str : '';\r\n    }\r\n\r\n    private exclusionArray(exclude, groups): string[] {\r\n        let minus: string[] = [];\r\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\r\n        _.forEach(exclude, (item: string) => {\r\n            var group = groups[item];\r\n            if (group) {\r\n                // exclude everything from this group\r\n                minus = minus.concat(this.exclusionArray(group.items, groups));\r\n            } else {\r\n                // exclude this item by name\r\n                minus.push(item);\r\n            }\r\n        });\r\n        return minus;\r\n    }\r\n\r\n    private createBundler(config: IJspmTaskConfig, builder: any, bundleName: string, bundleStr: string, bundleDest: string, builderCfg: IBuidlerConfig, bundleGp?: IBundleGroup): Promise<any> {\r\n\r\n        let sfx = builderCfg.sfx;\r\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\r\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleGp);\r\n        let filename = path.parse(bundleDest).base;\r\n\r\n        return bundler.bind(builder)(bundleStr, bundleDest, builderCfg)\r\n            .then(output => {\r\n                mkdirp.sync(path.dirname(bundleDest));\r\n                var stream: ITransform = source(filename);\r\n                stream.write(output.source);\r\n                process.nextTick(function () {\r\n                    stream.end();\r\n                });\r\n\r\n                return stream.pipe(vinylBuffer());\r\n            })\r\n            .then(output => {\r\n                output['bundle'] = {\r\n                    sfx: sfx,\r\n                    path: shortPath,\r\n                    bundleName: bundleName,\r\n                    filename: filename,\r\n                    bundleDest: bundleDest,\r\n                    modules: output.modules\r\n                };\r\n                return output;\r\n            });\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    private calcChecksums(option: IBundlesConfig, bundles: any[]): Promise<any> {\r\n        let chksums = {};\r\n\r\n        console.log('Calculating checksums...');\r\n\r\n        return Promise.all(_.map(bundles, (bundle: any) => {\r\n            if (!_.isObject(bundle)) {\r\n                return null;\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                let filepath = path.join(option.baseURL, bundle.path);\r\n                let filename = path.parse(bundle.path).base;\r\n                chksum.file(filepath, (err, sum) => {\r\n                    if (err) {\r\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\r\n                    }\r\n                    console.log(filename, chalk.cyan(sum));\r\n                    chksums[bundle.path] = sum;\r\n                    resolve(chksums);\r\n                });\r\n            });\r\n\r\n        })).then(() => {\r\n            return chksums;\r\n        });\r\n    }\r\n\r\n    protected updateBundleManifest(option: IBundlesConfig, bundles: any[], chksums?: any) {\r\n\r\n        chksums = chksums || {};\r\n\r\n        var manifest: any = _.defaults(this.getBundleManifest(option), {\r\n            bundles: {},\r\n            chksums: {}\r\n        });\r\n\r\n        // console.log(manifest);\r\n\r\n        _.each(bundles, bundle => {\r\n            if (bundle.path) {\r\n                manifest.bundles[bundle.path] = bundle.modules;\r\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\r\n            }\r\n        });\r\n\r\n        return manifest;\r\n\r\n    }\r\n\r\n    private manifestSplit = `/*------bundles infos------*/`;\r\n    private writeBundleManifest(config: IJspmTaskConfig, manifest, gulp: Gulp): Promise<any> {\r\n        let option = config.option;\r\n        if (!option.mainfile) {\r\n            return Promise.reject('mainfile not configed.');\r\n        }\r\n\r\n\r\n        console.log('Writing manifest...');\r\n\r\n\r\n        let output = `\r\nSystem.config({\r\n    baseURL: '${ path.relative(option.baseURL, config.env.root) || '.'}',\r\n    defaultJSExtensions: true\r\n});\r\nSystem.bundled = true;\r\nSystem.bust = '${option.bust}';\r\nif(window != undefined) window.prod = true;\r\n${this.manifestSplit}\r\n`;\r\n        let template = '';\r\n\r\n        if (manifest) {\r\n            // try {\r\n            template = option.systemConfigTempl;\r\n\r\n            if (!template) {\r\n                template = (option.bust) ? `\r\n(function(module) {\r\n    var bust = {};\r\n    var systemLocate = System.locate;\r\n    var systemNormalize = System.normalize;\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var chksums = module.exports.chksums = \\${chksums};\r\n    var bundles = module.exports.bundles = \\${bundles};                    \r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n    System.normalize = function (name, pName, pAddress) {\r\n        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n            var chksum = chksums[name];\r\n            if (chksums[name]) { bust[address] = chksum; }\r\n            return address;\r\n        });\r\n    };\r\n\r\n    System.locate = function (load) {\r\n        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n            var chksum = bust[address];\r\n            return (chksum) ? address + '?' + chksum : address;\r\n        });\r\n    };\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n` : `\r\n(function(module) {\r\n    var bundles = module.exports.bundles = \\${bundles};\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n`;\r\n            }\r\n\r\n\r\n            let maps = {\r\n                css: 'github:systemjs/plugin-css@0.1.20.js',\r\n                json: 'github:systemjs/plugin-json@0.1.2.js'\r\n            };\r\n\r\n            _.each(_.keys(manifest.bundles), n => {\r\n                if (/css.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n                if (/json.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n            });\r\n\r\n            let jspmMetas = option.jspmMetas;\r\n            output += _.template(template)({\r\n                maps: JSON.stringify(maps, null, '    '),\r\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\r\n                paths: JSON.stringify(config.option.builder.config ? config.option.builder.config.paths : null, null, '    '),\r\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\r\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\r\n            });\r\n\r\n        }\r\n\r\n        let mainfile = this.getBundleManifestPath(option);\r\n\r\n\r\n        let includes = option.includes || [\r\n            './system-polyfills.src.js',\r\n            './system.src.js'\r\n        ]\r\n        return Promise.all(_.map(includes, f => {\r\n            return new Promise<string>((resolve, reject) => {\r\n                readFile(path.join(option.jspmConfig, f), 'utf8', (err, data) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    } else {\r\n                        resolve(data);\r\n                    }\r\n                });\r\n            });\r\n        }))\r\n            .then(data => {\r\n                data.push(output);\r\n                mkdirp.sync(path.dirname(mainfile));\r\n                var stream = <NodeJS.ReadWriteStream>source(mainfile);\r\n                stream.write(data.join('\\n'));\r\n                process.nextTick(() => {\r\n                    stream.end();\r\n                });\r\n\r\n                return super.working(stream.pipe(vinylBuffer()), config, option, gulp, option.mainfilePipes);\r\n            });\r\n\r\n        // if (!existsSync(mainfile)) {\r\n        //     mkdirp.sync(path.dirname(mainfile));\r\n\r\n        //     writeFileSync(mainfile, output, { flag: 'wx' });\r\n        // } else {\r\n        //     writeFileSync(mainfile, output);\r\n        // }\r\n\r\n        // console.log(chalk.green('Manifest written'));\r\n\r\n        // return Promise.resolve(true);\r\n\r\n    }\r\n\r\n    private getBundleManifestPath(option: IBundlesConfig): string {\r\n        var url = option.baseURL;\r\n        return path.join(url, option.mainfile);\r\n    }\r\n    private getBundleManifest(option: IBundlesConfig): any {\r\n        let data: any = {};\r\n        let path: string = this.getBundleManifestPath(option);\r\n        if (existsSync(path)) {\r\n            try {\r\n                let content = readFileSync(path, 'utf8');\r\n                let idx = content.indexOf(this.manifestSplit);\r\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\r\n                content = content.substring(idx);\r\n                // console.log(content);\r\n                writeFileSync(path, content);\r\n                data = require(path);\r\n                console.log('has old bundle：\\n', chalk.cyan(path)); // , 'data:\\n', data);\r\n            } catch (e) {\r\n                console.log(chalk.red(e));\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    private getBundleShortPath(config: IJspmTaskConfig, bundleName: string, bundleGp?: IBundleGroup) {\r\n        var fullPath = bundleGp ? this.getBundleDest(config, bundleName, bundleGp)\r\n            : path.join(config.getDist(), bundleName);\r\n\r\n        let spath: string = path.relative(config.option.baseURL, fullPath);\r\n        spath = spath.replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n        return spath;\r\n    }\r\n\r\n    private getBundleDest(config: IJspmTaskConfig, bundleName: string, bundleGp: IBundleGroup) {\r\n\r\n        let dest = config.getDist();\r\n        let min = bundleGp.builder.minify;\r\n        let name = bundleGp.items[bundleName] || bundleName;\r\n        let file = name + ((min) ? '.min.js' : '.js');\r\n\r\n        if (bundleGp.combine) {\r\n            dest = path.join(dest, file);\r\n        } else {\r\n            dest = path.join(dest, bundleName, file);\r\n        }\r\n\r\n        return dest;\r\n    }\r\n}\r\n"]}