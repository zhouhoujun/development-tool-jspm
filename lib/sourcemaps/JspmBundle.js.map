{"version":3,"sources":["JspmBundle.js","JspmBundle.ts"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","_typeof","decorate","i","defineProperty","__metadata","k","v","metadata","_","require","development_core_1","path","fs_1","chalk","globby","jspm","source","vinylBuffer","chksum","mkdirp","JspmBundle","info","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","call","name","runWay","RunWay","sequence","packages","manifestSplit","_inherits","_development_core_1$P","_createClass","value","config","option","ctx","console","log","dirname","packageFile","setPackagePath","jsbuilder","Builder","separateCSS","builder","Promise","resolve","then","jspmConfig","loadConfig","undefined","dist","gulp","_this2","bundles","all","map","getbundles","loadBuilder","bundle","defaults","groupBundle","groups","flatten","src","getSrc","getInfo","cyan","files","getRelativeSrc","createBundler","join","mainfile","_this3","toModule","baseURL","isArray","s","filename","relative","replace","toModulePath","fn","substring","extname","extend","dest","file","systemConfigTempl","relationToRoot","bust","includePackageFiles","jspmMates","*.css","loader","*.json","*.jsx","sfx","minify","mangle","sourceMaps","lowResSourceMaps","toRootPath","pkg","getPackage","jspmPackages","directories","readdirSync","red","process","exit","_this4","_get","prototype","calcChecksums","checksums","updateBundleManifest","manifest","writeBundleManifest","green","initOption","pipes","output","_this5","bundlemap","shortPath","modules","push","bundleName","bundleDest","env","gb","uniq","split","keys","filter","f","bundleGp","_this6","bundleStr","bundleItems","minusStr","exclusionString","exclude","items","combine","getBundleDest","str","exclusionArray","_this7","minus","forEach","item","group","concat","builderCfg","bundler","buildStatic","getBundleShortPath","parse","base","bind","sync","stream","write","nextTick","end","pipe","chksums","isObject","reject","filepath","err","sum","error","getBundleManifest","each","_this8","root","template","maps","css","json","n","test","first","jspmMetas","JSON","stringify","jspmMeta","paths","getBundleManifestPath","includes","readFile","data","mainoption","clone","bindingConfig","mainfilePipes","mainfileOutput","url","existsSync","content","readFileSync","idx","indexOf","writeFileSync","e","fullPath","getDist","spath","min","PipeTask","task","oper","Operation","release","deploy","exports"],"mappings":"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","file":"../JspmBundle.js","sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nconst _ = require('lodash');\nconst development_core_1 = require('development-core');\nconst path = require('path');\nconst fs_1 = require('fs');\nconst chalk = require('chalk');\nconst globby = require('globby');\nconst jspm = require('jspm');\nconst source = require('vinyl-source-stream');\nconst vinylBuffer = require('vinyl-buffer');\nconst chksum = require('checksum');\nconst mkdirp = require('mkdirp');\nlet JspmBundle = class JspmBundle extends development_core_1.PipeTask {\n    constructor(info) {\n        super(info);\n        this.name = 'jspm-bundle';\n        this.runWay = development_core_1.RunWay.sequence;\n        this.packages = {};\n        this.manifestSplit = `/*------bundles infos------*/`;\n    }\n    getOption(config) {\n        return config.option;\n    }\n    loadBuilder(ctx) {\n        let option = ctx.option;\n        console.log(path.dirname(option.packageFile));\n        jspm.setPackagePath(path.dirname(option.packageFile));\n        let jsbuilder = new jspm.Builder({ separateCSS: option.builder.separateCSS });\n        return Promise.resolve(jsbuilder)\n            .then(builder => {\n            console.log(option.jspmConfig);\n            if (option.jspmConfig) {\n                return builder.loadConfig(option.jspmConfig, undefined, true)\n                    .then(() => {\n                    return builder;\n                });\n            }\n            else {\n                return builder;\n            }\n        });\n    }\n    source(ctx, dist, gulp) {\n        let option = ctx.option;\n        if (option.bundles) {\n            return Promise.all(_.map(this.getbundles(ctx), name => {\n                return this.loadBuilder(ctx)\n                    .then(builder => {\n                    let bundle = option.bundles[name];\n                    bundle.builder = _.defaults(bundle.builder, option.builder);\n                    if (option.builder.config) {\n                        builder.config(bundle.builder.config);\n                    }\n                    return this.groupBundle(ctx, builder, name, bundle, gulp);\n                });\n            })).then(groups => {\n                return _.flatten(groups);\n            });\n        }\n        else {\n            return this.loadBuilder(ctx)\n                .then(builder => {\n                let src = ctx.getSrc(this.getInfo());\n                console.log('start bundle all src : ', chalk.cyan(src));\n                if (option.builder.config) {\n                    builder.config(option.builder.config);\n                }\n                return Promise.resolve(globby(src))\n                    .then(files => {\n                    files = this.getRelativeSrc(files, ctx);\n                    console.log(files);\n                    return this.createBundler(ctx, builder, 'bundle', files.join(' + '), option.mainfile, option.builder);\n                });\n            });\n        }\n    }\n    getRelativeSrc(src, config, toModule = false) {\n        // console.log(option.baseURL);\n        let baseURL = config.option.baseURL;\n        if (_.isArray(src)) {\n            return _.map(src, s => {\n                let filename = path.relative(baseURL, s).replace(/\\\\/g, '/').replace(/^\\//g, '');\n                return toModule ? this.toModulePath(filename) : filename;\n            });\n        }\n        else {\n            let fn = path.relative(baseURL, src).replace(/\\\\/g, '/').replace(/^\\//g, '');\n            return [(toModule ? this.toModulePath(fn) : fn)];\n        }\n    }\n    toModulePath(filename) {\n        if (!filename) {\n            return '';\n        }\n        return filename.substring(0, filename.length - path.extname(filename).length);\n    }\n    initOption(ctx) {\n        let option = _.extend({\n            baseURL: '',\n            mainfile: 'bundle.js',\n            jspmConfig: '',\n            packageFile: 'package.json',\n            dest: '',\n            file: '',\n            systemConfigTempl: '',\n            relationToRoot: '',\n            bust: '',\n            bundles: null,\n            includePackageFiles: [\n                'system-polyfills.src.js',\n                'system.src.js'\n            ],\n            jspmMates: {\n                '*.css': {\n                    loader: 'css'\n                },\n                '*.json': {\n                    loader: 'json'\n                },\n                '*.jsx': {\n                    loader: 'jsx'\n                }\n            },\n            builder: {\n                sfx: false,\n                minify: false,\n                mangle: false,\n                sourceMaps: false,\n                separateCSS: false,\n                lowResSourceMaps: true\n            }\n        }, ctx.option);\n        option.baseURL = ctx.toRootPath(option.baseURL);\n        if (option.jspmConfig) {\n            option.jspmConfig = ctx.toRootPath(option.jspmConfig);\n        }\n        option.packageFile = ctx.toRootPath(option.packageFile);\n        let pkg = this.getPackage(option);\n        if (!option.jspmPackages) {\n            if (pkg.jspm.directories && pkg.jspm.directories.packages) {\n                option.jspmPackages = pkg.jspm.directories.packages;\n            }\n            else {\n                option.jspmPackages = 'jspm_packages';\n            }\n        }\n        option.jspmPackages = ctx.toRootPath(option.jspmPackages);\n        if (!fs_1.readdirSync(option.jspmPackages)) {\n            console.log(chalk.red('jspm project config error!'));\n            process.exit(0);\n        }\n        return option;\n    }\n    execute(ctx, gulp) {\n        this.bundles = [];\n        return super.execute(ctx, gulp)\n            .then(() => {\n            let option = ctx.option;\n            if (option.bundles) {\n                if (option.bust) {\n                    return this.calcChecksums(option, this.bundles).then((checksums) => {\n                        return this.updateBundleManifest(option, this.bundles, checksums);\n                    });\n                }\n                else {\n                    return this.updateBundleManifest(option, this.bundles);\n                }\n            }\n            else {\n                return null;\n            }\n        }).then(manifest => {\n            if (manifest) {\n                return this.writeBundleManifest(ctx, manifest, gulp)\n                    .then(() => {\n                    console.log(chalk.green('------ Complete -------------'));\n                });\n            }\n            else {\n                console.log(chalk.green('------ Complete -------------'));\n                return null;\n            }\n        });\n    }\n    setup(ctx, gulp) {\n        ctx.option = this.initOption(ctx);\n        return super.setup(ctx, gulp);\n    }\n    working(source, ctx, option, gulp, pipes, output) {\n        let bundle = source['bundle'];\n        return super.working(source, ctx, option, gulp, pipes, output)\n            .then(() => {\n            let bundlemap = {\n                path: bundle.shortPath,\n                modules: bundle.modules\n            };\n            this.bundles.push(bundlemap);\n            if (bundle.sfx) {\n                console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\n            }\n            else {\n                console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\n            }\n            return;\n        });\n    }\n    getbundles(ctx) {\n        let option = ctx.option;\n        console.log('gb:', ctx.env.gb);\n        let groups = [];\n        if (ctx.env.gb) {\n            groups = _.uniq(_.isArray(ctx.env.gb) ? ctx.env.gb : (ctx.env.gb || '').split(','));\n        }\n        if (groups.length < 1) {\n            groups = _.keys(option.bundles);\n        }\n        else {\n            groups = _.filter(groups, f => f && groups[f]);\n        }\n        console.log('cmmand group bundle:', groups);\n        return groups;\n    }\n    groupBundle(config, builder, name, bundleGp, gulp) {\n        let option = config.option;\n        let bundleStr = '';\n        let bundleDest = '';\n        let bundleItems = [];\n        let minusStr = this.exclusionString(bundleGp.exclude, option.bundles);\n        if (bundleGp.items) {\n            bundleItems = _.isArray(bundleItems) ? bundleGp.items : _.keys(bundleGp.items);\n        }\n        console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(bundleItems)}\\n-------------------------------`);\n        if (bundleGp.combine) {\n            bundleDest = this.getBundleDest(config, name, bundleGp);\n            bundleStr = bundleItems.join(' + ') + minusStr;\n            return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleGp.builder, bundleGp);\n        }\n        else {\n            return Promise.all(bundleItems.map(key => {\n                bundleStr = key + minusStr;\n                bundleDest = this.getBundleDest(config, key, bundleGp);\n                return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleGp.builder, bundleGp);\n            }));\n        }\n    }\n    exclusionString(exclude, groups) {\n        let str = this.exclusionArray(exclude, groups).join(' - ');\n        return (str) ? ' - ' + str : '';\n    }\n    exclusionArray(exclude, groups) {\n        let minus = [];\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\n        _.forEach(exclude, (item) => {\n            var group = groups[item];\n            if (group) {\n                // exclude everything from this group\n                minus = minus.concat(this.exclusionArray(group.items, groups));\n            }\n            else {\n                // exclude this item by name\n                minus.push(item);\n            }\n        });\n        return minus;\n    }\n    createBundler(config, builder, bundleName, bundleStr, bundleDest, builderCfg, bundleGp) {\n        let sfx = builderCfg.sfx;\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleGp);\n        let filename = path.parse(bundleDest).base;\n        return bundler.bind(builder)(bundleStr, bundleDest, builderCfg)\n            .then(output => {\n            mkdirp.sync(path.dirname(bundleDest));\n            var stream = source(filename);\n            stream.write(output.source);\n            process.nextTick(function () {\n                stream.end();\n            });\n            return stream.pipe(vinylBuffer());\n        })\n            .then(output => {\n            output['bundle'] = {\n                sfx: sfx,\n                path: shortPath,\n                bundleName: bundleName,\n                filename: filename,\n                bundleDest: bundleDest,\n                modules: output.modules\n            };\n            return output;\n        });\n    }\n    getPackage(option) {\n        if (!this.packages[option.packageFile]) {\n            this.packages[option.packageFile] = require(option.packageFile);\n        }\n        return this.packages[option.packageFile];\n    }\n    calcChecksums(option, bundles) {\n        let chksums = {};\n        console.log('Calculating checksums...');\n        return Promise.all(_.map(bundles, (bundle) => {\n            if (!_.isObject(bundle)) {\n                return null;\n            }\n            return new Promise((resolve, reject) => {\n                let filepath = path.join(option.baseURL, bundle.path);\n                let filename = path.parse(bundle.path).base;\n                chksum.file(filepath, (err, sum) => {\n                    if (err) {\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\n                    }\n                    console.log(filename, chalk.cyan(sum));\n                    chksums[bundle.path] = sum;\n                    resolve(chksums);\n                });\n            });\n        })).then(() => {\n            return chksums;\n        });\n    }\n    updateBundleManifest(option, bundles, chksums) {\n        chksums = chksums || {};\n        var manifest = _.defaults(this.getBundleManifest(option), {\n            bundles: {},\n            chksums: {}\n        });\n        // console.log(manifest);\n        _.each(bundles, bundle => {\n            if (bundle.path) {\n                manifest.bundles[bundle.path] = bundle.modules;\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\n            }\n        });\n        return manifest;\n    }\n    writeBundleManifest(config, manifest, gulp) {\n        let option = config.option;\n        if (!option.mainfile) {\n            return Promise.reject('mainfile not configed.');\n        }\n        console.log('Writing manifest...');\n        let output = `\r\nSystem.config({\r\n    baseURL: '${path.relative(option.baseURL, config.env.root) || '.'}',\r\n    defaultJSExtensions: true\r\n});\r\nSystem.bundled = true;\r\nSystem.bust = '${option.bust}';\r\nif(window != undefined) window.prod = true;\r\n${this.manifestSplit}\r\n`;\n        let template = '';\n        if (manifest) {\n            // try {\n            template = option.systemConfigTempl;\n            if (!template) {\n                template = (option.bust) ? `\r\n(function(module) {\r\n    var bust = {};\r\n    var systemLocate = System.locate;\r\n    var systemNormalize = System.normalize;\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var chksums = module.exports.chksums = \\${chksums};\r\n    var bundles = module.exports.bundles = \\${bundles};                    \r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n    System.normalize = function (name, pName, pAddress) {\r\n        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n            var chksum = chksums[name];\r\n            if (chksums[name]) { bust[address] = chksum; }\r\n            return address;\r\n        });\r\n    };\r\n\r\n    System.locate = function (load) {\r\n        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n            var chksum = bust[address];\r\n            return (chksum) ? address + '?' + chksum : address;\r\n        });\r\n    };\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n` : `\r\n(function(module) {\r\n    var bundles = module.exports.bundles = \\${bundles};\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n`;\n            }\n            let maps = {\n                css: 'github:systemjs/plugin-css@0.1.20.js',\n                json: 'github:systemjs/plugin-json@0.1.2.js'\n            };\n            _.each(_.keys(manifest.bundles), n => {\n                if (/css.min.js$/.test(n)) {\n                    maps.css = _.first(manifest.bundles[n]);\n                }\n                if (/json.min.js$/.test(n)) {\n                    maps.css = _.first(manifest.bundles[n]);\n                }\n            });\n            let jspmMetas = option.jspmMates;\n            output += _.template(template)({\n                maps: JSON.stringify(maps, null, '    '),\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\n                paths: JSON.stringify(config.option.builder.config ? config.option.builder.config.paths : null, null, '    '),\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\n            });\n        }\n        let mainfile = this.getBundleManifestPath(option);\n        let includes = option.includes || [];\n        includes = includes.concat(_.map(option.includePackageFiles, f => path.join(option.jspmPackages, f)));\n        return Promise.all(_.map(includes, f => {\n            return new Promise((resolve, reject) => {\n                fs_1.readFile(path.join(option.jspmConfig, f), 'utf8', (err, data) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(data);\n                    }\n                });\n            });\n        }))\n            .then(data => {\n            data.push(output);\n            mkdirp.sync(path.dirname(mainfile));\n            var stream = source(mainfile);\n            stream.write(data.join('\\n'));\n            process.nextTick(() => {\n                stream.end();\n            });\n            console.log('relative:', path.relative(config.env.root, config.toRootPath(option.mainfile)));\n            let mainoption = {\n                env: config.env,\n                option: _.extend(_.clone(config.option), {\n                    dist: path.dirname(path.relative(config.env.root, config.toRootPath(option.mainfile)))\n                })\n            };\n            return super.working(stream.pipe(vinylBuffer()), development_core_1.bindingConfig(mainoption), mainoption, gulp, option.mainfilePipes, option.mainfileOutput);\n        });\n    }\n    getBundleManifestPath(option) {\n        var url = option.baseURL;\n        return path.join(url, option.mainfile);\n    }\n    getBundleManifest(option) {\n        let data = {};\n        let path = this.getBundleManifestPath(option);\n        if (fs_1.existsSync(path)) {\n            try {\n                let content = fs_1.readFileSync(path, 'utf8');\n                let idx = content.indexOf(this.manifestSplit);\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\n                content = content.substring(idx);\n                // console.log(content);\n                fs_1.writeFileSync(path, content);\n                data = require(path);\n                console.log('has old bundle：\\n', chalk.cyan(path)); // , 'data:\\n', data);\n            }\n            catch (e) {\n                console.log(chalk.red(e));\n            }\n        }\n        return data;\n    }\n    getBundleShortPath(config, bundleName, bundleGp) {\n        var fullPath = bundleGp ? this.getBundleDest(config, bundleName, bundleGp)\n            : path.join(config.getDist(), bundleName);\n        let spath = path.relative(config.option.baseURL, fullPath);\n        spath = spath.replace(/\\\\/g, '/').replace(/^\\//g, '');\n        return spath;\n    }\n    getBundleDest(config, bundleName, bundleGp) {\n        let dest = config.getDist();\n        let min = bundleGp.builder.minify;\n        let name = bundleGp.items[bundleName] || bundleName;\n        let file = name + ((min) ? '.min.js' : '.js');\n        if (bundleGp.combine) {\n            dest = path.join(dest, file);\n        }\n        else {\n            dest = path.join(dest, bundleName, file);\n        }\n        return dest;\n    }\n};\nJspmBundle = __decorate([\n    development_core_1.task({\n        oper: development_core_1.Operation.release | development_core_1.Operation.deploy\n    }), \n    __metadata('design:paramtypes', [Object])\n], JspmBundle);\nexports.JspmBundle = JspmBundle;\n","import * as _ from 'lodash';\r\nimport { task, RunWay, IAssertDist, ITaskContext, Src, Pipe, OutputPipe, ITaskInfo, TransformSource, ITransform, Operation, PipeTask, bindingConfig } from 'development-core';\r\nimport { Gulp } from 'gulp';\r\nimport * as path from 'path';\r\nimport { IJspmTaskConfig, IBundlesConfig, IBundleGroup, IBuidlerConfig } from './config';\r\n\r\nimport { readFileSync, readFile, existsSync, writeFileSync, readdirSync } from 'fs';\r\nimport * as chalk from 'chalk';\r\nconst globby = require('globby');\r\nconst jspm = require('jspm');\r\nconst source = require('vinyl-source-stream');\r\nconst vinylBuffer = require('vinyl-buffer');\r\nconst chksum = require('checksum');\r\nconst mkdirp = require('mkdirp');\r\n// const uglify = require('gulp-uglify');\r\n\r\nexport interface IBundleMap {\r\n    path: string;\r\n    modules: Src\r\n}\r\n\r\n@task({\r\n    oper: Operation.release | Operation.deploy\r\n})\r\nexport class JspmBundle extends PipeTask {\r\n\r\n    name = 'jspm-bundle';\r\n    runWay = RunWay.sequence;\r\n    private bundles: IBundleMap[];\r\n    constructor(info?: ITaskInfo) {\r\n        super(info);\r\n    }\r\n\r\n    protected getOption(config: ITaskContext): IAssertDist {\r\n        return config.option;\r\n    }\r\n\r\n    protected loadBuilder(ctx: ITaskContext): Promise<any> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        console.log(path.dirname(option.packageFile));\r\n        jspm.setPackagePath(path.dirname(option.packageFile));\r\n        let jsbuilder = new jspm.Builder({ separateCSS: option.builder.separateCSS });\r\n\r\n        return Promise.resolve(jsbuilder)\r\n            .then(builder => {\r\n                console.log(option.jspmConfig);\r\n                if (option.jspmConfig) {\r\n                    return builder.loadConfig(option.jspmConfig, undefined, true)\r\n                        .then(() => {\r\n                            return builder;\r\n                        });\r\n                } else {\r\n                    return builder;\r\n                }\r\n            });\r\n    }\r\n\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (option.bundles) {\r\n            return Promise.all(_.map(this.getbundles(ctx), name => {\r\n                return this.loadBuilder(ctx)\r\n                    .then(builder => {\r\n                        let bundle: IBundleGroup = option.bundles[name];\r\n                        bundle.builder = <IBuidlerConfig>_.defaults(bundle.builder, option.builder);\r\n                        if (option.builder.config) {\r\n                            builder.config(bundle.builder.config);\r\n                        }\r\n                        return this.groupBundle(<IJspmTaskConfig>ctx, builder, name, bundle, gulp);\r\n                    });\r\n            })).then(groups => {\r\n                return _.flatten(groups);\r\n            });\r\n        } else {\r\n            return this.loadBuilder(ctx)\r\n                .then(builder => {\r\n                    let src = ctx.getSrc(this.getInfo());\r\n                    console.log('start bundle all src : ', chalk.cyan(<any>src));\r\n                    if (option.builder.config) {\r\n                        builder.config(option.builder.config)\r\n                    }\r\n\r\n                    return Promise.resolve<string[]>(globby(src))\r\n                        .then(files => {\r\n                            files = this.getRelativeSrc(files, <IJspmTaskConfig>ctx);\r\n                            console.log(files);\r\n                            return this.createBundler(<IJspmTaskConfig>ctx, builder, 'bundle', files.join(' + '), option.mainfile, option.builder);\r\n                        });\r\n                });\r\n        }\r\n    }\r\n\r\n    private getRelativeSrc(src: Src, config: IJspmTaskConfig, toModule = false): string[] {\r\n        // console.log(option.baseURL);\r\n        let baseURL = config.option.baseURL\r\n        if (_.isArray(src)) {\r\n            return _.map(src, s => {\r\n                let filename = path.relative(baseURL, s).replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n                return toModule ? this.toModulePath(filename) : filename;\r\n            });\r\n        } else {\r\n            let fn = path.relative(baseURL, src).replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n            return [(toModule ? this.toModulePath(fn) : fn)];\r\n        }\r\n    }\r\n\r\n    private toModulePath(filename: string): string {\r\n        if (!filename) {\r\n            return '';\r\n        }\r\n        return filename.substring(0, filename.length - path.extname(filename).length);\r\n    }\r\n\r\n    private initOption(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>_.extend(<IBundlesConfig>{\r\n            baseURL: '',\r\n            mainfile: 'bundle.js',\r\n            jspmConfig: '',\r\n            packageFile: 'package.json',\r\n            dest: '',\r\n            file: '',\r\n            systemConfigTempl: '',\r\n            relationToRoot: '',\r\n            bust: '',\r\n            bundles: null,\r\n            includePackageFiles: [\r\n                'system-polyfills.src.js',\r\n                'system.src.js'\r\n            ],\r\n            jspmMates: {\r\n                '*.css': {\r\n                    loader: 'css'\r\n                },\r\n                '*.json': {\r\n                    loader: 'json'\r\n                },\r\n                '*.jsx': {\r\n                    loader: 'jsx'\r\n                }\r\n            },\r\n            builder: {\r\n                sfx: false,\r\n                minify: false,\r\n                mangle: false,\r\n                sourceMaps: false,\r\n                separateCSS: false,\r\n                lowResSourceMaps: true\r\n            }\r\n        }, <IBundlesConfig>ctx.option);\r\n\r\n        option.baseURL = ctx.toRootPath(option.baseURL);\r\n        if (option.jspmConfig) {\r\n            option.jspmConfig = ctx.toRootPath(option.jspmConfig);\r\n        }\r\n        option.packageFile = ctx.toRootPath(option.packageFile);\r\n\r\n        let pkg = this.getPackage(option);\r\n        if (!option.jspmPackages) {\r\n            if (pkg.jspm.directories && pkg.jspm.directories.packages) {\r\n                option.jspmPackages = <string>pkg.jspm.directories.packages;\r\n            } else {\r\n                option.jspmPackages = 'jspm_packages';\r\n            }\r\n        }\r\n        option.jspmPackages = ctx.toRootPath(option.jspmPackages);\r\n\r\n        if (!readdirSync(option.jspmPackages)) {\r\n            console.log(chalk.red('jspm project config error!'));\r\n            process.exit(0);\r\n        }\r\n\r\n        return option;\r\n    }\r\n\r\n\r\n    execute(ctx: ITaskContext, gulp: Gulp) {\r\n        this.bundles = [];\r\n        return super.execute(ctx, gulp)\r\n            .then(() => {\r\n                let option = <IBundlesConfig>ctx.option;\r\n                if (option.bundles) {\r\n                    if (option.bust) {\r\n                        return this.calcChecksums(option, this.bundles).then((checksums) => {\r\n                            return this.updateBundleManifest(option, this.bundles, checksums);\r\n                        });\r\n                    } else {\r\n                        return this.updateBundleManifest(option, this.bundles);\r\n                    }\r\n                } else {\r\n                    return null;\r\n                }\r\n            }).then(manifest => {\r\n                if (manifest) {\r\n                    return this.writeBundleManifest(<IJspmTaskConfig>ctx, manifest, gulp)\r\n                        .then(() => {\r\n                            console.log(chalk.green('------ Complete -------------'));\r\n                        });\r\n                } else {\r\n                    console.log(chalk.green('------ Complete -------------'));\r\n                    return null;\r\n                }\r\n            });\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp: Gulp) {\r\n        ctx.option = this.initOption(ctx);\r\n        return super.setup(ctx, gulp);\r\n    }\r\n\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        let bundle = source['bundle'];\r\n        return super.working(source, ctx, option, gulp, pipes, output)\r\n            .then(() => {\r\n                let bundlemap: IBundleMap = {\r\n                    path: bundle.shortPath,\r\n                    modules: bundle.modules\r\n                };\r\n                this.bundles.push(bundlemap);\r\n                if (bundle.sfx) {\r\n                    console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                } else {\r\n                    console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                }\r\n                return;\r\n            });\r\n    }\r\n\r\n    getbundles(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        console.log('gb:', ctx.env.gb);\r\n        let groups = [];\r\n        if (ctx.env.gb) {\r\n            groups = _.uniq(_.isArray(ctx.env.gb) ? ctx.env.gb : (ctx.env.gb || '').split(','));\r\n        }\r\n\r\n        if (groups.length < 1) {\r\n            groups = _.keys(option.bundles);\r\n        } else {\r\n            groups = _.filter(groups, f => f && groups[f]);\r\n        }\r\n        console.log('cmmand group bundle:', groups);\r\n        return groups;\r\n    }\r\n\r\n    protected groupBundle(config: IJspmTaskConfig, builder, name: string, bundleGp: IBundleGroup, gulp: Gulp): Promise<ITransform | ITransform[]> {\r\n\r\n        let option: IBundlesConfig = config.option;\r\n\r\n        let bundleStr = '';\r\n        let bundleDest = '';\r\n\r\n        let bundleItems: string[] = [];\r\n        let minusStr = this.exclusionString(bundleGp.exclude, option.bundles);\r\n\r\n        if (bundleGp.items) {\r\n            bundleItems = _.isArray(bundleItems) ? <string[]>bundleGp.items : _.keys(bundleGp.items);\r\n        }\r\n\r\n        console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(<any>bundleItems)}\\n-------------------------------`);\r\n\r\n        if (bundleGp.combine) {\r\n            bundleDest = this.getBundleDest(config, name, bundleGp);\r\n            bundleStr = bundleItems.join(' + ') + minusStr;\r\n            return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n\r\n        } else {\r\n            return Promise.all(bundleItems.map(key => {\r\n                bundleStr = key + minusStr;\r\n                bundleDest = this.getBundleDest(config, key, bundleGp);\r\n                return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n            }));\r\n        }\r\n\r\n    }\r\n\r\n    private exclusionString(exclude, groups): string {\r\n        let str = this.exclusionArray(exclude, groups).join(' - ');\r\n        return (str) ? ' - ' + str : '';\r\n    }\r\n\r\n    private exclusionArray(exclude, groups): string[] {\r\n        let minus: string[] = [];\r\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\r\n        _.forEach(exclude, (item: string) => {\r\n            var group = groups[item];\r\n            if (group) {\r\n                // exclude everything from this group\r\n                minus = minus.concat(this.exclusionArray(group.items, groups));\r\n            } else {\r\n                // exclude this item by name\r\n                minus.push(item);\r\n            }\r\n        });\r\n        return minus;\r\n    }\r\n\r\n    private createBundler(config: IJspmTaskConfig, builder: any, bundleName: string, bundleStr: string, bundleDest: string, builderCfg: IBuidlerConfig, bundleGp?: IBundleGroup): Promise<ITransform> {\r\n\r\n        let sfx = builderCfg.sfx;\r\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\r\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleGp);\r\n        let filename = path.parse(bundleDest).base;\r\n\r\n        return bundler.bind(builder)(bundleStr, bundleDest, builderCfg)\r\n            .then(output => {\r\n                mkdirp.sync(path.dirname(bundleDest));\r\n                var stream: ITransform = source(filename);\r\n                stream.write(output.source);\r\n                process.nextTick(function () {\r\n                    stream.end();\r\n                });\r\n\r\n                return stream.pipe(vinylBuffer());\r\n            })\r\n            .then(output => {\r\n                output['bundle'] = {\r\n                    sfx: sfx,\r\n                    path: shortPath,\r\n                    bundleName: bundleName,\r\n                    filename: filename,\r\n                    bundleDest: bundleDest,\r\n                    modules: output.modules\r\n                };\r\n                return output;\r\n            });\r\n\r\n\r\n    }\r\n\r\n    private packages = {};\r\n    public getPackage(option: IBundlesConfig): any {\r\n        if (!this.packages[option.packageFile]) {\r\n            this.packages[option.packageFile] = require(option.packageFile);\r\n        }\r\n        return this.packages[option.packageFile]\r\n    }\r\n\r\n    private calcChecksums(option: IBundlesConfig, bundles: any[]): Promise<any> {\r\n        let chksums = {};\r\n\r\n        console.log('Calculating checksums...');\r\n\r\n        return Promise.all(_.map(bundles, (bundle: any) => {\r\n            if (!_.isObject(bundle)) {\r\n                return null;\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                let filepath = path.join(option.baseURL, bundle.path);\r\n                let filename = path.parse(bundle.path).base;\r\n                chksum.file(filepath, (err, sum) => {\r\n                    if (err) {\r\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\r\n                    }\r\n                    console.log(filename, chalk.cyan(sum));\r\n                    chksums[bundle.path] = sum;\r\n                    resolve(chksums);\r\n                });\r\n            });\r\n\r\n        })).then(() => {\r\n            return chksums;\r\n        });\r\n    }\r\n\r\n    protected updateBundleManifest(option: IBundlesConfig, bundles: any[], chksums?: any) {\r\n\r\n        chksums = chksums || {};\r\n\r\n        var manifest: any = _.defaults(this.getBundleManifest(option), {\r\n            bundles: {},\r\n            chksums: {}\r\n        });\r\n\r\n        // console.log(manifest);\r\n\r\n        _.each(bundles, bundle => {\r\n            if (bundle.path) {\r\n                manifest.bundles[bundle.path] = bundle.modules;\r\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\r\n            }\r\n        });\r\n\r\n        return manifest;\r\n\r\n    }\r\n\r\n    private manifestSplit = `/*------bundles infos------*/`;\r\n    private writeBundleManifest(config: IJspmTaskConfig, manifest, gulp: Gulp): Promise<any> {\r\n        let option = config.option;\r\n        if (!option.mainfile) {\r\n            return Promise.reject('mainfile not configed.');\r\n        }\r\n\r\n\r\n        console.log('Writing manifest...');\r\n\r\n\r\n        let output = `\r\nSystem.config({\r\n    baseURL: '${ path.relative(option.baseURL, config.env.root) || '.'}',\r\n    defaultJSExtensions: true\r\n});\r\nSystem.bundled = true;\r\nSystem.bust = '${option.bust}';\r\nif(window != undefined) window.prod = true;\r\n${this.manifestSplit}\r\n`;\r\n        let template = '';\r\n\r\n        if (manifest) {\r\n            // try {\r\n            template = option.systemConfigTempl;\r\n\r\n            if (!template) {\r\n                template = (option.bust) ? `\r\n(function(module) {\r\n    var bust = {};\r\n    var systemLocate = System.locate;\r\n    var systemNormalize = System.normalize;\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var chksums = module.exports.chksums = \\${chksums};\r\n    var bundles = module.exports.bundles = \\${bundles};                    \r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n    System.normalize = function (name, pName, pAddress) {\r\n        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n            var chksum = chksums[name];\r\n            if (chksums[name]) { bust[address] = chksum; }\r\n            return address;\r\n        });\r\n    };\r\n\r\n    System.locate = function (load) {\r\n        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n            var chksum = bust[address];\r\n            return (chksum) ? address + '?' + chksum : address;\r\n        });\r\n    };\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n` : `\r\n(function(module) {\r\n    var bundles = module.exports.bundles = \\${bundles};\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n`;\r\n            }\r\n\r\n\r\n            let maps = {\r\n                css: 'github:systemjs/plugin-css@0.1.20.js',\r\n                json: 'github:systemjs/plugin-json@0.1.2.js'\r\n            };\r\n\r\n            _.each(_.keys(manifest.bundles), n => {\r\n                if (/css.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n                if (/json.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n            });\r\n\r\n            let jspmMetas = option.jspmMates;\r\n            output += _.template(template)({\r\n                maps: JSON.stringify(maps, null, '    '),\r\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\r\n                paths: JSON.stringify(config.option.builder.config ? config.option.builder.config.paths : null, null, '    '),\r\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\r\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\r\n            });\r\n\r\n        }\r\n\r\n        let mainfile = this.getBundleManifestPath(option);\r\n\r\n\r\n        let includes = option.includes || [];\r\n\r\n        includes = includes.concat(_.map(option.includePackageFiles, f => path.join(option.jspmPackages, f)));\r\n\r\n        return Promise.all(_.map(includes, f => {\r\n            return new Promise<string>((resolve, reject) => {\r\n                readFile(path.join(option.jspmConfig, f), 'utf8', (err, data) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    } else {\r\n                        resolve(data);\r\n                    }\r\n                });\r\n            });\r\n        }))\r\n            .then(data => {\r\n                data.push(output);\r\n                mkdirp.sync(path.dirname(mainfile));\r\n                var stream = <NodeJS.ReadWriteStream>source(mainfile);\r\n                stream.write(data.join('\\n'));\r\n                process.nextTick(() => {\r\n                    stream.end();\r\n                });\r\n\r\n                console.log('relative:', path.relative(config.env.root, config.toRootPath(option.mainfile)));\r\n                let mainoption = {\r\n                    env: config.env,\r\n                    option: _.extend(_.clone(config.option), {\r\n                        dist: path.dirname(path.relative(config.env.root, config.toRootPath(option.mainfile)))\r\n                    })\r\n                };\r\n\r\n                return super.working(stream.pipe(vinylBuffer()), bindingConfig(mainoption), mainoption, gulp, option.mainfilePipes, option.mainfileOutput);\r\n            });\r\n\r\n    }\r\n\r\n    private getBundleManifestPath(option: IBundlesConfig): string {\r\n        var url = option.baseURL;\r\n        return path.join(url, option.mainfile);\r\n    }\r\n    private getBundleManifest(option: IBundlesConfig): any {\r\n        let data: any = {};\r\n        let path: string = this.getBundleManifestPath(option);\r\n        if (existsSync(path)) {\r\n            try {\r\n                let content = readFileSync(path, 'utf8');\r\n                let idx = content.indexOf(this.manifestSplit);\r\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\r\n                content = content.substring(idx);\r\n                // console.log(content);\r\n                writeFileSync(path, content);\r\n                data = require(path);\r\n                console.log('has old bundle：\\n', chalk.cyan(path)); // , 'data:\\n', data);\r\n            } catch (e) {\r\n                console.log(chalk.red(e));\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    private getBundleShortPath(config: IJspmTaskConfig, bundleName: string, bundleGp?: IBundleGroup) {\r\n        var fullPath = bundleGp ? this.getBundleDest(config, bundleName, bundleGp)\r\n            : path.join(config.getDist(), bundleName);\r\n\r\n        let spath: string = path.relative(config.option.baseURL, fullPath);\r\n        spath = spath.replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n        return spath;\r\n    }\r\n\r\n    private getBundleDest(config: IJspmTaskConfig, bundleName: string, bundleGp: IBundleGroup) {\r\n\r\n        let dest = config.getDist();\r\n        let min = bundleGp.builder.minify;\r\n        let name = bundleGp.items[bundleName] || bundleName;\r\n        let file = name + ((min) ? '.min.js' : '.js');\r\n\r\n        if (bundleGp.combine) {\r\n            dest = path.join(dest, file);\r\n        } else {\r\n            dest = path.join(dest, bundleName, file);\r\n        }\r\n\r\n        return dest;\r\n    }\r\n}\r\n"]}