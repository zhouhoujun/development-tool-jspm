{"version":3,"sources":["JspmBundle.ts"],"names":["_","require","development_core_1","path","url","fs_1","chalk","replace","jspm","source","vinylBuffer","chksum","mkdirp","JspmBundle","_super","info","_this","call","this","name","runWay","RunWay","sequence","manifestSplit","__extends","prototype","ctx","dist","gulp","option","bundles","initBundles","then","Promise","all","map","getBundles","loadBuilder","builder","bundle","bundleConfig","bcfg","getBuildConfig","defaults","config","groupBundle","trans","translate","groups","flatten","src","getSrc","getInfo","console","log","cyan","fileFilter","files","getRelativeSrc","mainfile","getBundleManifestPath","createBundler","join","execute","context","bundleMaps","calcChecksums","checksums","updateBundleManifest","manifest","writeBundleManifest","green","setup","initOption","pipes","ps","getAssertResetPipe","length","concat","working","output","bundlemap","modules","push","sfx","bundleName","filename","bundleDest","getOption","setPackagePath","dirname","toStr","packageFile","jsbuilder","Builder","separateCSS","resolve","jspmConfig","isArray","cf","loadConfig","undefined","t","stream","opt","pr","to","bundleDeps","pkg","getPackage","red","process","exit","deps","dependencies","keys","depsExclude","exclude_1","isFunction","filter","d","indexOf","isBoolean","deplibs","combine","items","cores","each","n","b","exclude","toModule","bunldeBase","bundleBaseDir","s","toUrl","toModulePath","fn","substring","extname","extend","baseURL","dest","file","systemConfigTempl","relationToRoot","bust","bundlePaths","paths","getDist","rootpath","getFolders","f","p","env","root","includePackageFiles","jspmMates","*.css","loader","*.json","*.jsx","minify","mangle","sourceMaps","lowResSourceMaps","parent","toRootPath","toRootSrc","toSrc","jspmPackages","directories","packages","readdirSync","rootURL","restps","isUndefined","resetAsserts","folders","isString","pth","toDistPath","existsSync","yellow","toDistSrc","ps_1","dist_1","baseURL_1","root_1","getRootPath","relp","fm","basename","reg","RegExp","reg2","reg3","gb","uniq","split","bundleGp","bundleStr","bundleItems","minusStr","exclusionString","getBundleDest","key","str","exclusionArray","minus","forEach","item","group","builderCfg","bundler","buildStatic","shortPath","getBundleShortPath","parse","base","bind","sync","write","nextTick","end","pipe","chksums","isObject","reject","filepath","err","sum","error","getBundleManifest","template","cssSrc_1","jsonSrc_1","textSrc_1","maps_1","css","json","text","find","it","test","jspmMetas","maps","JSON","stringify","jspmMeta","includes","readFile","data","mainfilePipes","mainfileOutput","content","readFileSync","idx","writeFileSync","e","fullPath","min","name_1","PipeTask","__decorate","task","oper","Operation","release","deploy","exports"],"mappings":"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","file":"../JspmBundle.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { IMap, task, RunWay, IAssertDist, ITaskContext, Src, Pipe, OutputPipe, ITaskInfo, TransformSource, ITransform, Operation, PipeTask, bindingConfig } from 'development-core';\r\nimport { Gulp } from 'gulp';\r\nimport * as path from 'path';\r\nimport { IBundlesConfig, IBundleGroup, IBuidlerConfig, IBundleMap, IBundleTransform } from './config';\r\nimport * as url from 'url';\r\nimport { readFileSync, readFile, existsSync, writeFileSync, readdirSync } from 'fs';\r\nimport * as chalk from 'chalk';\r\n\r\nconst replace = require('gulp-replace');\r\n// const globby = require('globby');\r\nconst jspm = require('jspm');\r\nconst source = require('vinyl-source-stream');\r\nconst vinylBuffer = require('vinyl-buffer');\r\nconst chksum = require('checksum');\r\nconst mkdirp = require('mkdirp');\r\n// const uglify = require('gulp-uglify');\r\n\r\n\r\n@task({\r\n    oper: Operation.release | Operation.deploy\r\n})\r\nexport class JspmBundle extends PipeTask {\r\n\r\n    name = 'jspm-bundle';\r\n    runWay = RunWay.sequence;\r\n    private bundleMaps: IBundleMap[];\r\n    constructor(info?: ITaskInfo) {\r\n        super(info);\r\n    }\r\n\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (option.bundles) {\r\n            return this.initBundles(<ITaskContext>ctx)\r\n                .then(() => {\r\n                    return Promise.all(_.map(this.getBundles(ctx), name => {\r\n                        return this.loadBuilder(ctx)\r\n                            .then(builder => {\r\n                                let bundle: IBundleGroup = this.bundleConfig[name];\r\n                                let bcfg = this.getBuildConfig(ctx);\r\n                                bundle.builder = <IBuidlerConfig>_.defaults(bundle.builder, bcfg);\r\n                                if (bundle.builder.config) {\r\n                                    builder.config(bundle.builder.config);\r\n                                }\r\n                                return this.groupBundle(<ITaskContext>ctx, builder, name, bundle, gulp)\r\n                                    .then(trans => this.translate(trans));\r\n                            });\r\n                    }))\r\n                }).then(groups => {\r\n                    return _.flatten(groups);\r\n                });\r\n        } else {\r\n            return this.loadBuilder(ctx)\r\n                .then(builder => {\r\n                    let src = ctx.getSrc(this.getInfo());\r\n                    console.log('start bundle all src : ', chalk.cyan(<any>src));\r\n                    let bcfg = this.getBuildConfig(ctx);\r\n                    if (bcfg.config) {\r\n                        builder.config(bcfg.config)\r\n                    }\r\n\r\n                    return ctx.fileFilter(src)\r\n                        .then(files => {\r\n                            files = this.getRelativeSrc(ctx, files);\r\n                            console.log('bundle files:', chalk.cyan(<any>files));\r\n                            let mainfile = this.getBundleManifestPath(<ITaskContext>ctx);\r\n                            return this.createBundler(<ITaskContext>ctx, builder, 'bundle', files.join(' + '), mainfile, bcfg)\r\n                                .then(trans => this.translate(trans));\r\n                        });\r\n                });\r\n        }\r\n    }\r\n\r\n    execute(context: ITaskContext, gulp: Gulp) {\r\n        this.bundleMaps = [];\r\n        let ctx = <ITaskContext>context;\r\n        return super.execute(ctx, gulp)\r\n            .then(() => {\r\n                let option = <IBundlesConfig>ctx.option;\r\n                if (option.bundles) {\r\n                    return this.calcChecksums(option, this.bundleMaps).then((checksums) => {\r\n                        return this.updateBundleManifest(ctx, this.bundleMaps, checksums);\r\n                    });\r\n                } else {\r\n                    return null;\r\n                }\r\n            }).then(manifest => {\r\n                if (manifest) {\r\n                    return this.writeBundleManifest(ctx, manifest, gulp)\r\n                        .then(() => {\r\n                            console.log(chalk.green('------ Complete -------------'));\r\n                        });\r\n                } else {\r\n                    console.log(chalk.green('------ Complete -------------'));\r\n                    return null;\r\n                }\r\n            });\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp: Gulp) {\r\n        ctx.option = this.initOption(ctx);\r\n        return super.setup(ctx, gulp);\r\n    }\r\n\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        let pipes = super.pipes(ctx, dist, gulp) || [];\r\n        let ps = this.getAssertResetPipe(ctx);\r\n        if (ps && ps.length > 0) {\r\n            pipes = pipes.concat(ps);\r\n        }\r\n        return pipes;\r\n    }\r\n\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        let bundle = <IBundleMap>source['bundle'];\r\n        return super.working(source, ctx, option, gulp, pipes, output)\r\n            .then(() => {\r\n                let bundlemap: IBundleMap = {\r\n                    path: bundle.path,\r\n                    modules: bundle.modules\r\n                };\r\n                this.bundleMaps.push(bundlemap);\r\n                if (bundle.sfx) {\r\n                    console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                } else {\r\n                    console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                }\r\n                return;\r\n            });\r\n    }\r\n\r\n\r\n    protected getOption(config: ITaskContext): IAssertDist {\r\n        return config.option;\r\n    }\r\n\r\n    protected loadBuilder(ctx: ITaskContext): Promise<any> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        jspm.setPackagePath(path.dirname(ctx.toStr(option.packageFile)));\r\n        let jsbuilder = new jspm.Builder({ separateCSS: option.builder.separateCSS });\r\n\r\n        return Promise.resolve(jsbuilder)\r\n            .then(builder => {\r\n                if (option.jspmConfig) {\r\n                    if (_.isArray(option.jspmConfig)) {\r\n                        return Promise.all(option.jspmConfig.map(cf => builder.loadConfig(cf, undefined, true)))\r\n                            .then(() => {\r\n                                return builder;\r\n                            });\r\n                    } else {\r\n                        return builder.loadConfig(option.jspmConfig, undefined, true)\r\n                            .then(() => {\r\n                                return builder;\r\n                            });\r\n                    }\r\n                } else {\r\n                    return builder;\r\n                }\r\n            });\r\n    }\r\n\r\n    private translate(trans: IBundleTransform | IBundleTransform[]): ITransform | ITransform[] {\r\n        if (_.isArray(trans)) {\r\n            return _.map(trans, t => {\r\n                t.stream['bundle'] = t.bundle;\r\n                return t.stream;\r\n            });\r\n        } else {\r\n            trans.stream['bundle'] = trans.bundle;\r\n            return trans.stream;\r\n        }\r\n    }\r\n\r\n    private bundleConfig: IMap<IBundleGroup>;\r\n    protected initBundles(ctx: ITaskContext): Promise<IMap<IBundleGroup>> {\r\n        let opt = <IBundlesConfig>ctx.option;\r\n        let pr = Promise.resolve<IMap<IBundleGroup>>(null)\r\n            .then(() => ctx.to<IMap<IBundleGroup> | Promise<IMap<IBundleGroup>>>(opt.bundles));\r\n\r\n        if (opt.bundleDeps) {\r\n            pr = pr.then(bundles => {\r\n                let pkg = ctx.getPackage(<string>opt.packageFile);\r\n                if (!pkg) {\r\n                    console.log(chalk.red('can not found package.json file.'));\r\n                    process.exit(0);\r\n                }\r\n\r\n                let deps = opt.dependencies ? ctx.to<string[]>(opt.dependencies) : _.keys(pkg.jspm.dependencies);\r\n                if (!deps || deps.length < 0) {\r\n                    console.log(chalk.red('not set bundle dependencies libs, or not setting jspm config.'));\r\n                    process.exit(0);\r\n                }\r\n                if (opt.depsExclude) {\r\n                    let exclude = _.isFunction(opt.depsExclude) ? opt.depsExclude(ctx, deps) : opt.depsExclude;\r\n                    deps = _.filter(deps, d => exclude.indexOf(d) < 0);\r\n                }\r\n\r\n                return Promise.resolve()\r\n                    .then(() => {\r\n                        if (_.isFunction(opt.bundleDeps)) {\r\n                            // opt['_bundleDepsFunc'] = opt.bundleDeps;\r\n                            return opt.bundleDeps(ctx, deps);\r\n                        } else if (_.isBoolean(opt.bundleDeps)) {\r\n                            return {\r\n                                deplibs: {\r\n                                    combine: true,\r\n                                    items: deps\r\n                                }\r\n                            };\r\n                        } else {\r\n                            return opt.bundleDeps;\r\n                        }\r\n                    })\r\n                    .then(bundleDeps => {\r\n\r\n                        let cores = _.keys(bundleDeps);\r\n                        _.each(_.keys(bundles), n => {\r\n                            let b: IBundleGroup = bundles[n];\r\n                            b.exclude = b.exclude || [];\r\n                            b.exclude = cores.concat(b.exclude);\r\n                            bundleDeps[n] = b;\r\n                        });\r\n\r\n                        return bundleDeps;\r\n                    });\r\n            });\r\n        }\r\n\r\n        return pr.then(bundles => {\r\n            this.bundleConfig = bundles;\r\n            console.log('group bundles setting:\\n', bundles, '---------------------------------\\n');\r\n            return bundles;\r\n        });\r\n\r\n    }\r\n\r\n    private getRelativeSrc(ctx: ITaskContext, src: Src, toModule = false): string[] {\r\n        let bunldeBase = <string>(<IBundlesConfig>ctx.option).bundleBaseDir;\r\n        if (_.isArray(src)) {\r\n            return _.map(src, s => {\r\n                let filename = ctx.toUrl(bunldeBase, s);\r\n                return toModule ? this.toModulePath(filename) : filename;\r\n            });\r\n        } else {\r\n            let fn = ctx.toUrl(bunldeBase, src);\r\n            return [(toModule ? this.toModulePath(fn) : fn)];\r\n        }\r\n    }\r\n\r\n    private toModulePath(filename: string): string {\r\n        if (!filename) {\r\n            return '';\r\n        }\r\n        return filename.substring(0, filename.length - path.extname(filename).length);\r\n    }\r\n\r\n    private initOption(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>_.extend({}, <IBundlesConfig>{\r\n            baseURL: '',\r\n            bundleBaseDir: '.',\r\n            mainfile: 'bundle.js',\r\n            jspmConfig: '',\r\n            packageFile: 'package.json',\r\n            dest: '',\r\n            file: '',\r\n            systemConfigTempl: '',\r\n            relationToRoot: '',\r\n            bust: '',\r\n            bundles: null,\r\n            bundlePaths(ctx) {\r\n                let paths: any = {};\r\n                let bundleDest = ctx.getDist();\r\n                let rootpath = <string>option.bundleBaseDir;\r\n                ctx.getFolders(rootpath, (f, d) => {\r\n                    if (f !== bundleDest) {\r\n                        let p = d + '/*';\r\n                        paths[p] = ctx.toUrl(ctx.env.root, path.join(rootpath, p));\r\n                    }\r\n                    return '';\r\n                });\r\n                // let jpk = <string>option.jspmPackages;\r\n                // let jp = path.basename(jpk) + '/*';\r\n                // paths[jp] = self.toUrl(rootpath, path.join(jpk, jp));\r\n                console.log('paths: ', paths);\r\n                return paths;\r\n            },\r\n            includePackageFiles: [\r\n                'system-polyfills.src.js',\r\n                'system.src.js'\r\n            ],\r\n            jspmMates: {\r\n                '*.css': {\r\n                    loader: 'css'\r\n                },\r\n                '*.json': {\r\n                    loader: 'json'\r\n                },\r\n                '*.jsx': {\r\n                    loader: 'jsx'\r\n                }\r\n            },\r\n            builder: {\r\n                sfx: false,\r\n                minify: false,\r\n                mangle: false,\r\n                sourceMaps: false,\r\n                separateCSS: false,\r\n                lowResSourceMaps: true\r\n            }\r\n        }, <IBundlesConfig>ctx.option);\r\n\r\n        ctx.option = option;\r\n\r\n        option.baseURL = ctx.toStr(option.baseURL) || './';\r\n        console.log('baseURL set as:', option.baseURL);\r\n        if (!option.bundleBaseDir && ctx.parent) {\r\n            option.bundleBaseDir = ctx.parent.getDist()\r\n        } else if (option.bundleBaseDir) {\r\n            option.bundleBaseDir = ctx.toRootPath(ctx.toStr(option.bundleBaseDir));\r\n        } else {\r\n            console.log(chalk.red('bundleBaseURL config error!'));\r\n            process.exit(0);\r\n        }\r\n\r\n        if (option.jspmConfig) {\r\n            option.jspmConfig = ctx.toRootSrc(ctx.toSrc(option.jspmConfig));\r\n        }\r\n        option.packageFile = ctx.toRootPath(ctx.toStr(option.packageFile));\r\n        option.mainfile = ctx.toStr(option.mainfile);\r\n        let pkg = ctx.getPackage(<string>option.packageFile);\r\n        if (!option.jspmPackages) {\r\n            if (pkg.jspm.directories && pkg.jspm.directories.packages) {\r\n                option.jspmPackages = <string>pkg.jspm.directories.packages;\r\n            } else {\r\n                option.jspmPackages = 'jspm_packages';\r\n            }\r\n        }\r\n        option.jspmPackages = ctx.toRootPath(ctx.toStr(option.jspmPackages));\r\n\r\n        if (!readdirSync(option.jspmPackages)) {\r\n            console.log(chalk.red('jspm project config error!'));\r\n            process.exit(0);\r\n        }\r\n\r\n        return option;\r\n    }\r\n\r\n    protected getBuildConfig(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (!option.builder.config) {\r\n            option.builder.config = _.extend(option.builder.config || {}, {\r\n                paths: ctx.to<IMap<string>>(option.bundlePaths) || {},\r\n                rootURL: <string>option.bundleBaseDir\r\n            });\r\n        }\r\n\r\n        return option.builder;\r\n    }\r\n\r\n    private restps: Pipe[];\r\n    protected getAssertResetPipe(ctx: ITaskContext) {\r\n        if (!this.restps) {\r\n            let option = <IBundlesConfig>ctx.option;\r\n            if (_.isUndefined(option.resetAsserts)) {\r\n                option.resetAsserts = 'assets';\r\n            }\r\n            if (option.resetAsserts) {\r\n                let folders: string[];\r\n                if (_.isString(option.resetAsserts)) {\r\n                    let pth = ctx.toDistPath(option.resetAsserts, this.getInfo());\r\n                    if (existsSync(pth)) {\r\n                        folders = ctx.getFolders(pth);\r\n                        folders.push(pth);\r\n                    } else {\r\n                        console.log(chalk.yellow('rest css asserts folders:', pth, 'not exists.'))\r\n                    }\r\n                } else {\r\n                    folders = <string[]>ctx.toDistSrc(option.resetAsserts, this.getInfo());\r\n                }\r\n\r\n                folders = folders || [];\r\n\r\n                let ps = [];\r\n                let dist = ctx.getDist(this.getInfo());\r\n                let baseURL = <string>option.baseURL; // ctx.toUrl(ctx.getRootPath(), <string>option.baseURL) || '.';\r\n                let root = ctx.getRootPath();\r\n                _.each(folders, f => {\r\n                    let relp = url.resolve(baseURL,  ctx.toUrl(root, ctx.toUrl(dist, f)));\r\n                    let fm = path.basename(f);\r\n                    console.log('reset css url folder name:', chalk.cyan(fm), 'relate url:', chalk.cyan(relp));\r\n                    let reg = new RegExp(`(url\\\\((\\\\.\\\\.\\\\/)+${fm})|(url\\\\(\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg, `url(${relp}`));\r\n                    let reg2 = new RegExp(`(url\\\\(\\\\\\\\'(\\\\.\\\\.\\\\/)+${fm})|(url\\\\(\\\\\\\\'\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg2, `url(\\\\'${relp}`));\r\n                    let reg3 = new RegExp(`(url\\\\((\"\\\\.\\\\.\\\\/)+${fm})|(url\\\\(\"\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg3, `url(\"${relp}`));\r\n                });\r\n                this.restps = ps;\r\n            } else {\r\n                this.restps = [];\r\n            }\r\n        }\r\n        return this.restps;\r\n    }\r\n\r\n\r\n    protected getBundles(ctx: ITaskContext) {\r\n\r\n        let groups = [];\r\n        if (ctx.env.gb) {\r\n            groups = _.uniq(_.isArray(ctx.env.gb) ? ctx.env.gb : (ctx.env.gb || '').split(','));\r\n        }\r\n\r\n        if (groups.length < 1) {\r\n            groups = _.keys(this.bundleConfig);\r\n        } else {\r\n            groups = _.filter(groups, f => f && this.bundleConfig[f]);\r\n        }\r\n        console.log('cmmand group bundle:', chalk.cyan(<any>groups));\r\n        return groups;\r\n    }\r\n\r\n    protected groupBundle(config: ITaskContext, builder, name: string, bundleGp: IBundleGroup, gulp: Gulp): Promise<IBundleTransform | IBundleTransform[]> {\r\n\r\n        let bundleStr = '';\r\n        let bundleDest = '';\r\n\r\n        let bundleItems: string[] = [];\r\n        let minusStr = this.exclusionString(bundleGp.exclude, this.bundleConfig);\r\n\r\n        if (bundleGp.items) {\r\n            bundleItems = _.isArray(bundleItems) ? <string[]>bundleGp.items : _.keys(bundleGp.items);\r\n        }\r\n\r\n        if (bundleGp.combine) {\r\n            bundleDest = this.getBundleDest(config, name, bundleGp);\r\n            bundleStr = bundleItems.join(' + ') + minusStr;\r\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup source:\\n  ${chalk.cyan(bundleStr)}\\n-------------------------------`);\r\n            return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n\r\n        } else {\r\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(<any>bundleItems)}\\n-------------------------------`);\r\n            return Promise.all(bundleItems.map(key => {\r\n                bundleStr = key + minusStr;\r\n                bundleDest = this.getBundleDest(config, key, bundleGp);\r\n                return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n            }));\r\n        }\r\n    }\r\n\r\n    private exclusionString(exclude, groups): string {\r\n        let str = this.exclusionArray(exclude, groups).join(' - ');\r\n        return (str) ? ' - ' + str : '';\r\n    }\r\n\r\n    private exclusionArray(exclude, groups): string[] {\r\n        let minus: string[] = [];\r\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\r\n        _.forEach(exclude, (item: string) => {\r\n            var group = groups[item];\r\n            if (group) {\r\n                // exclude everything from this group\r\n                minus = minus.concat(this.exclusionArray(group.items, groups));\r\n            } else {\r\n                // exclude this item by name\r\n                minus.push(item);\r\n            }\r\n        });\r\n        return minus;\r\n    }\r\n\r\n    private createBundler(config: ITaskContext, builder: any, bundleName: string, bundleStr: string, bundleDest: string, builderCfg: IBuidlerConfig, bundleGp?: IBundleGroup): Promise<IBundleTransform> {\r\n\r\n        let sfx = builderCfg.sfx;\r\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\r\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleGp);\r\n        let filename = path.parse(bundleDest).base;\r\n\r\n        return bundler.bind(builder)(bundleStr, bundleDest, builderCfg)\r\n            .then(output => {\r\n                mkdirp.sync(path.dirname(bundleDest));\r\n                var stream: ITransform = source(filename);\r\n                stream.write(output.source);\r\n                process.nextTick(function () {\r\n                    stream.end();\r\n                });\r\n\r\n                console.log('pipe bundling：', chalk.cyan(bundleName));\r\n                return {\r\n                    stream: stream.pipe(vinylBuffer()),\r\n                    bundle: {\r\n                        path: shortPath,\r\n                        sfx: sfx,\r\n                        bundleName: bundleName,\r\n                        filename: filename,\r\n                        bundleDest: bundleDest,\r\n                        modules: output.modules\r\n                    }\r\n                };\r\n            });\r\n\r\n    }\r\n\r\n    private calcChecksums(option: IBundlesConfig, bundles: any[]): Promise<any> {\r\n        let chksums = {};\r\n\r\n        console.log('Calculating checksums...');\r\n\r\n        return Promise.all(_.map(bundles, (bundle: any) => {\r\n            if (!_.isObject(bundle)) {\r\n                return null;\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                let filepath = path.join(<string>option.bundleBaseDir || '.', bundle.path);\r\n                let filename = path.parse(bundle.path).base;\r\n                chksum.file(filepath, (err, sum) => {\r\n                    if (err) {\r\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\r\n                    }\r\n                    console.log(filename, chalk.cyan(sum));\r\n                    chksums[bundle.path] = sum;\r\n                    resolve(chksums);\r\n                });\r\n            });\r\n\r\n        })).then(() => {\r\n            return chksums;\r\n        });\r\n    }\r\n\r\n    protected updateBundleManifest(ctx: ITaskContext, bundles: any[], chksums?: any) {\r\n\r\n        chksums = chksums || {};\r\n\r\n        var manifest: any = _.defaults(this.getBundleManifest(ctx), {\r\n            bundles: {},\r\n            chksums: {}\r\n        });\r\n\r\n        // console.log(manifest);\r\n\r\n        _.each(bundles, bundle => {\r\n            if (bundle.path) {\r\n                manifest.bundles[bundle.path] = bundle.modules;\r\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\r\n            }\r\n        });\r\n\r\n        return manifest;\r\n\r\n    }\r\n\r\n    private manifestSplit = `/*------bundles infos------*/`;\r\n    private writeBundleManifest(ctx: ITaskContext, manifest, gulp: Gulp): Promise<any> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (!option.mainfile) {\r\n            return Promise.reject('mainfile not configed.');\r\n        }\r\n\r\n\r\n        console.log('Writing manifest...');\r\n\r\n        let baseURL = ctx.toUrl(<string>option.baseURL) || '.';\r\n        console.log('system config baseURL: ', chalk.cyan(baseURL));\r\n\r\n        let bust = ctx.toStr(option.bust);\r\n        console.log('system bust: ', chalk.cyan(bust));\r\n\r\n        let output = `\r\nSystem.config({\r\n    baseURL: '${baseURL}',\r\n    defaultJSExtensions: true\r\n});\r\nSystem.bundled = true;\r\nSystem.bust = '${bust}';\r\nif(window != undefined) window.prod = true;\r\n${this.manifestSplit}\r\n`;\r\n        let template = '';\r\n\r\n        if (manifest) {\r\n            // try {\r\n            template = ctx.toStr(option.systemConfigTempl);\r\n\r\n            if (!template) {\r\n                template = (bust) ? `\r\n(function(module) {\r\n    var bust = {};\r\n    var systemLocate = System.locate;\r\n    var systemNormalize = System.normalize;\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var chksums = module.exports.chksums = \\${chksums};\r\n    var bundles = module.exports.bundles = \\${bundles};                    \r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n    System.normalize = function (name, pName, pAddress) {\r\n        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n            var chksum = chksums[name];\r\n            if (chksums[name]) { bust[address] = chksum; }\r\n            return address;\r\n        });\r\n    };\r\n\r\n    System.locate = function (load) {\r\n        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n            var chksum = bust[address];\r\n            return (chksum) ? address + '?' + chksum : address;\r\n        });\r\n    };\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n` : `\r\n(function(module) {\r\n    var bundles = module.exports.bundles = \\${bundles};\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n`;\r\n            }\r\n\r\n\r\n            // let maps = {\r\n            //     css: 'github:systemjs/plugin-css@0.1.20.js',\r\n            //     json: 'github:systemjs/plugin-json@0.1.2.js'\r\n            // };\r\n\r\n           let maps = option.bundleMaps || {\r\n                css: '',\r\n                json: '',\r\n                text: ''\r\n            };\r\n\r\n            let cssSrc, jsonSrc, textSrc;\r\n            _.each(_.keys(manifest.bundles), n => {\r\n                if (!maps.css) {\r\n                    cssSrc = <string>_.find(manifest.bundles[n], (it: string) => /(css(.min){0,1}.js)|(plugin-css@\\d+.\\d+.\\d+.js)$/.test(it));\r\n                    if (cssSrc) {\r\n                        maps.css = cssSrc;\r\n                    }\r\n                }\r\n\r\n                if (!maps.json) {\r\n                    jsonSrc = _.find(manifest.bundles[n], (it: string) => /(json(.min){0,1}.js)|(plugin-json@\\d+.\\d+.\\d+.js)$/.test(it));\r\n                    if (jsonSrc) {\r\n                        maps.json = jsonSrc;\r\n                    }\r\n                }\r\n                if (!maps.text) {\r\n                    textSrc = <string>_.find(manifest.bundles[n], (it: string) => /(text(.min){0,1}.js)|(plugin-text@\\d+.\\d+.\\d+.js)$/.test(it));\r\n                    if (textSrc) {\r\n                        maps.text = textSrc;\r\n                    }\r\n                }\r\n            });\r\n            let jspmMetas = option.jspmMates;\r\n            output += _.template(template)({\r\n                maps: JSON.stringify(maps, null, '    '),\r\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\r\n                paths: JSON.stringify(null, null, '    '), // option.builder.config ? option.builder.config.paths :\r\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\r\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\r\n            });\r\n\r\n        }\r\n\r\n\r\n        let includes = option.includes || [];\r\n\r\n        includes = includes.concat(_.map(option.includePackageFiles, f => path.join(option.jspmPackages, f)));\r\n\r\n        return Promise.all(_.map(includes, f => {\r\n            return new Promise<string>((resolve, reject) => {\r\n                readFile(f, 'utf8', (err, data) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    } else {\r\n                        resolve(data);\r\n                    }\r\n                });\r\n            });\r\n        }))\r\n            .then(data => {\r\n                data.push(output);\r\n                let mainfile = ctx.toStr(option.mainfile); // path.relative(this.getBundleManifestPath(ctx), ctx.getDist(this.getInfo()));\r\n                console.log('mainfile:', mainfile);\r\n                mkdirp.sync(path.dirname(mainfile));\r\n                var stream = <NodeJS.ReadWriteStream>source(mainfile);\r\n                stream.write(data.join('\\n'));\r\n                process.nextTick(() => {\r\n                    stream.end();\r\n                });\r\n\r\n                return super.working(stream.pipe(vinylBuffer()), ctx, option, gulp, option.mainfilePipes || [], option.mainfileOutput);\r\n            });\r\n\r\n    }\r\n\r\n    private getBundleManifestPath(ctx: ITaskContext): string {\r\n        return this.getBundleDest(ctx, <string>(<IBundlesConfig>ctx.option).mainfile);\r\n    }\r\n    private getBundleManifest(ctx: ITaskContext): any {\r\n        let data: any = {};\r\n        let mainfile: string = this.getBundleManifestPath(ctx);\r\n        console.log('try to load old bundle in path ', mainfile);\r\n        if (existsSync(mainfile)) {\r\n            try {\r\n                let content = readFileSync(mainfile, 'utf8');\r\n                let idx = content.indexOf(this.manifestSplit);\r\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\r\n                content = content.substring(idx);\r\n                // console.log(content);\r\n                writeFileSync(mainfile, content);\r\n                data = require(mainfile);\r\n                console.log('has old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\r\n            } catch (e) {\r\n                console.log(chalk.red(e));\r\n            }\r\n        } else {\r\n            console.log('no old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    private getBundleShortPath(ctx: ITaskContext, bundleName: string, bundleGp?: IBundleGroup) {\r\n        var fullPath = bundleGp ? this.getBundleDest(ctx, bundleName, bundleGp)\r\n            : path.join(ctx.getDist(), bundleName);\r\n\r\n        return ctx.toUrl(<string>(<IBundlesConfig>ctx.option).bundleBaseDir, fullPath)\r\n\r\n    }\r\n\r\n    private getBundleDest(ctx: ITaskContext, bundleName: string, bundleGp?: IBundleGroup) {\r\n\r\n        let dest = ctx.getDist();\r\n        if (bundleGp) {\r\n            let min = bundleGp.builder.minify;\r\n            let name = bundleGp.items[bundleName] || bundleName;\r\n            let file = name + ((min) ? '.min.js' : '.js');\r\n\r\n            if (bundleGp.combine) {\r\n                dest = path.join(dest, file);\r\n            } else {\r\n                dest = path.join(dest, bundleName, file);\r\n            }\r\n        } else {\r\n            dest = path.join(dest, bundleName);\r\n        }\r\n\r\n        return dest;\r\n    }\r\n}\r\n"]}