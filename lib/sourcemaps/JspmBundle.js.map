{"version":3,"sources":["JspmBundle.js","JspmBundle.ts"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","_typeof","decorate","i","defineProperty","__metadata","k","v","metadata","_","require","development_core_1","path","fs_1","chalk","globby","jspm","source","vinylBuffer","chksum","mkdirp","JspmBundle","info","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","call","name","runWay","RunWay","sequence","packages","manifestSplit","_inherits","_development_core_1$P","_createClass","value","config","option","ctx","setPackagePath","dirname","packageFile","jsbuilder","Builder","separateCSS","builder","Promise","resolve","then","jspmConfig","loadConfig","undefined","trans","isArray","map","t","stream","bundle","dist","gulp","_this2","bundles","all","getbundles","loadBuilder","defaults","groupBundle","translate","groups","flatten","src","getSrc","getInfo","console","log","cyan","files","getRelativeSrc","createBundler","join","toRootPath","mainfile","_this3","toModule","baseURL","s","filename","relative","replace","toModulePath","fn","substring","extname","extend","dest","file","systemConfigTempl","relationToRoot","bust","includePackageFiles","jspmMates","*.css","loader","*.json","*.jsx","sfx","minify","mangle","sourceMaps","lowResSourceMaps","pkg","getPackage","jspmPackages","directories","readdirSync","red","process","exit","context","_this4","_get","prototype","calcChecksums","checksums","updateBundleManifest","manifest","writeBundleManifest","green","initOption","pipes","output","_this5","bundlemap","modules","push","bundleName","bundleDest","env","gb","uniq","split","keys","filter","f","bundleGp","_this6","bundleStr","bundleItems","minusStr","exclusionString","exclude","items","combine","getBundleDest","str","exclusionArray","_this7","minus","forEach","item","group","concat","builderCfg","bundler","buildStatic","shortPath","getBundleShortPath","parse","base","bind","sync","write","nextTick","end","pipe","chksums","isObject","reject","filepath","err","sum","error","getBundleManifest","each","_this8","root","template","maps","css","json","n","test","first","jspmMetas","JSON","stringify","jspmMeta","paths","includes","readFile","data","mainfilePipes","mainfileOutput","getBundleManifestPath","existsSync","content","readFileSync","idx","indexOf","writeFileSync","e","fullPath","getDist","spath","min","PipeTask","task","oper","Operation","release","deploy","exports"],"mappings":"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","file":"../JspmBundle.js","sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nconst _ = require('lodash');\nconst development_core_1 = require('development-core');\nconst path = require('path');\nconst fs_1 = require('fs');\nconst chalk = require('chalk');\nconst globby = require('globby');\nconst jspm = require('jspm');\nconst source = require('vinyl-source-stream');\nconst vinylBuffer = require('vinyl-buffer');\nconst chksum = require('checksum');\nconst mkdirp = require('mkdirp');\n// const uglify = require('gulp-uglify');\nlet JspmBundle = class JspmBundle extends development_core_1.PipeTask {\n    constructor(info) {\n        super(info);\n        this.name = 'jspm-bundle';\n        this.runWay = development_core_1.RunWay.sequence;\n        this.packages = {};\n        this.manifestSplit = `/*------bundles infos------*/`;\n    }\n    getOption(config) {\n        return config.option;\n    }\n    loadBuilder(ctx) {\n        let option = ctx.option;\n        jspm.setPackagePath(path.dirname(option.packageFile));\n        let jsbuilder = new jspm.Builder({ separateCSS: option.builder.separateCSS });\n        return Promise.resolve(jsbuilder)\n            .then(builder => {\n            if (option.jspmConfig) {\n                return builder.loadConfig(option.jspmConfig, undefined, true)\n                    .then(() => {\n                    return builder;\n                });\n            }\n            else {\n                return builder;\n            }\n        });\n    }\n    translate(trans) {\n        if (_.isArray(trans)) {\n            return _.map(trans, t => {\n                t.stream['bundle'] = t.bundle;\n                return t.stream;\n            });\n        }\n        else {\n            trans.stream['bundle'] = trans.bundle;\n            return trans.stream;\n        }\n    }\n    source(ctx, dist, gulp) {\n        let option = ctx.option;\n        if (option.bundles) {\n            return Promise.all(_.map(this.getbundles(ctx), name => {\n                return this.loadBuilder(ctx)\n                    .then(builder => {\n                    let bundle = option.bundles[name];\n                    bundle.builder = _.defaults(bundle.builder, option.builder);\n                    if (option.builder.config) {\n                        builder.config(bundle.builder.config);\n                    }\n                    return this.groupBundle(ctx, builder, name, bundle, gulp)\n                        .then(trans => this.translate(trans));\n                });\n            })).then(groups => {\n                return _.flatten(groups);\n            });\n        }\n        else {\n            return this.loadBuilder(ctx)\n                .then(builder => {\n                let src = ctx.getSrc(this.getInfo());\n                console.log('start bundle all src : ', chalk.cyan(src));\n                if (option.builder.config) {\n                    builder.config(option.builder.config);\n                }\n                return Promise.resolve(globby(src))\n                    .then(files => {\n                    files = this.getRelativeSrc(files, ctx);\n                    console.log('bundle files:', chalk.cyan(files));\n                    return this.createBundler(ctx, builder, 'bundle', files.join(' + '), ctx.toRootPath(option.mainfile), option.builder)\n                        .then(trans => this.translate(trans));\n                });\n            });\n        }\n    }\n    getRelativeSrc(src, config, toModule = false) {\n        // console.log(option.baseURL);\n        let baseURL = config.option.baseURL;\n        if (_.isArray(src)) {\n            return _.map(src, s => {\n                let filename = path.relative(baseURL, s).replace(/\\\\/g, '/').replace(/^\\//g, '');\n                return toModule ? this.toModulePath(filename) : filename;\n            });\n        }\n        else {\n            let fn = path.relative(baseURL, src).replace(/\\\\/g, '/').replace(/^\\//g, '');\n            return [(toModule ? this.toModulePath(fn) : fn)];\n        }\n    }\n    toModulePath(filename) {\n        if (!filename) {\n            return '';\n        }\n        return filename.substring(0, filename.length - path.extname(filename).length);\n    }\n    initOption(ctx) {\n        let option = _.extend({\n            baseURL: '',\n            mainfile: 'bundle.js',\n            jspmConfig: '',\n            packageFile: 'package.json',\n            dest: '',\n            file: '',\n            systemConfigTempl: '',\n            relationToRoot: '',\n            bust: '',\n            bundles: null,\n            includePackageFiles: [\n                'system-polyfills.src.js',\n                'system.src.js'\n            ],\n            jspmMates: {\n                '*.css': {\n                    loader: 'css'\n                },\n                '*.json': {\n                    loader: 'json'\n                },\n                '*.jsx': {\n                    loader: 'jsx'\n                }\n            },\n            builder: {\n                sfx: false,\n                minify: false,\n                mangle: false,\n                sourceMaps: false,\n                separateCSS: false,\n                lowResSourceMaps: true\n            }\n        }, ctx.option);\n        option.baseURL = ctx.toRootPath(option.baseURL);\n        if (option.jspmConfig) {\n            option.jspmConfig = ctx.toRootPath(option.jspmConfig);\n        }\n        option.packageFile = ctx.toRootPath(option.packageFile);\n        let pkg = this.getPackage(option);\n        if (!option.jspmPackages) {\n            if (pkg.jspm.directories && pkg.jspm.directories.packages) {\n                option.jspmPackages = pkg.jspm.directories.packages;\n            }\n            else {\n                option.jspmPackages = 'jspm_packages';\n            }\n        }\n        option.jspmPackages = ctx.toRootPath(option.jspmPackages);\n        if (!fs_1.readdirSync(option.jspmPackages)) {\n            console.log(chalk.red('jspm project config error!'));\n            process.exit(0);\n        }\n        return option;\n    }\n    execute(context, gulp) {\n        this.bundles = [];\n        let ctx = context;\n        return super.execute(ctx, gulp)\n            .then(() => {\n            let option = ctx.option;\n            if (option.bundles) {\n                return this.calcChecksums(option, this.bundles).then((checksums) => {\n                    return this.updateBundleManifest(ctx, this.bundles, checksums);\n                });\n            }\n            else {\n                return null;\n            }\n        }).then(manifest => {\n            if (manifest) {\n                return this.writeBundleManifest(ctx, manifest, gulp)\n                    .then(() => {\n                    console.log(chalk.green('------ Complete -------------'));\n                });\n            }\n            else {\n                console.log(chalk.green('------ Complete -------------'));\n                return null;\n            }\n        });\n    }\n    setup(ctx, gulp) {\n        ctx.option = this.initOption(ctx);\n        return super.setup(ctx, gulp);\n    }\n    working(source, ctx, option, gulp, pipes, output) {\n        let bundle = source['bundle'];\n        return super.working(source, ctx, option, gulp, pipes, output)\n            .then(() => {\n            let bundlemap = {\n                path: bundle.path,\n                modules: bundle.modules\n            };\n            this.bundles.push(bundlemap);\n            if (bundle.sfx) {\n                console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\n            }\n            else {\n                console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\n            }\n            return;\n        });\n    }\n    getbundles(ctx) {\n        let option = ctx.option;\n        let groups = [];\n        if (ctx.env.gb) {\n            groups = _.uniq(_.isArray(ctx.env.gb) ? ctx.env.gb : (ctx.env.gb || '').split(','));\n        }\n        if (groups.length < 1) {\n            groups = _.keys(option.bundles);\n        }\n        else {\n            groups = _.filter(groups, f => f && groups[f]);\n        }\n        console.log('cmmand group bundle:', chalk.cyan(groups));\n        return groups;\n    }\n    groupBundle(config, builder, name, bundleGp, gulp) {\n        let option = config.option;\n        let bundleStr = '';\n        let bundleDest = '';\n        let bundleItems = [];\n        let minusStr = this.exclusionString(bundleGp.exclude, option.bundles);\n        if (bundleGp.items) {\n            bundleItems = _.isArray(bundleItems) ? bundleGp.items : _.keys(bundleGp.items);\n        }\n        if (bundleGp.combine) {\n            bundleDest = this.getBundleDest(config, name, bundleGp);\n            bundleStr = bundleItems.join(' + ') + minusStr;\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup source:\\n  ${chalk.cyan(bundleStr)}\\n-------------------------------`);\n            return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleGp.builder, bundleGp);\n        }\n        else {\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(bundleItems)}\\n-------------------------------`);\n            return Promise.all(bundleItems.map(key => {\n                bundleStr = key + minusStr;\n                bundleDest = this.getBundleDest(config, key, bundleGp);\n                return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleGp.builder, bundleGp);\n            }));\n        }\n    }\n    exclusionString(exclude, groups) {\n        let str = this.exclusionArray(exclude, groups).join(' - ');\n        return (str) ? ' - ' + str : '';\n    }\n    exclusionArray(exclude, groups) {\n        let minus = [];\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\n        _.forEach(exclude, (item) => {\n            var group = groups[item];\n            if (group) {\n                // exclude everything from this group\n                minus = minus.concat(this.exclusionArray(group.items, groups));\n            }\n            else {\n                // exclude this item by name\n                minus.push(item);\n            }\n        });\n        return minus;\n    }\n    createBundler(config, builder, bundleName, bundleStr, bundleDest, builderCfg, bundleGp) {\n        let sfx = builderCfg.sfx;\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleGp);\n        let filename = path.parse(bundleDest).base;\n        return bundler.bind(builder)(bundleStr, bundleDest, builderCfg)\n            .then(output => {\n            mkdirp.sync(path.dirname(bundleDest));\n            var stream = source(filename);\n            stream.write(output.source);\n            process.nextTick(function () {\n                stream.end();\n            });\n            // transform['bundle'] = {\n            //     sfx: sfx,\n            //     path: shortPath,\n            //     bundleName: bundleName,\n            //     filename: filename,\n            //     bundleDest: bundleDest,\n            //     modules: output.modules\n            // };\n            return {\n                stream: stream.pipe(vinylBuffer()),\n                bundle: {\n                    path: shortPath,\n                    sfx: sfx,\n                    bundleName: bundleName,\n                    filename: filename,\n                    bundleDest: bundleDest,\n                    modules: output.modules\n                }\n            };\n        });\n    }\n    getPackage(option) {\n        if (!this.packages[option.packageFile]) {\n            this.packages[option.packageFile] = require(option.packageFile);\n        }\n        return this.packages[option.packageFile];\n    }\n    calcChecksums(option, bundles) {\n        let chksums = {};\n        console.log('Calculating checksums...');\n        return Promise.all(_.map(bundles, (bundle) => {\n            if (!_.isObject(bundle)) {\n                return null;\n            }\n            return new Promise((resolve, reject) => {\n                let filepath = path.join(option.baseURL || '.', bundle.path);\n                let filename = path.parse(bundle.path).base;\n                chksum.file(filepath, (err, sum) => {\n                    if (err) {\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\n                    }\n                    console.log(filename, chalk.cyan(sum));\n                    chksums[bundle.path] = sum;\n                    resolve(chksums);\n                });\n            });\n        })).then(() => {\n            return chksums;\n        });\n    }\n    updateBundleManifest(ctx, bundles, chksums) {\n        chksums = chksums || {};\n        var manifest = _.defaults(this.getBundleManifest(ctx), {\n            bundles: {},\n            chksums: {}\n        });\n        // console.log(manifest);\n        _.each(bundles, bundle => {\n            if (bundle.path) {\n                manifest.bundles[bundle.path] = bundle.modules;\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\n            }\n        });\n        return manifest;\n    }\n    writeBundleManifest(ctx, manifest, gulp) {\n        let option = ctx.option;\n        if (!option.mainfile) {\n            return Promise.reject('mainfile not configed.');\n        }\n        console.log('Writing manifest...');\n        let output = `\r\nSystem.config({\r\n    baseURL: '${path.relative(option.baseURL, ctx.env.root) || '.'}',\r\n    defaultJSExtensions: true\r\n});\r\nSystem.bundled = true;\r\nSystem.bust = '${option.bust}';\r\nif(window != undefined) window.prod = true;\r\n${this.manifestSplit}\r\n`;\n        let template = '';\n        if (manifest) {\n            // try {\n            template = option.systemConfigTempl;\n            if (!template) {\n                template = (option.bust) ? `\r\n(function(module) {\r\n    var bust = {};\r\n    var systemLocate = System.locate;\r\n    var systemNormalize = System.normalize;\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var chksums = module.exports.chksums = \\${chksums};\r\n    var bundles = module.exports.bundles = \\${bundles};                    \r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n    System.normalize = function (name, pName, pAddress) {\r\n        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n            var chksum = chksums[name];\r\n            if (chksums[name]) { bust[address] = chksum; }\r\n            return address;\r\n        });\r\n    };\r\n\r\n    System.locate = function (load) {\r\n        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n            var chksum = bust[address];\r\n            return (chksum) ? address + '?' + chksum : address;\r\n        });\r\n    };\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n` : `\r\n(function(module) {\r\n    var bundles = module.exports.bundles = \\${bundles};\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n`;\n            }\n            let maps = {\n                css: 'github:systemjs/plugin-css@0.1.20.js',\n                json: 'github:systemjs/plugin-json@0.1.2.js'\n            };\n            _.each(_.keys(manifest.bundles), n => {\n                if (/css.min.js$/.test(n)) {\n                    maps.css = _.first(manifest.bundles[n]);\n                }\n                if (/json.min.js$/.test(n)) {\n                    maps.css = _.first(manifest.bundles[n]);\n                }\n            });\n            let jspmMetas = option.jspmMates;\n            output += _.template(template)({\n                maps: JSON.stringify(maps, null, '    '),\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\n                paths: JSON.stringify(ctx.option.builder.config ? ctx.option.builder.config.paths : null, null, '    '),\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\n            });\n        }\n        let includes = option.includes || [];\n        includes = includes.concat(_.map(option.includePackageFiles, f => path.join(option.jspmPackages, f)));\n        return Promise.all(_.map(includes, f => {\n            return new Promise((resolve, reject) => {\n                fs_1.readFile(path.join(option.jspmConfig, f), 'utf8', (err, data) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(data);\n                    }\n                });\n            });\n        }))\n            .then(data => {\n            data.push(output);\n            let mainfile = option.mainfile; // path.relative(this.getBundleManifestPath(ctx), ctx.getDist(this.getInfo()));\n            // console.log('mainfile:', mainfile);\n            mkdirp.sync(path.dirname(mainfile));\n            var stream = source(mainfile);\n            stream.write(data.join('\\n'));\n            process.nextTick(() => {\n                stream.end();\n            });\n            return super.working(stream.pipe(vinylBuffer()), ctx, option, gulp, option.mainfilePipes, option.mainfileOutput);\n        });\n    }\n    getBundleManifestPath(ctx) {\n        return this.getBundleDest(ctx, ctx.option.mainfile);\n    }\n    getBundleManifest(ctx) {\n        let data = {};\n        let mainfile = this.getBundleManifestPath(ctx);\n        console.log('try to load old bundle in path ', mainfile);\n        if (fs_1.existsSync(mainfile)) {\n            try {\n                let content = fs_1.readFileSync(mainfile, 'utf8');\n                let idx = content.indexOf(this.manifestSplit);\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\n                content = content.substring(idx);\n                // console.log(content);\n                fs_1.writeFileSync(mainfile, content);\n                data = require(mainfile);\n                console.log('has old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\n            }\n            catch (e) {\n                console.log(chalk.red(e));\n            }\n        }\n        else {\n            console.log('no old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\n        }\n        return data;\n    }\n    getBundleShortPath(config, bundleName, bundleGp) {\n        var fullPath = bundleGp ? this.getBundleDest(config, bundleName, bundleGp)\n            : path.join(config.getDist(), bundleName);\n        let spath = path.relative(config.option.baseURL, fullPath);\n        spath = spath.replace(/\\\\/g, '/').replace(/^\\//g, '');\n        return spath;\n    }\n    getBundleDest(config, bundleName, bundleGp) {\n        let dest = config.getDist();\n        if (bundleGp) {\n            let min = bundleGp.builder.minify;\n            let name = bundleGp.items[bundleName] || bundleName;\n            let file = name + ((min) ? '.min.js' : '.js');\n            if (bundleGp.combine) {\n                dest = path.join(dest, file);\n            }\n            else {\n                dest = path.join(dest, bundleName, file);\n            }\n        }\n        else {\n            dest = path.join(dest, bundleName);\n        }\n        return dest;\n    }\n};\nJspmBundle = __decorate([\n    development_core_1.task({\n        oper: development_core_1.Operation.release | development_core_1.Operation.deploy\n    }), \n    __metadata('design:paramtypes', [Object])\n], JspmBundle);\nexports.JspmBundle = JspmBundle;\n","import * as _ from 'lodash';\r\nimport { task, RunWay, IAssertDist, ITaskContext, Src, Pipe, OutputPipe, ITaskInfo, TransformSource, ITransform, Operation, PipeTask, bindingConfig } from 'development-core';\r\nimport { Gulp } from 'gulp';\r\nimport * as path from 'path';\r\nimport { IJspmTaskContext, IBundlesConfig, IBundleGroup, IBuidlerConfig, IBundleMap, IBundleTransform } from './config';\r\n\r\nimport { readFileSync, readFile, existsSync, writeFileSync, readdirSync } from 'fs';\r\nimport * as chalk from 'chalk';\r\nconst globby = require('globby');\r\nconst jspm = require('jspm');\r\nconst source = require('vinyl-source-stream');\r\nconst vinylBuffer = require('vinyl-buffer');\r\nconst chksum = require('checksum');\r\nconst mkdirp = require('mkdirp');\r\n// const uglify = require('gulp-uglify');\r\n\r\n\r\n@task({\r\n    oper: Operation.release | Operation.deploy\r\n})\r\nexport class JspmBundle extends PipeTask {\r\n\r\n    name = 'jspm-bundle';\r\n    runWay = RunWay.sequence;\r\n    private bundles: IBundleMap[];\r\n    constructor(info?: ITaskInfo) {\r\n        super(info);\r\n    }\r\n\r\n    protected getOption(config: ITaskContext): IAssertDist {\r\n        return config.option;\r\n    }\r\n\r\n    protected loadBuilder(ctx: ITaskContext): Promise<any> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        jspm.setPackagePath(path.dirname(option.packageFile));\r\n        let jsbuilder = new jspm.Builder({ separateCSS: option.builder.separateCSS });\r\n\r\n        return Promise.resolve(jsbuilder)\r\n            .then(builder => {\r\n                if (option.jspmConfig) {\r\n                    return builder.loadConfig(option.jspmConfig, undefined, true)\r\n                        .then(() => {\r\n                            return builder;\r\n                        });\r\n                } else {\r\n                    return builder;\r\n                }\r\n            });\r\n    }\r\n\r\n    private translate(trans: IBundleTransform | IBundleTransform[]): ITransform | ITransform[] {\r\n        if (_.isArray(trans)) {\r\n            return _.map(trans, t => {\r\n                t.stream['bundle'] = t.bundle;\r\n                return t.stream;\r\n            });\r\n        } else {\r\n            trans.stream['bundle'] = trans.bundle;\r\n            return trans.stream;\r\n        }\r\n    }\r\n\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (option.bundles) {\r\n            return Promise.all(_.map(this.getbundles(ctx), name => {\r\n                return this.loadBuilder(ctx)\r\n                    .then(builder => {\r\n                        let bundle: IBundleGroup = option.bundles[name];\r\n                        bundle.builder = <IBuidlerConfig>_.defaults(bundle.builder, option.builder);\r\n                        if (option.builder.config) {\r\n                            builder.config(bundle.builder.config);\r\n                        }\r\n                        return this.groupBundle(<IJspmTaskContext>ctx, builder, name, bundle, gulp)\r\n                            .then(trans => this.translate(trans));\r\n                    });\r\n            })).then(groups => {\r\n                return _.flatten(groups);\r\n            });\r\n        } else {\r\n            return this.loadBuilder(ctx)\r\n                .then(builder => {\r\n                    let src = ctx.getSrc(this.getInfo());\r\n                    console.log('start bundle all src : ', chalk.cyan(<any>src));\r\n                    if (option.builder.config) {\r\n                        builder.config(option.builder.config)\r\n                    }\r\n\r\n                    return Promise.resolve<string[]>(globby(src))\r\n                        .then(files => {\r\n                            files = this.getRelativeSrc(files, <IJspmTaskContext>ctx);\r\n                            console.log('bundle files:', chalk.cyan(<any>files));\r\n                            return this.createBundler(<IJspmTaskContext>ctx, builder, 'bundle', files.join(' + '), ctx.toRootPath(option.mainfile), option.builder)\r\n                                .then(trans => this.translate(trans));\r\n                        });\r\n                });\r\n        }\r\n    }\r\n\r\n    private getRelativeSrc(src: Src, config: IJspmTaskContext, toModule = false): string[] {\r\n        // console.log(option.baseURL);\r\n        let baseURL = config.option.baseURL\r\n        if (_.isArray(src)) {\r\n            return _.map(src, s => {\r\n                let filename = path.relative(baseURL, s).replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n                return toModule ? this.toModulePath(filename) : filename;\r\n            });\r\n        } else {\r\n            let fn = path.relative(baseURL, src).replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n            return [(toModule ? this.toModulePath(fn) : fn)];\r\n        }\r\n    }\r\n\r\n    private toModulePath(filename: string): string {\r\n        if (!filename) {\r\n            return '';\r\n        }\r\n        return filename.substring(0, filename.length - path.extname(filename).length);\r\n    }\r\n\r\n    private initOption(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>_.extend(<IBundlesConfig>{\r\n            baseURL: '',\r\n            mainfile: 'bundle.js',\r\n            jspmConfig: '',\r\n            packageFile: 'package.json',\r\n            dest: '',\r\n            file: '',\r\n            systemConfigTempl: '',\r\n            relationToRoot: '',\r\n            bust: '',\r\n            bundles: null,\r\n            includePackageFiles: [\r\n                'system-polyfills.src.js',\r\n                'system.src.js'\r\n            ],\r\n            jspmMates: {\r\n                '*.css': {\r\n                    loader: 'css'\r\n                },\r\n                '*.json': {\r\n                    loader: 'json'\r\n                },\r\n                '*.jsx': {\r\n                    loader: 'jsx'\r\n                }\r\n            },\r\n            builder: {\r\n                sfx: false,\r\n                minify: false,\r\n                mangle: false,\r\n                sourceMaps: false,\r\n                separateCSS: false,\r\n                lowResSourceMaps: true\r\n            }\r\n        }, <IBundlesConfig>ctx.option);\r\n\r\n        option.baseURL = ctx.toRootPath(option.baseURL);\r\n        if (option.jspmConfig) {\r\n            option.jspmConfig = ctx.toRootPath(option.jspmConfig);\r\n        }\r\n        option.packageFile = ctx.toRootPath(option.packageFile);\r\n\r\n        let pkg = this.getPackage(option);\r\n        if (!option.jspmPackages) {\r\n            if (pkg.jspm.directories && pkg.jspm.directories.packages) {\r\n                option.jspmPackages = <string>pkg.jspm.directories.packages;\r\n            } else {\r\n                option.jspmPackages = 'jspm_packages';\r\n            }\r\n        }\r\n        option.jspmPackages = ctx.toRootPath(option.jspmPackages);\r\n\r\n        if (!readdirSync(option.jspmPackages)) {\r\n            console.log(chalk.red('jspm project config error!'));\r\n            process.exit(0);\r\n        }\r\n\r\n        return option;\r\n    }\r\n\r\n\r\n    execute(context: ITaskContext, gulp: Gulp) {\r\n        this.bundles = [];\r\n        let ctx = <IJspmTaskContext>context;\r\n        return super.execute(ctx, gulp)\r\n            .then(() => {\r\n                let option = <IBundlesConfig>ctx.option;\r\n                if (option.bundles) {\r\n                    return this.calcChecksums(option, this.bundles).then((checksums) => {\r\n                        return this.updateBundleManifest(ctx, this.bundles, checksums);\r\n                    });\r\n                } else {\r\n                    return null;\r\n                }\r\n            }).then(manifest => {\r\n                if (manifest) {\r\n                    return this.writeBundleManifest(ctx, manifest, gulp)\r\n                        .then(() => {\r\n                            console.log(chalk.green('------ Complete -------------'));\r\n                        });\r\n                } else {\r\n                    console.log(chalk.green('------ Complete -------------'));\r\n                    return null;\r\n                }\r\n            });\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp: Gulp) {\r\n        ctx.option = this.initOption(ctx);\r\n        return super.setup(ctx, gulp);\r\n    }\r\n\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        let bundle = <IBundleMap>source['bundle'];\r\n        return super.working(source, ctx, option, gulp, pipes, output)\r\n            .then(() => {\r\n                let bundlemap: IBundleMap = {\r\n                    path: bundle.path,\r\n                    modules: bundle.modules\r\n                };\r\n                this.bundles.push(bundlemap);\r\n                if (bundle.sfx) {\r\n                    console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                } else {\r\n                    console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                }\r\n                return;\r\n            });\r\n    }\r\n\r\n    getbundles(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        let groups = [];\r\n        if (ctx.env.gb) {\r\n            groups = _.uniq(_.isArray(ctx.env.gb) ? ctx.env.gb : (ctx.env.gb || '').split(','));\r\n        }\r\n\r\n        if (groups.length < 1) {\r\n            groups = _.keys(option.bundles);\r\n        } else {\r\n            groups = _.filter(groups, f => f && groups[f]);\r\n        }\r\n        console.log('cmmand group bundle:', chalk.cyan(<any>groups));\r\n        return groups;\r\n    }\r\n\r\n    protected groupBundle(config: IJspmTaskContext, builder, name: string, bundleGp: IBundleGroup, gulp: Gulp): Promise<IBundleTransform | IBundleTransform[]> {\r\n\r\n        let option: IBundlesConfig = config.option;\r\n\r\n        let bundleStr = '';\r\n        let bundleDest = '';\r\n\r\n        let bundleItems: string[] = [];\r\n        let minusStr = this.exclusionString(bundleGp.exclude, option.bundles);\r\n\r\n        if (bundleGp.items) {\r\n            bundleItems = _.isArray(bundleItems) ? <string[]>bundleGp.items : _.keys(bundleGp.items);\r\n        }\r\n\r\n        if (bundleGp.combine) {\r\n            bundleDest = this.getBundleDest(config, name, bundleGp);\r\n            bundleStr = bundleItems.join(' + ') + minusStr;\r\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup source:\\n  ${chalk.cyan(bundleStr)}\\n-------------------------------`);\r\n            return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n\r\n        } else {\r\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(<any>bundleItems)}\\n-------------------------------`);\r\n            return Promise.all(bundleItems.map(key => {\r\n                bundleStr = key + minusStr;\r\n                bundleDest = this.getBundleDest(config, key, bundleGp);\r\n                return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n            }));\r\n        }\r\n    }\r\n\r\n    private exclusionString(exclude, groups): string {\r\n        let str = this.exclusionArray(exclude, groups).join(' - ');\r\n        return (str) ? ' - ' + str : '';\r\n    }\r\n\r\n    private exclusionArray(exclude, groups): string[] {\r\n        let minus: string[] = [];\r\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\r\n        _.forEach(exclude, (item: string) => {\r\n            var group = groups[item];\r\n            if (group) {\r\n                // exclude everything from this group\r\n                minus = minus.concat(this.exclusionArray(group.items, groups));\r\n            } else {\r\n                // exclude this item by name\r\n                minus.push(item);\r\n            }\r\n        });\r\n        return minus;\r\n    }\r\n\r\n    private createBundler(config: IJspmTaskContext, builder: any, bundleName: string, bundleStr: string, bundleDest: string, builderCfg: IBuidlerConfig, bundleGp?: IBundleGroup): Promise<IBundleTransform> {\r\n\r\n        let sfx = builderCfg.sfx;\r\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\r\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleGp);\r\n        let filename = path.parse(bundleDest).base;\r\n\r\n        return bundler.bind(builder)(bundleStr, bundleDest, builderCfg)\r\n            .then(output => {\r\n                mkdirp.sync(path.dirname(bundleDest));\r\n                var stream: ITransform = source(filename);\r\n                stream.write(output.source);\r\n                process.nextTick(function() {\r\n                    stream.end();\r\n                });\r\n\r\n\r\n                // transform['bundle'] = {\r\n                //     sfx: sfx,\r\n                //     path: shortPath,\r\n                //     bundleName: bundleName,\r\n                //     filename: filename,\r\n                //     bundleDest: bundleDest,\r\n                //     modules: output.modules\r\n                // };\r\n                return {\r\n                    stream: stream.pipe(vinylBuffer()),\r\n                    bundle: {\r\n                        path: shortPath,\r\n                        sfx: sfx,\r\n                        bundleName: bundleName,\r\n                        filename: filename,\r\n                        bundleDest: bundleDest,\r\n                        modules: output.modules\r\n                    }\r\n                };\r\n            });\r\n\r\n    }\r\n\r\n    private packages = {};\r\n    public getPackage(option: IBundlesConfig): any {\r\n        if (!this.packages[option.packageFile]) {\r\n            this.packages[option.packageFile] = require(option.packageFile);\r\n        }\r\n        return this.packages[option.packageFile]\r\n    }\r\n\r\n    private calcChecksums(option: IBundlesConfig, bundles: any[]): Promise<any> {\r\n        let chksums = {};\r\n\r\n        console.log('Calculating checksums...');\r\n\r\n        return Promise.all(_.map(bundles, (bundle: any) => {\r\n            if (!_.isObject(bundle)) {\r\n                return null;\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                let filepath = path.join(option.baseURL || '.', bundle.path);\r\n                let filename = path.parse(bundle.path).base;\r\n                chksum.file(filepath, (err, sum) => {\r\n                    if (err) {\r\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\r\n                    }\r\n                    console.log(filename, chalk.cyan(sum));\r\n                    chksums[bundle.path] = sum;\r\n                    resolve(chksums);\r\n                });\r\n            });\r\n\r\n        })).then(() => {\r\n            return chksums;\r\n        });\r\n    }\r\n\r\n    protected updateBundleManifest(ctx: IJspmTaskContext, bundles: any[], chksums?: any) {\r\n\r\n        chksums = chksums || {};\r\n\r\n        var manifest: any = _.defaults(this.getBundleManifest(ctx), {\r\n            bundles: {},\r\n            chksums: {}\r\n        });\r\n\r\n        // console.log(manifest);\r\n\r\n        _.each(bundles, bundle => {\r\n            if (bundle.path) {\r\n                manifest.bundles[bundle.path] = bundle.modules;\r\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\r\n            }\r\n        });\r\n\r\n        return manifest;\r\n\r\n    }\r\n\r\n    private manifestSplit = `/*------bundles infos------*/`;\r\n    private writeBundleManifest(ctx: IJspmTaskContext, manifest, gulp: Gulp): Promise<any> {\r\n        let option = ctx.option;\r\n        if (!option.mainfile) {\r\n            return Promise.reject('mainfile not configed.');\r\n        }\r\n\r\n\r\n        console.log('Writing manifest...');\r\n\r\n\r\n        let output = `\r\nSystem.config({\r\n    baseURL: '${ path.relative(option.baseURL, ctx.env.root) || '.'}',\r\n    defaultJSExtensions: true\r\n});\r\nSystem.bundled = true;\r\nSystem.bust = '${option.bust}';\r\nif(window != undefined) window.prod = true;\r\n${this.manifestSplit}\r\n`;\r\n        let template = '';\r\n\r\n        if (manifest) {\r\n            // try {\r\n            template = option.systemConfigTempl;\r\n\r\n            if (!template) {\r\n                template = (option.bust) ? `\r\n(function(module) {\r\n    var bust = {};\r\n    var systemLocate = System.locate;\r\n    var systemNormalize = System.normalize;\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var chksums = module.exports.chksums = \\${chksums};\r\n    var bundles = module.exports.bundles = \\${bundles};                    \r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n    System.normalize = function (name, pName, pAddress) {\r\n        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n            var chksum = chksums[name];\r\n            if (chksums[name]) { bust[address] = chksum; }\r\n            return address;\r\n        });\r\n    };\r\n\r\n    System.locate = function (load) {\r\n        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n            var chksum = bust[address];\r\n            return (chksum) ? address + '?' + chksum : address;\r\n        });\r\n    };\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n` : `\r\n(function(module) {\r\n    var bundles = module.exports.bundles = \\${bundles};\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n`;\r\n            }\r\n\r\n\r\n            let maps = {\r\n                css: 'github:systemjs/plugin-css@0.1.20.js',\r\n                json: 'github:systemjs/plugin-json@0.1.2.js'\r\n            };\r\n\r\n            _.each(_.keys(manifest.bundles), n => {\r\n                if (/css.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n                if (/json.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n            });\r\n\r\n            let jspmMetas = option.jspmMates;\r\n            output += _.template(template)({\r\n                maps: JSON.stringify(maps, null, '    '),\r\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\r\n                paths: JSON.stringify(ctx.option.builder.config ? ctx.option.builder.config.paths : null, null, '    '),\r\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\r\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\r\n            });\r\n\r\n        }\r\n\r\n\r\n        let includes = option.includes || [];\r\n\r\n        includes = includes.concat(_.map(option.includePackageFiles, f => path.join(option.jspmPackages, f)));\r\n\r\n        return Promise.all(_.map(includes, f => {\r\n            return new Promise<string>((resolve, reject) => {\r\n                readFile(path.join(option.jspmConfig, f), 'utf8', (err, data) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    } else {\r\n                        resolve(data);\r\n                    }\r\n                });\r\n            });\r\n        }))\r\n            .then(data => {\r\n                data.push(output);\r\n                let mainfile = option.mainfile; // path.relative(this.getBundleManifestPath(ctx), ctx.getDist(this.getInfo()));\r\n                // console.log('mainfile:', mainfile);\r\n                mkdirp.sync(path.dirname(mainfile));\r\n                var stream = <NodeJS.ReadWriteStream>source(mainfile);\r\n                stream.write(data.join('\\n'));\r\n                process.nextTick(() => {\r\n                    stream.end();\r\n                });\r\n\r\n                return super.working(stream.pipe(vinylBuffer()), ctx, option, gulp, option.mainfilePipes, option.mainfileOutput);\r\n            });\r\n\r\n    }\r\n\r\n    private getBundleManifestPath(ctx: IJspmTaskContext): string {\r\n        return this.getBundleDest(ctx, ctx.option.mainfile);\r\n    }\r\n    private getBundleManifest(ctx: IJspmTaskContext): any {\r\n        let data: any = {};\r\n        let mainfile: string = this.getBundleManifestPath(ctx);\r\n        console.log('try to load old bundle in path ', mainfile);\r\n        if (existsSync(mainfile)) {\r\n            try {\r\n                let content = readFileSync(mainfile, 'utf8');\r\n                let idx = content.indexOf(this.manifestSplit);\r\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\r\n                content = content.substring(idx);\r\n                // console.log(content);\r\n                writeFileSync(mainfile, content);\r\n                data = require(mainfile);\r\n                console.log('has old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\r\n            } catch (e) {\r\n                console.log(chalk.red(e));\r\n            }\r\n        } else {\r\n            console.log('no old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    private getBundleShortPath(config: IJspmTaskContext, bundleName: string, bundleGp?: IBundleGroup) {\r\n        var fullPath = bundleGp ? this.getBundleDest(config, bundleName, bundleGp)\r\n            : path.join(config.getDist(), bundleName);\r\n\r\n        let spath: string = path.relative(config.option.baseURL, fullPath);\r\n        spath = spath.replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n        return spath;\r\n    }\r\n\r\n    private getBundleDest(config: IJspmTaskContext, bundleName: string, bundleGp?: IBundleGroup) {\r\n\r\n        let dest = config.getDist();\r\n        if (bundleGp) {\r\n            let min = bundleGp.builder.minify;\r\n            let name = bundleGp.items[bundleName] || bundleName;\r\n            let file = name + ((min) ? '.min.js' : '.js');\r\n\r\n            if (bundleGp.combine) {\r\n                dest = path.join(dest, file);\r\n            } else {\r\n                dest = path.join(dest, bundleName, file);\r\n            }\r\n        } else {\r\n            dest = path.join(dest, bundleName);\r\n        }\r\n\r\n        return dest;\r\n    }\r\n}\r\n"]}