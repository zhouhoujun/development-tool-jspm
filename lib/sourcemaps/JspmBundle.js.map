{"version":3,"sources":["JspmBundle.js","JspmBundle.ts"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","_typeof","decorate","i","defineProperty","__metadata","k","v","metadata","_","require","development_core_1","path","fs_1","chalk","replace","jspm","source","vinylBuffer","chksum","mkdirp","JspmBundle","info","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","call","name","runWay","RunWay","sequence","manifestSplit","_inherits","_development_core_1$P","_createClass","value","ctx","dist","gulp","_this2","option","bundles","initBundles","then","Promise","all","map","getBundles","loadBuilder","builder","bundle","bundleConfig","bcfg","getBuildConfig","defaults","config","groupBundle","trans","translate","groups","flatten","src","getSrc","getInfo","console","log","cyan","fileFilter","files","getRelativeSrc","mainfile","getBundleManifestPath","createBundler","join","context","_this3","bundleMaps","_get","prototype","calcChecksums","checksums","updateBundleManifest","manifest","writeBundleManifest","green","initOption","pipes","ps","getAssertResetPipe","concat","output","_this4","bundlemap","modules","push","sfx","bundleName","filename","bundleDest","setPackagePath","dirname","toStr","packageFile","jsbuilder","Builder","separateCSS","resolve","jspmConfig","isArray","cf","loadConfig","undefined","t","stream","_this5","opt","pr","to","bundleDeps","pkg","getPackage","red","process","exit","deps","dependencies","keys","depsExclude","exclude","isFunction","filter","indexOf","isBoolean","deplibs","combine","items","cores","each","n","b","_this6","toModule","baseURL","bundleBaseDir","s","toUrl","toModulePath","fn","substring","extname","extend","dest","file","systemConfigTempl","relationToRoot","bust","bundlePaths","paths","getDist","rootpath","getFolders","f","p","env","root","includePackageFiles","jspmMates","*.css","loader","*.json","*.jsx","minify","mangle","sourceMaps","lowResSourceMaps","toRootPath","parent","toRootSrc","toSrc","jspmPackages","directories","packages","readdirSync","rootURL","_this7","restps","isUndefined","resetAsserts","folders","isString","pth","toDistPath","existsSync","yellow","toDistSrc","getRootPath","relp","fm","basename","reg","RegExp","reg2","reg3","_this8","gb","uniq","split","bundleGp","_this9","bundleStr","bundleItems","minusStr","exclusionString","getBundleDest","str","exclusionArray","_this10","minus","forEach","item","group","builderCfg","bundler","buildStatic","shortPath","getBundleShortPath","parse","base","bind","sync","write","nextTick","end","pipe","chksums","isObject","reject","filepath","err","sum","error","getBundleManifest","_this11","template","maps","css","json","test","first","jspmMetas","JSON","stringify","jspmMeta","includes","readFile","data","mainfilePipes","mainfileOutput","content","readFileSync","idx","writeFileSync","e","fullPath","min","PipeTask","task","oper","Operation","release","deploy","exports"],"mappings":"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","file":"../JspmBundle.js","sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nconst _ = require('lodash');\nconst development_core_1 = require('development-core');\nconst path = require('path');\nconst fs_1 = require('fs');\nconst chalk = require('chalk');\nconst replace = require('gulp-replace');\n// const globby = require('globby');\nconst jspm = require('jspm');\nconst source = require('vinyl-source-stream');\nconst vinylBuffer = require('vinyl-buffer');\nconst chksum = require('checksum');\nconst mkdirp = require('mkdirp');\n// const uglify = require('gulp-uglify');\nlet JspmBundle = class JspmBundle extends development_core_1.PipeTask {\n    constructor(info) {\n        super(info);\n        this.name = 'jspm-bundle';\n        this.runWay = development_core_1.RunWay.sequence;\n        this.manifestSplit = `/*------bundles infos------*/`;\n    }\n    source(ctx, dist, gulp) {\n        let option = ctx.option;\n        if (option.bundles) {\n            return this.initBundles(ctx)\n                .then(() => {\n                return Promise.all(_.map(this.getBundles(ctx), name => {\n                    return this.loadBuilder(ctx)\n                        .then(builder => {\n                        let bundle = this.bundleConfig[name];\n                        let bcfg = this.getBuildConfig(ctx);\n                        bundle.builder = _.defaults(bundle.builder, bcfg);\n                        if (bundle.builder.config) {\n                            builder.config(bundle.builder.config);\n                        }\n                        return this.groupBundle(ctx, builder, name, bundle, gulp)\n                            .then(trans => this.translate(trans));\n                    });\n                }));\n            }).then(groups => {\n                return _.flatten(groups);\n            });\n        }\n        else {\n            return this.loadBuilder(ctx)\n                .then(builder => {\n                let src = ctx.getSrc(this.getInfo());\n                console.log('start bundle all src : ', chalk.cyan(src));\n                let bcfg = this.getBuildConfig(ctx);\n                if (bcfg.config) {\n                    builder.config(bcfg.config);\n                }\n                return ctx.fileFilter(src)\n                    .then(files => {\n                    files = this.getRelativeSrc(ctx, files);\n                    console.log('bundle files:', chalk.cyan(files));\n                    let mainfile = this.getBundleManifestPath(ctx);\n                    return this.createBundler(ctx, builder, 'bundle', files.join(' + '), mainfile, bcfg)\n                        .then(trans => this.translate(trans));\n                });\n            });\n        }\n    }\n    execute(context, gulp) {\n        this.bundleMaps = [];\n        let ctx = context;\n        return super.execute(ctx, gulp)\n            .then(() => {\n            let option = ctx.option;\n            if (option.bundles) {\n                return this.calcChecksums(option, this.bundleMaps).then((checksums) => {\n                    return this.updateBundleManifest(ctx, this.bundleMaps, checksums);\n                });\n            }\n            else {\n                return null;\n            }\n        }).then(manifest => {\n            if (manifest) {\n                return this.writeBundleManifest(ctx, manifest, gulp)\n                    .then(() => {\n                    console.log(chalk.green('------ Complete -------------'));\n                });\n            }\n            else {\n                console.log(chalk.green('------ Complete -------------'));\n                return null;\n            }\n        });\n    }\n    setup(ctx, gulp) {\n        ctx.option = this.initOption(ctx);\n        return super.setup(ctx, gulp);\n    }\n    pipes(ctx, dist, gulp) {\n        let pipes = super.pipes(ctx, dist, gulp) || [];\n        let ps = this.getAssertResetPipe(ctx);\n        if (ps && ps.length > 0) {\n            pipes = pipes.concat(ps);\n        }\n        return pipes;\n    }\n    working(source, ctx, option, gulp, pipes, output) {\n        let bundle = source['bundle'];\n        return super.working(source, ctx, option, gulp, pipes, output)\n            .then(() => {\n            let bundlemap = {\n                path: bundle.path,\n                modules: bundle.modules\n            };\n            this.bundleMaps.push(bundlemap);\n            if (bundle.sfx) {\n                console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\n            }\n            else {\n                console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\n            }\n            return;\n        });\n    }\n    getOption(config) {\n        return config.option;\n    }\n    loadBuilder(ctx) {\n        let option = ctx.option;\n        jspm.setPackagePath(path.dirname(ctx.toStr(option.packageFile)));\n        let jsbuilder = new jspm.Builder({ separateCSS: option.builder.separateCSS });\n        return Promise.resolve(jsbuilder)\n            .then(builder => {\n            if (option.jspmConfig) {\n                if (_.isArray(option.jspmConfig)) {\n                    return Promise.all(option.jspmConfig.map(cf => builder.loadConfig(cf, undefined, true)))\n                        .then(() => {\n                        return builder;\n                    });\n                }\n                else {\n                    return builder.loadConfig(option.jspmConfig, undefined, true)\n                        .then(() => {\n                        return builder;\n                    });\n                }\n            }\n            else {\n                return builder;\n            }\n        });\n    }\n    translate(trans) {\n        if (_.isArray(trans)) {\n            return _.map(trans, t => {\n                t.stream['bundle'] = t.bundle;\n                return t.stream;\n            });\n        }\n        else {\n            trans.stream['bundle'] = trans.bundle;\n            return trans.stream;\n        }\n    }\n    initBundles(ctx) {\n        let opt = ctx.option;\n        let pr = Promise.resolve(null)\n            .then(() => ctx.to(opt.bundles));\n        if (opt.bundleDeps) {\n            pr = pr.then(bundles => {\n                let pkg = ctx.getPackage(opt.packageFile);\n                if (!pkg) {\n                    console.log(chalk.red('can not found package.json file.'));\n                    process.exit(0);\n                }\n                let deps = opt.dependencies ? ctx.to(opt.dependencies) : _.keys(pkg.jspm.dependencies);\n                if (!deps || deps.length < 0) {\n                    console.log(chalk.red('not set bundle dependencies libs, or not setting jspm config.'));\n                    process.exit(0);\n                }\n                if (opt.depsExclude) {\n                    let exclude = _.isFunction(opt.depsExclude) ? opt.depsExclude(ctx, deps) : opt.depsExclude;\n                    deps = _.filter(deps, d => exclude.indexOf(d) < 0);\n                }\n                return Promise.resolve()\n                    .then(() => {\n                    if (_.isFunction(opt.bundleDeps)) {\n                        // opt['_bundleDepsFunc'] = opt.bundleDeps;\n                        return opt.bundleDeps(ctx, deps);\n                    }\n                    else if (_.isBoolean(opt.bundleDeps)) {\n                        return {\n                            deplibs: {\n                                combine: true,\n                                items: deps\n                            }\n                        };\n                    }\n                    else {\n                        return opt.bundleDeps;\n                    }\n                })\n                    .then(bundleDeps => {\n                    let cores = _.keys(bundleDeps);\n                    _.each(_.keys(bundles), n => {\n                        let b = bundles[n];\n                        b.exclude = b.exclude || [];\n                        b.exclude = cores.concat(b.exclude);\n                        bundleDeps[n] = b;\n                    });\n                    return bundleDeps;\n                });\n            });\n        }\n        return pr.then(bundles => {\n            this.bundleConfig = bundles;\n            console.log('group bundles setting:\\n', bundles, '---------------------------------\\n');\n            return bundles;\n        });\n    }\n    getRelativeSrc(ctx, src, toModule = false) {\n        let baseURL = ctx.option.bundleBaseDir;\n        if (_.isArray(src)) {\n            return _.map(src, s => {\n                let filename = ctx.toUrl(baseURL, s);\n                return toModule ? this.toModulePath(filename) : filename;\n            });\n        }\n        else {\n            let fn = ctx.toUrl(baseURL, src);\n            return [(toModule ? this.toModulePath(fn) : fn)];\n        }\n    }\n    toModulePath(filename) {\n        if (!filename) {\n            return '';\n        }\n        return filename.substring(0, filename.length - path.extname(filename).length);\n    }\n    initOption(ctx) {\n        let option = _.extend({\n            baseURL: '',\n            bundleBaseDir: '.',\n            mainfile: 'bundle.js',\n            jspmConfig: '',\n            packageFile: 'package.json',\n            dest: '',\n            file: '',\n            systemConfigTempl: '',\n            relationToRoot: '',\n            bust: '',\n            bundles: null,\n            bundlePaths(ctx) {\n                let paths = {};\n                let bundleDest = ctx.getDist();\n                let rootpath = option.bundleBaseDir;\n                ctx.getFolders(rootpath, (f, d) => {\n                    if (f !== bundleDest) {\n                        let p = d + '/*';\n                        paths[p] = ctx.toUrl(ctx.env.root, path.join(rootpath, p));\n                    }\n                    return '';\n                });\n                // let jpk = <string>option.jspmPackages;\n                // let jp = path.basename(jpk) + '/*';\n                // paths[jp] = self.toUrl(rootpath, path.join(jpk, jp));\n                console.log('paths: ', paths);\n                return paths;\n            },\n            includePackageFiles: [\n                'system-polyfills.src.js',\n                'system.src.js'\n            ],\n            jspmMates: {\n                '*.css': {\n                    loader: 'css'\n                },\n                '*.json': {\n                    loader: 'json'\n                },\n                '*.jsx': {\n                    loader: 'jsx'\n                }\n            },\n            builder: {\n                sfx: false,\n                minify: false,\n                mangle: false,\n                sourceMaps: false,\n                separateCSS: false,\n                lowResSourceMaps: true\n            }\n        }, ctx.option);\n        ctx.option = option;\n        option.baseURL = ctx.toRootPath(ctx.toStr(option.baseURL));\n        if (!option.bundleBaseDir && ctx.parent) {\n            option.bundleBaseDir = ctx.parent.getDist();\n        }\n        else if (option.bundleBaseDir) {\n            option.bundleBaseDir = ctx.toRootPath(ctx.toStr(option.bundleBaseDir));\n        }\n        else {\n            console.log(chalk.red('bundleBaseURL config error!'));\n            process.exit(0);\n        }\n        if (option.jspmConfig) {\n            option.jspmConfig = ctx.toRootSrc(ctx.toSrc(option.jspmConfig));\n        }\n        option.packageFile = ctx.toRootPath(ctx.toStr(option.packageFile));\n        option.mainfile = ctx.toStr(option.mainfile);\n        let pkg = ctx.getPackage(option.packageFile);\n        if (!option.jspmPackages) {\n            if (pkg.jspm.directories && pkg.jspm.directories.packages) {\n                option.jspmPackages = pkg.jspm.directories.packages;\n            }\n            else {\n                option.jspmPackages = 'jspm_packages';\n            }\n        }\n        option.jspmPackages = ctx.toRootPath(ctx.toStr(option.jspmPackages));\n        if (!fs_1.readdirSync(option.jspmPackages)) {\n            console.log(chalk.red('jspm project config error!'));\n            process.exit(0);\n        }\n        return option;\n    }\n    getBuildConfig(ctx) {\n        let option = ctx.option;\n        if (!option.builder.config) {\n            option.builder.config = _.extend(option.builder.config || {}, {\n                paths: ctx.to(option.bundlePaths) || {},\n                rootURL: option.bundleBaseDir\n            });\n        }\n        return option.builder;\n    }\n    getAssertResetPipe(ctx) {\n        if (!this.restps) {\n            let option = ctx.option;\n            if (_.isUndefined(option.resetAsserts)) {\n                option.resetAsserts = 'assets';\n            }\n            if (option.resetAsserts) {\n                let folders;\n                if (_.isString(option.resetAsserts)) {\n                    let pth = ctx.toDistPath(option.resetAsserts, this.getInfo());\n                    if (fs_1.existsSync(pth)) {\n                        folders = ctx.getFolders(pth);\n                        folders.push(pth);\n                    }\n                    else {\n                        console.log(chalk.yellow('rest css asserts folders:', pth, 'not exists.'));\n                    }\n                }\n                else {\n                    folders = ctx.toDistSrc(option.resetAsserts, this.getInfo());\n                }\n                folders = folders || [];\n                let ps = [];\n                let dist = ctx.getDist(this.getInfo());\n                let baseURL = option.baseURL; // ctx.toUrl(ctx.getRootPath(), <string>option.baseURL) || '.';\n                let root = ctx.getRootPath();\n                _.each(folders, f => {\n                    let relp = ctx.toUrl(root, path.join(baseURL, ctx.toUrl(dist, f)));\n                    let fm = path.basename(f);\n                    console.log('reset css url folder name:', chalk.cyan(fm), 'relate url:', chalk.cyan(relp));\n                    let reg = new RegExp(`(url\\\\((..\\\\/)+${fm})|(url\\\\(\\\\/${fm})`, 'gi');\n                    ps.push(() => replace(reg, `url(${relp}`));\n                    let reg2 = new RegExp(`(url\\\\(\\\\'(..\\\\/)+${fm})|(url\\\\(\\\\'\\\\/${fm})`, 'gi');\n                    ps.push(() => replace(reg2, `url(\\\\'${relp}`));\n                    let reg3 = new RegExp(`(url\\\\((\"..\\\\/)+${fm})|(url\\\\(\"\\\\/${fm})`, 'gi');\n                    ps.push(() => replace(reg3, `url(\"${relp}`));\n                });\n                this.restps = ps;\n            }\n            else {\n                this.restps = [];\n            }\n        }\n        return this.restps;\n    }\n    getBundles(ctx) {\n        let groups = [];\n        if (ctx.env.gb) {\n            groups = _.uniq(_.isArray(ctx.env.gb) ? ctx.env.gb : (ctx.env.gb || '').split(','));\n        }\n        if (groups.length < 1) {\n            groups = _.keys(this.bundleConfig);\n        }\n        else {\n            groups = _.filter(groups, f => f && this.bundleConfig[f]);\n        }\n        console.log('cmmand group bundle:', chalk.cyan(groups));\n        return groups;\n    }\n    groupBundle(config, builder, name, bundleGp, gulp) {\n        let bundleStr = '';\n        let bundleDest = '';\n        let bundleItems = [];\n        let minusStr = this.exclusionString(bundleGp.exclude, this.bundleConfig);\n        if (bundleGp.items) {\n            bundleItems = _.isArray(bundleItems) ? bundleGp.items : _.keys(bundleGp.items);\n        }\n        if (bundleGp.combine) {\n            bundleDest = this.getBundleDest(config, name, bundleGp);\n            bundleStr = bundleItems.join(' + ') + minusStr;\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup source:\\n  ${chalk.cyan(bundleStr)}\\n-------------------------------`);\n            return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleGp.builder, bundleGp);\n        }\n        else {\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(bundleItems)}\\n-------------------------------`);\n            return Promise.all(bundleItems.map(key => {\n                bundleStr = key + minusStr;\n                bundleDest = this.getBundleDest(config, key, bundleGp);\n                return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleGp.builder, bundleGp);\n            }));\n        }\n    }\n    exclusionString(exclude, groups) {\n        let str = this.exclusionArray(exclude, groups).join(' - ');\n        return (str) ? ' - ' + str : '';\n    }\n    exclusionArray(exclude, groups) {\n        let minus = [];\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\n        _.forEach(exclude, (item) => {\n            var group = groups[item];\n            if (group) {\n                // exclude everything from this group\n                minus = minus.concat(this.exclusionArray(group.items, groups));\n            }\n            else {\n                // exclude this item by name\n                minus.push(item);\n            }\n        });\n        return minus;\n    }\n    createBundler(config, builder, bundleName, bundleStr, bundleDest, builderCfg, bundleGp) {\n        let sfx = builderCfg.sfx;\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleGp);\n        let filename = path.parse(bundleDest).base;\n        return bundler.bind(builder)(bundleStr, bundleDest, builderCfg)\n            .then(output => {\n            mkdirp.sync(path.dirname(bundleDest));\n            var stream = source(filename);\n            stream.write(output.source);\n            process.nextTick(function () {\n                stream.end();\n            });\n            console.log('pipe bundling：', chalk.cyan(bundleName));\n            return {\n                stream: stream.pipe(vinylBuffer()),\n                bundle: {\n                    path: shortPath,\n                    sfx: sfx,\n                    bundleName: bundleName,\n                    filename: filename,\n                    bundleDest: bundleDest,\n                    modules: output.modules\n                }\n            };\n        });\n    }\n    calcChecksums(option, bundles) {\n        let chksums = {};\n        console.log('Calculating checksums...');\n        return Promise.all(_.map(bundles, (bundle) => {\n            if (!_.isObject(bundle)) {\n                return null;\n            }\n            return new Promise((resolve, reject) => {\n                let filepath = path.join(option.bundleBaseDir || '.', bundle.path);\n                let filename = path.parse(bundle.path).base;\n                chksum.file(filepath, (err, sum) => {\n                    if (err) {\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\n                    }\n                    console.log(filename, chalk.cyan(sum));\n                    chksums[bundle.path] = sum;\n                    resolve(chksums);\n                });\n            });\n        })).then(() => {\n            return chksums;\n        });\n    }\n    updateBundleManifest(ctx, bundles, chksums) {\n        chksums = chksums || {};\n        var manifest = _.defaults(this.getBundleManifest(ctx), {\n            bundles: {},\n            chksums: {}\n        });\n        // console.log(manifest);\n        _.each(bundles, bundle => {\n            if (bundle.path) {\n                manifest.bundles[bundle.path] = bundle.modules;\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\n            }\n        });\n        return manifest;\n    }\n    writeBundleManifest(ctx, manifest, gulp) {\n        let option = ctx.option;\n        if (!option.mainfile) {\n            return Promise.reject('mainfile not configed.');\n        }\n        console.log('Writing manifest...');\n        let baseURL = ctx.toUrl(ctx.getRootPath(), option.baseURL) || '.';\n        console.log('system config baseURL: ', chalk.cyan(baseURL));\n        let bust = ctx.toStr(option.bust);\n        console.log('system bust: ', chalk.cyan(bust));\n        let output = `\r\nSystem.config({\r\n    baseURL: '${baseURL}',\r\n    defaultJSExtensions: true\r\n});\r\nSystem.bundled = true;\r\nSystem.bust = '${bust}';\r\nif(window != undefined) window.prod = true;\r\n${this.manifestSplit}\r\n`;\n        let template = '';\n        if (manifest) {\n            // try {\n            template = ctx.toStr(option.systemConfigTempl);\n            if (!template) {\n                template = (bust) ? `\r\n(function(module) {\r\n    var bust = {};\r\n    var systemLocate = System.locate;\r\n    var systemNormalize = System.normalize;\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var chksums = module.exports.chksums = \\${chksums};\r\n    var bundles = module.exports.bundles = \\${bundles};                    \r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n    System.normalize = function (name, pName, pAddress) {\r\n        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n            var chksum = chksums[name];\r\n            if (chksums[name]) { bust[address] = chksum; }\r\n            return address;\r\n        });\r\n    };\r\n\r\n    System.locate = function (load) {\r\n        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n            var chksum = bust[address];\r\n            return (chksum) ? address + '?' + chksum : address;\r\n        });\r\n    };\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n` : `\r\n(function(module) {\r\n    var bundles = module.exports.bundles = \\${bundles};\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n`;\n            }\n            let maps = {\n                css: 'github:systemjs/plugin-css@0.1.20.js',\n                json: 'github:systemjs/plugin-json@0.1.2.js'\n            };\n            _.each(_.keys(manifest.bundles), n => {\n                if (/css.min.js$/.test(n)) {\n                    maps.css = _.first(manifest.bundles[n]);\n                }\n                if (/json.min.js$/.test(n)) {\n                    maps.css = _.first(manifest.bundles[n]);\n                }\n            });\n            let jspmMetas = option.jspmMates;\n            output += _.template(template)({\n                maps: JSON.stringify(maps, null, '    '),\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\n                paths: JSON.stringify(null, null, '    '),\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\n            });\n        }\n        let includes = option.includes || [];\n        includes = includes.concat(_.map(option.includePackageFiles, f => path.join(option.jspmPackages, f)));\n        return Promise.all(_.map(includes, f => {\n            return new Promise((resolve, reject) => {\n                fs_1.readFile(f, 'utf8', (err, data) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(data);\n                    }\n                });\n            });\n        }))\n            .then(data => {\n            data.push(output);\n            let mainfile = ctx.toStr(option.mainfile); // path.relative(this.getBundleManifestPath(ctx), ctx.getDist(this.getInfo()));\n            console.log('mainfile:', mainfile);\n            mkdirp.sync(path.dirname(mainfile));\n            var stream = source(mainfile);\n            stream.write(data.join('\\n'));\n            process.nextTick(() => {\n                stream.end();\n            });\n            return super.working(stream.pipe(vinylBuffer()), ctx, option, gulp, option.mainfilePipes || [], option.mainfileOutput);\n        });\n    }\n    getBundleManifestPath(ctx) {\n        return this.getBundleDest(ctx, ctx.option.mainfile);\n    }\n    getBundleManifest(ctx) {\n        let data = {};\n        let mainfile = this.getBundleManifestPath(ctx);\n        console.log('try to load old bundle in path ', mainfile);\n        if (fs_1.existsSync(mainfile)) {\n            try {\n                let content = fs_1.readFileSync(mainfile, 'utf8');\n                let idx = content.indexOf(this.manifestSplit);\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\n                content = content.substring(idx);\n                // console.log(content);\n                fs_1.writeFileSync(mainfile, content);\n                data = require(mainfile);\n                console.log('has old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\n            }\n            catch (e) {\n                console.log(chalk.red(e));\n            }\n        }\n        else {\n            console.log('no old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\n        }\n        return data;\n    }\n    getBundleShortPath(ctx, bundleName, bundleGp) {\n        var fullPath = bundleGp ? this.getBundleDest(ctx, bundleName, bundleGp)\n            : path.join(ctx.getDist(), bundleName);\n        return ctx.toUrl(ctx.option.bundleBaseDir, fullPath);\n    }\n    getBundleDest(ctx, bundleName, bundleGp) {\n        let dest = ctx.getDist();\n        if (bundleGp) {\n            let min = bundleGp.builder.minify;\n            let name = bundleGp.items[bundleName] || bundleName;\n            let file = name + ((min) ? '.min.js' : '.js');\n            if (bundleGp.combine) {\n                dest = path.join(dest, file);\n            }\n            else {\n                dest = path.join(dest, bundleName, file);\n            }\n        }\n        else {\n            dest = path.join(dest, bundleName);\n        }\n        return dest;\n    }\n};\nJspmBundle = __decorate([\n    development_core_1.task({\n        oper: development_core_1.Operation.release | development_core_1.Operation.deploy\n    }), \n    __metadata('design:paramtypes', [Object])\n], JspmBundle);\nexports.JspmBundle = JspmBundle;\n","import * as _ from 'lodash';\r\nimport { IMap, task, RunWay, IAssertDist, ITaskContext, Src, Pipe, OutputPipe, ITaskInfo, TransformSource, ITransform, Operation, PipeTask, bindingConfig } from 'development-core';\r\nimport { Gulp } from 'gulp';\r\nimport * as path from 'path';\r\nimport { IBundlesConfig, IBundleGroup, IBuidlerConfig, IBundleMap, IBundleTransform } from './config';\r\n\r\nimport { readFileSync, readFile, existsSync, writeFileSync, readdirSync } from 'fs';\r\nimport * as chalk from 'chalk';\r\n\r\nconst replace = require('gulp-replace');\r\n// const globby = require('globby');\r\nconst jspm = require('jspm');\r\nconst source = require('vinyl-source-stream');\r\nconst vinylBuffer = require('vinyl-buffer');\r\nconst chksum = require('checksum');\r\nconst mkdirp = require('mkdirp');\r\n// const uglify = require('gulp-uglify');\r\n\r\n\r\n@task({\r\n    oper: Operation.release | Operation.deploy\r\n})\r\nexport class JspmBundle extends PipeTask {\r\n\r\n    name = 'jspm-bundle';\r\n    runWay = RunWay.sequence;\r\n    private bundleMaps: IBundleMap[];\r\n    constructor(info?: ITaskInfo) {\r\n        super(info);\r\n    }\r\n\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (option.bundles) {\r\n            return this.initBundles(<ITaskContext>ctx)\r\n                .then(() => {\r\n                    return Promise.all(_.map(this.getBundles(ctx), name => {\r\n                        return this.loadBuilder(ctx)\r\n                            .then(builder => {\r\n                                let bundle: IBundleGroup = this.bundleConfig[name];\r\n                                let bcfg = this.getBuildConfig(ctx);\r\n                                bundle.builder = <IBuidlerConfig>_.defaults(bundle.builder, bcfg);\r\n                                if (bundle.builder.config) {\r\n                                    builder.config(bundle.builder.config);\r\n                                }\r\n                                return this.groupBundle(<ITaskContext>ctx, builder, name, bundle, gulp)\r\n                                    .then(trans => this.translate(trans));\r\n                            });\r\n                    }))\r\n                }).then(groups => {\r\n                    return _.flatten(groups);\r\n                });\r\n        } else {\r\n            return this.loadBuilder(ctx)\r\n                .then(builder => {\r\n                    let src = ctx.getSrc(this.getInfo());\r\n                    console.log('start bundle all src : ', chalk.cyan(<any>src));\r\n                    let bcfg = this.getBuildConfig(ctx);\r\n                    if (bcfg.config) {\r\n                        builder.config(bcfg.config)\r\n                    }\r\n\r\n                    return ctx.fileFilter(src)\r\n                        .then(files => {\r\n                            files = this.getRelativeSrc(ctx, files);\r\n                            console.log('bundle files:', chalk.cyan(<any>files));\r\n                            let mainfile = this.getBundleManifestPath(<ITaskContext>ctx);\r\n                            return this.createBundler(<ITaskContext>ctx, builder, 'bundle', files.join(' + '), mainfile, bcfg)\r\n                                .then(trans => this.translate(trans));\r\n                        });\r\n                });\r\n        }\r\n    }\r\n\r\n    execute(context: ITaskContext, gulp: Gulp) {\r\n        this.bundleMaps = [];\r\n        let ctx = <ITaskContext>context;\r\n        return super.execute(ctx, gulp)\r\n            .then(() => {\r\n                let option = <IBundlesConfig>ctx.option;\r\n                if (option.bundles) {\r\n                    return this.calcChecksums(option, this.bundleMaps).then((checksums) => {\r\n                        return this.updateBundleManifest(ctx, this.bundleMaps, checksums);\r\n                    });\r\n                } else {\r\n                    return null;\r\n                }\r\n            }).then(manifest => {\r\n                if (manifest) {\r\n                    return this.writeBundleManifest(ctx, manifest, gulp)\r\n                        .then(() => {\r\n                            console.log(chalk.green('------ Complete -------------'));\r\n                        });\r\n                } else {\r\n                    console.log(chalk.green('------ Complete -------------'));\r\n                    return null;\r\n                }\r\n            });\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp: Gulp) {\r\n        ctx.option = this.initOption(ctx);\r\n        return super.setup(ctx, gulp);\r\n    }\r\n\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        let pipes = super.pipes(ctx, dist, gulp) || [];\r\n        let ps = this.getAssertResetPipe(ctx);\r\n        if (ps && ps.length > 0) {\r\n            pipes = pipes.concat(ps);\r\n        }\r\n        return pipes;\r\n    }\r\n\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        let bundle = <IBundleMap>source['bundle'];\r\n        return super.working(source, ctx, option, gulp, pipes, output)\r\n            .then(() => {\r\n                let bundlemap: IBundleMap = {\r\n                    path: bundle.path,\r\n                    modules: bundle.modules\r\n                };\r\n                this.bundleMaps.push(bundlemap);\r\n                if (bundle.sfx) {\r\n                    console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                } else {\r\n                    console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                }\r\n                return;\r\n            });\r\n    }\r\n\r\n\r\n    protected getOption(config: ITaskContext): IAssertDist {\r\n        return config.option;\r\n    }\r\n\r\n    protected loadBuilder(ctx: ITaskContext): Promise<any> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        jspm.setPackagePath(path.dirname(ctx.toStr(option.packageFile)));\r\n        let jsbuilder = new jspm.Builder({ separateCSS: option.builder.separateCSS });\r\n\r\n        return Promise.resolve(jsbuilder)\r\n            .then(builder => {\r\n                if (option.jspmConfig) {\r\n                    if (_.isArray(option.jspmConfig)) {\r\n                        return Promise.all(option.jspmConfig.map(cf => builder.loadConfig(cf, undefined, true)))\r\n                            .then(() => {\r\n                                return builder;\r\n                            });\r\n                    } else {\r\n                        return builder.loadConfig(option.jspmConfig, undefined, true)\r\n                            .then(() => {\r\n                                return builder;\r\n                            });\r\n                    }\r\n                } else {\r\n                    return builder;\r\n                }\r\n            });\r\n    }\r\n\r\n    private translate(trans: IBundleTransform | IBundleTransform[]): ITransform | ITransform[] {\r\n        if (_.isArray(trans)) {\r\n            return _.map(trans, t => {\r\n                t.stream['bundle'] = t.bundle;\r\n                return t.stream;\r\n            });\r\n        } else {\r\n            trans.stream['bundle'] = trans.bundle;\r\n            return trans.stream;\r\n        }\r\n    }\r\n\r\n    private bundleConfig: IMap<IBundleGroup>;\r\n    protected initBundles(ctx: ITaskContext): Promise<IMap<IBundleGroup>> {\r\n        let opt = <IBundlesConfig>ctx.option;\r\n        let pr = Promise.resolve<IMap<IBundleGroup>>(null)\r\n            .then(() => ctx.to<IMap<IBundleGroup> | Promise<IMap<IBundleGroup>>>(opt.bundles));\r\n\r\n        if (opt.bundleDeps) {\r\n            pr = pr.then(bundles => {\r\n                let pkg = ctx.getPackage(<string>opt.packageFile);\r\n                if (!pkg) {\r\n                    console.log(chalk.red('can not found package.json file.'));\r\n                    process.exit(0);\r\n                }\r\n\r\n                let deps = opt.dependencies ? ctx.to<string[]>(opt.dependencies) : _.keys(pkg.jspm.dependencies);\r\n                if (!deps || deps.length < 0) {\r\n                    console.log(chalk.red('not set bundle dependencies libs, or not setting jspm config.'));\r\n                    process.exit(0);\r\n                }\r\n                if (opt.depsExclude) {\r\n                    let exclude = _.isFunction(opt.depsExclude) ? opt.depsExclude(ctx, deps) : opt.depsExclude;\r\n                    deps = _.filter(deps, d => exclude.indexOf(d) < 0);\r\n                }\r\n\r\n                return Promise.resolve()\r\n                    .then(() => {\r\n                        if (_.isFunction(opt.bundleDeps)) {\r\n                            // opt['_bundleDepsFunc'] = opt.bundleDeps;\r\n                            return opt.bundleDeps(ctx, deps);\r\n                        } else if (_.isBoolean(opt.bundleDeps)) {\r\n                            return {\r\n                                deplibs: {\r\n                                    combine: true,\r\n                                    items: deps\r\n                                }\r\n                            };\r\n                        } else {\r\n                            return opt.bundleDeps;\r\n                        }\r\n                    })\r\n                    .then(bundleDeps => {\r\n\r\n                        let cores = _.keys(bundleDeps);\r\n                        _.each(_.keys(bundles), n => {\r\n                            let b: IBundleGroup = bundles[n];\r\n                            b.exclude = b.exclude || [];\r\n                            b.exclude = cores.concat(b.exclude);\r\n                            bundleDeps[n] = b;\r\n                        });\r\n\r\n                        return bundleDeps;\r\n                    });\r\n            });\r\n        }\r\n\r\n        return pr.then(bundles => {\r\n            this.bundleConfig = bundles;\r\n            console.log('group bundles setting:\\n', bundles, '---------------------------------\\n');\r\n            return bundles;\r\n        });\r\n\r\n    }\r\n\r\n    private getRelativeSrc(ctx: ITaskContext, src: Src, toModule = false): string[] {\r\n        let baseURL = <string>(<IBundlesConfig>ctx.option).bundleBaseDir;\r\n        if (_.isArray(src)) {\r\n            return _.map(src, s => {\r\n                let filename = ctx.toUrl(baseURL, s);\r\n                return toModule ? this.toModulePath(filename) : filename;\r\n            });\r\n        } else {\r\n            let fn = ctx.toUrl(baseURL, src);\r\n            return [(toModule ? this.toModulePath(fn) : fn)];\r\n        }\r\n    }\r\n\r\n    private toModulePath(filename: string): string {\r\n        if (!filename) {\r\n            return '';\r\n        }\r\n        return filename.substring(0, filename.length - path.extname(filename).length);\r\n    }\r\n\r\n    private initOption(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>_.extend(<IBundlesConfig>{\r\n            baseURL: '',\r\n            bundleBaseDir: '.',\r\n            mainfile: 'bundle.js',\r\n            jspmConfig: '',\r\n            packageFile: 'package.json',\r\n            dest: '',\r\n            file: '',\r\n            systemConfigTempl: '',\r\n            relationToRoot: '',\r\n            bust: '',\r\n            bundles: null,\r\n            bundlePaths(ctx) {\r\n                let paths: any = {};\r\n                let bundleDest = ctx.getDist();\r\n                let rootpath = <string>option.bundleBaseDir;\r\n                ctx.getFolders(rootpath, (f, d) => {\r\n                    if (f !== bundleDest) {\r\n                        let p = d + '/*';\r\n                        paths[p] = ctx.toUrl(ctx.env.root, path.join(rootpath, p));\r\n                    }\r\n                    return '';\r\n                });\r\n                // let jpk = <string>option.jspmPackages;\r\n                // let jp = path.basename(jpk) + '/*';\r\n                // paths[jp] = self.toUrl(rootpath, path.join(jpk, jp));\r\n                console.log('paths: ', paths);\r\n                return paths;\r\n            },\r\n            includePackageFiles: [\r\n                'system-polyfills.src.js',\r\n                'system.src.js'\r\n            ],\r\n            jspmMates: {\r\n                '*.css': {\r\n                    loader: 'css'\r\n                },\r\n                '*.json': {\r\n                    loader: 'json'\r\n                },\r\n                '*.jsx': {\r\n                    loader: 'jsx'\r\n                }\r\n            },\r\n            builder: {\r\n                sfx: false,\r\n                minify: false,\r\n                mangle: false,\r\n                sourceMaps: false,\r\n                separateCSS: false,\r\n                lowResSourceMaps: true\r\n            }\r\n        }, <IBundlesConfig>ctx.option);\r\n\r\n        ctx.option = option;\r\n\r\n        option.baseURL = ctx.toRootPath(ctx.toStr(option.baseURL));\r\n        if (!option.bundleBaseDir && ctx.parent) {\r\n            option.bundleBaseDir = ctx.parent.getDist()\r\n        } else if (option.bundleBaseDir) {\r\n            option.bundleBaseDir = ctx.toRootPath(ctx.toStr(option.bundleBaseDir));\r\n        } else {\r\n            console.log(chalk.red('bundleBaseURL config error!'));\r\n            process.exit(0);\r\n        }\r\n\r\n        if (option.jspmConfig) {\r\n            option.jspmConfig = ctx.toRootSrc(ctx.toSrc(option.jspmConfig));\r\n        }\r\n        option.packageFile = ctx.toRootPath(ctx.toStr(option.packageFile));\r\n        option.mainfile = ctx.toStr(option.mainfile);\r\n        let pkg = ctx.getPackage(<string>option.packageFile);\r\n        if (!option.jspmPackages) {\r\n            if (pkg.jspm.directories && pkg.jspm.directories.packages) {\r\n                option.jspmPackages = <string>pkg.jspm.directories.packages;\r\n            } else {\r\n                option.jspmPackages = 'jspm_packages';\r\n            }\r\n        }\r\n        option.jspmPackages = ctx.toRootPath(ctx.toStr(option.jspmPackages));\r\n\r\n        if (!readdirSync(option.jspmPackages)) {\r\n            console.log(chalk.red('jspm project config error!'));\r\n            process.exit(0);\r\n        }\r\n\r\n        return option;\r\n    }\r\n\r\n    protected getBuildConfig(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (!option.builder.config) {\r\n            option.builder.config = _.extend(option.builder.config || {}, {\r\n                paths: ctx.to<IMap<string>>(option.bundlePaths) || {},\r\n                rootURL: <string>option.bundleBaseDir\r\n            });\r\n        }\r\n\r\n        return option.builder;\r\n    }\r\n\r\n    private restps: Pipe[];\r\n    protected getAssertResetPipe(ctx: ITaskContext) {\r\n        if (!this.restps) {\r\n            let option = <IBundlesConfig>ctx.option;\r\n            if (_.isUndefined(option.resetAsserts)) {\r\n                option.resetAsserts = 'assets';\r\n            }\r\n            if (option.resetAsserts) {\r\n                let folders: string[];\r\n                if (_.isString(option.resetAsserts)) {\r\n                    let pth = ctx.toDistPath(option.resetAsserts, this.getInfo());\r\n                    if (existsSync(pth)) {\r\n                        folders = ctx.getFolders(pth);\r\n                        folders.push(pth);\r\n                    } else {\r\n                        console.log(chalk.yellow('rest css asserts folders:', pth, 'not exists.'))\r\n                    }\r\n                } else {\r\n                    folders = <string[]>ctx.toDistSrc(option.resetAsserts, this.getInfo());\r\n                }\r\n\r\n                folders = folders || [];\r\n\r\n                let ps = [];\r\n                let dist = ctx.getDist(this.getInfo());\r\n                let baseURL = <string>option.baseURL; // ctx.toUrl(ctx.getRootPath(), <string>option.baseURL) || '.';\r\n                let root = ctx.getRootPath();\r\n                _.each(folders, f => {\r\n                    let relp = ctx.toUrl(root, path.join(baseURL, ctx.toUrl(dist, f)));\r\n                    let fm = path.basename(f);\r\n                    console.log('reset css url folder name:', chalk.cyan(fm), 'relate url:', chalk.cyan(relp));\r\n                    let reg = new RegExp(`(url\\\\((..\\\\/)+${fm})|(url\\\\(\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg, `url(${relp}`));\r\n                    let reg2 = new RegExp(`(url\\\\(\\\\'(..\\\\/)+${fm})|(url\\\\(\\\\'\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg2, `url(\\\\'${relp}`));\r\n                    let reg3 = new RegExp(`(url\\\\((\"..\\\\/)+${fm})|(url\\\\(\"\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg3, `url(\"${relp}`));\r\n                });\r\n                this.restps = ps;\r\n            } else {\r\n                this.restps = [];\r\n            }\r\n        }\r\n        return this.restps;\r\n    }\r\n\r\n\r\n    protected getBundles(ctx: ITaskContext) {\r\n\r\n        let groups = [];\r\n        if (ctx.env.gb) {\r\n            groups = _.uniq(_.isArray(ctx.env.gb) ? ctx.env.gb : (ctx.env.gb || '').split(','));\r\n        }\r\n\r\n        if (groups.length < 1) {\r\n            groups = _.keys(this.bundleConfig);\r\n        } else {\r\n            groups = _.filter(groups, f => f && this.bundleConfig[f]);\r\n        }\r\n        console.log('cmmand group bundle:', chalk.cyan(<any>groups));\r\n        return groups;\r\n    }\r\n\r\n    protected groupBundle(config: ITaskContext, builder, name: string, bundleGp: IBundleGroup, gulp: Gulp): Promise<IBundleTransform | IBundleTransform[]> {\r\n\r\n        let bundleStr = '';\r\n        let bundleDest = '';\r\n\r\n        let bundleItems: string[] = [];\r\n        let minusStr = this.exclusionString(bundleGp.exclude, this.bundleConfig);\r\n\r\n        if (bundleGp.items) {\r\n            bundleItems = _.isArray(bundleItems) ? <string[]>bundleGp.items : _.keys(bundleGp.items);\r\n        }\r\n\r\n        if (bundleGp.combine) {\r\n            bundleDest = this.getBundleDest(config, name, bundleGp);\r\n            bundleStr = bundleItems.join(' + ') + minusStr;\r\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup source:\\n  ${chalk.cyan(bundleStr)}\\n-------------------------------`);\r\n            return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n\r\n        } else {\r\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(<any>bundleItems)}\\n-------------------------------`);\r\n            return Promise.all(bundleItems.map(key => {\r\n                bundleStr = key + minusStr;\r\n                bundleDest = this.getBundleDest(config, key, bundleGp);\r\n                return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n            }));\r\n        }\r\n    }\r\n\r\n    private exclusionString(exclude, groups): string {\r\n        let str = this.exclusionArray(exclude, groups).join(' - ');\r\n        return (str) ? ' - ' + str : '';\r\n    }\r\n\r\n    private exclusionArray(exclude, groups): string[] {\r\n        let minus: string[] = [];\r\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\r\n        _.forEach(exclude, (item: string) => {\r\n            var group = groups[item];\r\n            if (group) {\r\n                // exclude everything from this group\r\n                minus = minus.concat(this.exclusionArray(group.items, groups));\r\n            } else {\r\n                // exclude this item by name\r\n                minus.push(item);\r\n            }\r\n        });\r\n        return minus;\r\n    }\r\n\r\n    private createBundler(config: ITaskContext, builder: any, bundleName: string, bundleStr: string, bundleDest: string, builderCfg: IBuidlerConfig, bundleGp?: IBundleGroup): Promise<IBundleTransform> {\r\n\r\n        let sfx = builderCfg.sfx;\r\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\r\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleGp);\r\n        let filename = path.parse(bundleDest).base;\r\n\r\n        return bundler.bind(builder)(bundleStr, bundleDest, builderCfg)\r\n            .then(output => {\r\n                mkdirp.sync(path.dirname(bundleDest));\r\n                var stream: ITransform = source(filename);\r\n                stream.write(output.source);\r\n                process.nextTick(function () {\r\n                    stream.end();\r\n                });\r\n\r\n                console.log('pipe bundling：', chalk.cyan(bundleName));\r\n                return {\r\n                    stream: stream.pipe(vinylBuffer()),\r\n                    bundle: {\r\n                        path: shortPath,\r\n                        sfx: sfx,\r\n                        bundleName: bundleName,\r\n                        filename: filename,\r\n                        bundleDest: bundleDest,\r\n                        modules: output.modules\r\n                    }\r\n                };\r\n            });\r\n\r\n    }\r\n\r\n    private calcChecksums(option: IBundlesConfig, bundles: any[]): Promise<any> {\r\n        let chksums = {};\r\n\r\n        console.log('Calculating checksums...');\r\n\r\n        return Promise.all(_.map(bundles, (bundle: any) => {\r\n            if (!_.isObject(bundle)) {\r\n                return null;\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                let filepath = path.join(<string>option.bundleBaseDir || '.', bundle.path);\r\n                let filename = path.parse(bundle.path).base;\r\n                chksum.file(filepath, (err, sum) => {\r\n                    if (err) {\r\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\r\n                    }\r\n                    console.log(filename, chalk.cyan(sum));\r\n                    chksums[bundle.path] = sum;\r\n                    resolve(chksums);\r\n                });\r\n            });\r\n\r\n        })).then(() => {\r\n            return chksums;\r\n        });\r\n    }\r\n\r\n    protected updateBundleManifest(ctx: ITaskContext, bundles: any[], chksums?: any) {\r\n\r\n        chksums = chksums || {};\r\n\r\n        var manifest: any = _.defaults(this.getBundleManifest(ctx), {\r\n            bundles: {},\r\n            chksums: {}\r\n        });\r\n\r\n        // console.log(manifest);\r\n\r\n        _.each(bundles, bundle => {\r\n            if (bundle.path) {\r\n                manifest.bundles[bundle.path] = bundle.modules;\r\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\r\n            }\r\n        });\r\n\r\n        return manifest;\r\n\r\n    }\r\n\r\n    private manifestSplit = `/*------bundles infos------*/`;\r\n    private writeBundleManifest(ctx: ITaskContext, manifest, gulp: Gulp): Promise<any> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (!option.mainfile) {\r\n            return Promise.reject('mainfile not configed.');\r\n        }\r\n\r\n\r\n        console.log('Writing manifest...');\r\n\r\n        let baseURL = ctx.toUrl(ctx.getRootPath(), <string>option.baseURL) || '.';\r\n        console.log('system config baseURL: ', chalk.cyan(baseURL));\r\n\r\n        let bust = ctx.toStr(option.bust);\r\n        console.log('system bust: ', chalk.cyan(bust));\r\n\r\n        let output = `\r\nSystem.config({\r\n    baseURL: '${baseURL}',\r\n    defaultJSExtensions: true\r\n});\r\nSystem.bundled = true;\r\nSystem.bust = '${bust}';\r\nif(window != undefined) window.prod = true;\r\n${this.manifestSplit}\r\n`;\r\n        let template = '';\r\n\r\n        if (manifest) {\r\n            // try {\r\n            template = ctx.toStr(option.systemConfigTempl);\r\n\r\n            if (!template) {\r\n                template = (bust) ? `\r\n(function(module) {\r\n    var bust = {};\r\n    var systemLocate = System.locate;\r\n    var systemNormalize = System.normalize;\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var chksums = module.exports.chksums = \\${chksums};\r\n    var bundles = module.exports.bundles = \\${bundles};                    \r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n    System.normalize = function (name, pName, pAddress) {\r\n        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n            var chksum = chksums[name];\r\n            if (chksums[name]) { bust[address] = chksum; }\r\n            return address;\r\n        });\r\n    };\r\n\r\n    System.locate = function (load) {\r\n        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n            var chksum = bust[address];\r\n            return (chksum) ? address + '?' + chksum : address;\r\n        });\r\n    };\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n` : `\r\n(function(module) {\r\n    var bundles = module.exports.bundles = \\${bundles};\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n`;\r\n            }\r\n\r\n\r\n            let maps = {\r\n                css: 'github:systemjs/plugin-css@0.1.20.js',\r\n                json: 'github:systemjs/plugin-json@0.1.2.js'\r\n            };\r\n\r\n            _.each(_.keys(manifest.bundles), n => {\r\n                if (/css.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n                if (/json.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n            });\r\n\r\n            let jspmMetas = option.jspmMates;\r\n            output += _.template(template)({\r\n                maps: JSON.stringify(maps, null, '    '),\r\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\r\n                paths: JSON.stringify(null, null, '    '), // option.builder.config ? option.builder.config.paths :\r\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\r\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\r\n            });\r\n\r\n        }\r\n\r\n\r\n        let includes = option.includes || [];\r\n\r\n        includes = includes.concat(_.map(option.includePackageFiles, f => path.join(option.jspmPackages, f)));\r\n\r\n        return Promise.all(_.map(includes, f => {\r\n            return new Promise<string>((resolve, reject) => {\r\n                readFile(f, 'utf8', (err, data) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    } else {\r\n                        resolve(data);\r\n                    }\r\n                });\r\n            });\r\n        }))\r\n            .then(data => {\r\n                data.push(output);\r\n                let mainfile = ctx.toStr(option.mainfile); // path.relative(this.getBundleManifestPath(ctx), ctx.getDist(this.getInfo()));\r\n                console.log('mainfile:', mainfile);\r\n                mkdirp.sync(path.dirname(mainfile));\r\n                var stream = <NodeJS.ReadWriteStream>source(mainfile);\r\n                stream.write(data.join('\\n'));\r\n                process.nextTick(() => {\r\n                    stream.end();\r\n                });\r\n\r\n                return super.working(stream.pipe(vinylBuffer()), ctx, option, gulp, option.mainfilePipes || [], option.mainfileOutput);\r\n            });\r\n\r\n    }\r\n\r\n    private getBundleManifestPath(ctx: ITaskContext): string {\r\n        return this.getBundleDest(ctx, <string>(<IBundlesConfig>ctx.option).mainfile);\r\n    }\r\n    private getBundleManifest(ctx: ITaskContext): any {\r\n        let data: any = {};\r\n        let mainfile: string = this.getBundleManifestPath(ctx);\r\n        console.log('try to load old bundle in path ', mainfile);\r\n        if (existsSync(mainfile)) {\r\n            try {\r\n                let content = readFileSync(mainfile, 'utf8');\r\n                let idx = content.indexOf(this.manifestSplit);\r\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\r\n                content = content.substring(idx);\r\n                // console.log(content);\r\n                writeFileSync(mainfile, content);\r\n                data = require(mainfile);\r\n                console.log('has old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\r\n            } catch (e) {\r\n                console.log(chalk.red(e));\r\n            }\r\n        } else {\r\n            console.log('no old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    private getBundleShortPath(ctx: ITaskContext, bundleName: string, bundleGp?: IBundleGroup) {\r\n        var fullPath = bundleGp ? this.getBundleDest(ctx, bundleName, bundleGp)\r\n            : path.join(ctx.getDist(), bundleName);\r\n\r\n        return ctx.toUrl(<string>(<IBundlesConfig>ctx.option).bundleBaseDir, fullPath)\r\n\r\n    }\r\n\r\n    private getBundleDest(ctx: ITaskContext, bundleName: string, bundleGp?: IBundleGroup) {\r\n\r\n        let dest = ctx.getDist();\r\n        if (bundleGp) {\r\n            let min = bundleGp.builder.minify;\r\n            let name = bundleGp.items[bundleName] || bundleName;\r\n            let file = name + ((min) ? '.min.js' : '.js');\r\n\r\n            if (bundleGp.combine) {\r\n                dest = path.join(dest, file);\r\n            } else {\r\n                dest = path.join(dest, bundleName, file);\r\n            }\r\n        } else {\r\n            dest = path.join(dest, bundleName);\r\n        }\r\n\r\n        return dest;\r\n    }\r\n}\r\n"]}