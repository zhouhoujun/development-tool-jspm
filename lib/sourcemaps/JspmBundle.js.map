{"version":3,"sources":["JspmBundle.ts"],"names":["_","require","development_core_1","path","fs_1","chalk","replace","jspm","source","vinylBuffer","chksum","mkdirp","JspmBundle","_super","info","_this","call","this","name","runWay","RunWay","sequence","manifestSplit","__extends","prototype","ctx","dist","gulp","option","bundles","initBundles","then","Promise","all","map","getBundles","loadBuilder","builder","bundle","bundleConfig","bcfg","getBuildConfig","defaults","config","groupBundle","trans","translate","groups","flatten","src","getSrc","getInfo","console","log","cyan","fileFilter","files","getRelativeSrc","mainfile","getBundleManifestPath","createBundler","join","execute","context","bundleMaps","calcChecksums","checksums","updateBundleManifest","manifest","writeBundleManifest","green","setup","initOption","pipes","ps","getAssertResetPipe","length","concat","working","output","bundlemap","modules","push","sfx","bundleName","filename","bundleDest","getOption","setPackagePath","dirname","toStr","packageFile","jsbuilder","Builder","separateCSS","resolve","jspmConfig","isArray","cf","loadConfig","undefined","t","stream","opt","pr","to","bundleDeps","pkg","getPackage","red","process","exit","deps","dependencies","keys","depsExclude","exclude_1","isFunction","filter","d","indexOf","isBoolean","deplibs","combine","items","cores","each","n","b","exclude","toModule","baseURL","bundleBaseDir","s","toUrl","toModulePath","fn","substring","extname","extend","dest","file","systemConfigTempl","relationToRoot","bust","bundlePaths","paths","getDist","rootpath","getFolders","f","p","env","root","includePackageFiles","jspmMates","*.css","loader","*.json","*.jsx","minify","mangle","sourceMaps","lowResSourceMaps","toRootPath","parent","toRootSrc","toSrc","jspmPackages","directories","packages","readdirSync","rootURL","restps","isUndefined","resetAsserts","folders","isString","pth","toDistPath","existsSync","yellow","toDistSrc","ps_1","dist_1","baseURL_1","root_1","getRootPath","relp","fm","basename","reg","RegExp","reg2","reg3","gb","uniq","split","bundleGp","bundleStr","bundleItems","minusStr","exclusionString","getBundleDest","key","str","exclusionArray","minus","forEach","item","group","builderCfg","bundler","buildStatic","shortPath","getBundleShortPath","parse","base","bind","sync","write","nextTick","end","pipe","chksums","isObject","reject","filepath","err","sum","error","getBundleManifest","template","maps_1","css","json","test","first","jspmMetas","maps","JSON","stringify","jspmMeta","includes","readFile","data","mainfilePipes","mainfileOutput","content","readFileSync","idx","writeFileSync","e","fullPath","min","name_1","PipeTask","__decorate","task","oper","Operation","release","deploy","exports"],"mappings":"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","file":"../JspmBundle.js","sourcesContent":["import * as _ from 'lodash';\r\nimport { IMap, task, RunWay, IAssertDist, ITaskContext, Src, Pipe, OutputPipe, ITaskInfo, TransformSource, ITransform, Operation, PipeTask, bindingConfig } from 'development-core';\r\nimport { Gulp } from 'gulp';\r\nimport * as path from 'path';\r\nimport { IBundlesConfig, IBundleGroup, IBuidlerConfig, IBundleMap, IBundleTransform } from './config';\r\n\r\nimport { readFileSync, readFile, existsSync, writeFileSync, readdirSync } from 'fs';\r\nimport * as chalk from 'chalk';\r\n\r\nconst replace = require('gulp-replace');\r\n// const globby = require('globby');\r\nconst jspm = require('jspm');\r\nconst source = require('vinyl-source-stream');\r\nconst vinylBuffer = require('vinyl-buffer');\r\nconst chksum = require('checksum');\r\nconst mkdirp = require('mkdirp');\r\n// const uglify = require('gulp-uglify');\r\n\r\n\r\n@task({\r\n    oper: Operation.release | Operation.deploy\r\n})\r\nexport class JspmBundle extends PipeTask {\r\n\r\n    name = 'jspm-bundle';\r\n    runWay = RunWay.sequence;\r\n    private bundleMaps: IBundleMap[];\r\n    constructor(info?: ITaskInfo) {\r\n        super(info);\r\n    }\r\n\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (option.bundles) {\r\n            return this.initBundles(<ITaskContext>ctx)\r\n                .then(() => {\r\n                    return Promise.all(_.map(this.getBundles(ctx), name => {\r\n                        return this.loadBuilder(ctx)\r\n                            .then(builder => {\r\n                                let bundle: IBundleGroup = this.bundleConfig[name];\r\n                                let bcfg = this.getBuildConfig(ctx);\r\n                                bundle.builder = <IBuidlerConfig>_.defaults(bundle.builder, bcfg);\r\n                                if (bundle.builder.config) {\r\n                                    builder.config(bundle.builder.config);\r\n                                }\r\n                                return this.groupBundle(<ITaskContext>ctx, builder, name, bundle, gulp)\r\n                                    .then(trans => this.translate(trans));\r\n                            });\r\n                    }))\r\n                }).then(groups => {\r\n                    return _.flatten(groups);\r\n                });\r\n        } else {\r\n            return this.loadBuilder(ctx)\r\n                .then(builder => {\r\n                    let src = ctx.getSrc(this.getInfo());\r\n                    console.log('start bundle all src : ', chalk.cyan(<any>src));\r\n                    let bcfg = this.getBuildConfig(ctx);\r\n                    if (bcfg.config) {\r\n                        builder.config(bcfg.config)\r\n                    }\r\n\r\n                    return ctx.fileFilter(src)\r\n                        .then(files => {\r\n                            files = this.getRelativeSrc(ctx, files);\r\n                            console.log('bundle files:', chalk.cyan(<any>files));\r\n                            let mainfile = this.getBundleManifestPath(<ITaskContext>ctx);\r\n                            return this.createBundler(<ITaskContext>ctx, builder, 'bundle', files.join(' + '), mainfile, bcfg)\r\n                                .then(trans => this.translate(trans));\r\n                        });\r\n                });\r\n        }\r\n    }\r\n\r\n    execute(context: ITaskContext, gulp: Gulp) {\r\n        this.bundleMaps = [];\r\n        let ctx = <ITaskContext>context;\r\n        return super.execute(ctx, gulp)\r\n            .then(() => {\r\n                let option = <IBundlesConfig>ctx.option;\r\n                if (option.bundles) {\r\n                    return this.calcChecksums(option, this.bundleMaps).then((checksums) => {\r\n                        return this.updateBundleManifest(ctx, this.bundleMaps, checksums);\r\n                    });\r\n                } else {\r\n                    return null;\r\n                }\r\n            }).then(manifest => {\r\n                if (manifest) {\r\n                    return this.writeBundleManifest(ctx, manifest, gulp)\r\n                        .then(() => {\r\n                            console.log(chalk.green('------ Complete -------------'));\r\n                        });\r\n                } else {\r\n                    console.log(chalk.green('------ Complete -------------'));\r\n                    return null;\r\n                }\r\n            });\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp: Gulp) {\r\n        ctx.option = this.initOption(ctx);\r\n        return super.setup(ctx, gulp);\r\n    }\r\n\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        let pipes = super.pipes(ctx, dist, gulp) || [];\r\n        let ps = this.getAssertResetPipe(ctx);\r\n        if (ps && ps.length > 0) {\r\n            pipes = pipes.concat(ps);\r\n        }\r\n        return pipes;\r\n    }\r\n\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        let bundle = <IBundleMap>source['bundle'];\r\n        return super.working(source, ctx, option, gulp, pipes, output)\r\n            .then(() => {\r\n                let bundlemap: IBundleMap = {\r\n                    path: bundle.path,\r\n                    modules: bundle.modules\r\n                };\r\n                this.bundleMaps.push(bundlemap);\r\n                if (bundle.sfx) {\r\n                    console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                } else {\r\n                    console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                }\r\n                return;\r\n            });\r\n    }\r\n\r\n\r\n    protected getOption(config: ITaskContext): IAssertDist {\r\n        return config.option;\r\n    }\r\n\r\n    protected loadBuilder(ctx: ITaskContext): Promise<any> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        jspm.setPackagePath(path.dirname(ctx.toStr(option.packageFile)));\r\n        let jsbuilder = new jspm.Builder({ separateCSS: option.builder.separateCSS });\r\n\r\n        return Promise.resolve(jsbuilder)\r\n            .then(builder => {\r\n                if (option.jspmConfig) {\r\n                    if (_.isArray(option.jspmConfig)) {\r\n                        return Promise.all(option.jspmConfig.map(cf => builder.loadConfig(cf, undefined, true)))\r\n                            .then(() => {\r\n                                return builder;\r\n                            });\r\n                    } else {\r\n                        return builder.loadConfig(option.jspmConfig, undefined, true)\r\n                            .then(() => {\r\n                                return builder;\r\n                            });\r\n                    }\r\n                } else {\r\n                    return builder;\r\n                }\r\n            });\r\n    }\r\n\r\n    private translate(trans: IBundleTransform | IBundleTransform[]): ITransform | ITransform[] {\r\n        if (_.isArray(trans)) {\r\n            return _.map(trans, t => {\r\n                t.stream['bundle'] = t.bundle;\r\n                return t.stream;\r\n            });\r\n        } else {\r\n            trans.stream['bundle'] = trans.bundle;\r\n            return trans.stream;\r\n        }\r\n    }\r\n\r\n    private bundleConfig: IMap<IBundleGroup>;\r\n    protected initBundles(ctx: ITaskContext): Promise<IMap<IBundleGroup>> {\r\n        let opt = <IBundlesConfig>ctx.option;\r\n        let pr = Promise.resolve<IMap<IBundleGroup>>(null)\r\n            .then(() => ctx.to<IMap<IBundleGroup> | Promise<IMap<IBundleGroup>>>(opt.bundles));\r\n\r\n        if (opt.bundleDeps) {\r\n            pr = pr.then(bundles => {\r\n                let pkg = ctx.getPackage(<string>opt.packageFile);\r\n                if (!pkg) {\r\n                    console.log(chalk.red('can not found package.json file.'));\r\n                    process.exit(0);\r\n                }\r\n\r\n                let deps = opt.dependencies ? ctx.to<string[]>(opt.dependencies) : _.keys(pkg.jspm.dependencies);\r\n                if (!deps || deps.length < 0) {\r\n                    console.log(chalk.red('not set bundle dependencies libs, or not setting jspm config.'));\r\n                    process.exit(0);\r\n                }\r\n                if (opt.depsExclude) {\r\n                    let exclude = _.isFunction(opt.depsExclude) ? opt.depsExclude(ctx, deps) : opt.depsExclude;\r\n                    deps = _.filter(deps, d => exclude.indexOf(d) < 0);\r\n                }\r\n\r\n                return Promise.resolve()\r\n                    .then(() => {\r\n                        if (_.isFunction(opt.bundleDeps)) {\r\n                            // opt['_bundleDepsFunc'] = opt.bundleDeps;\r\n                            return opt.bundleDeps(ctx, deps);\r\n                        } else if (_.isBoolean(opt.bundleDeps)) {\r\n                            return {\r\n                                deplibs: {\r\n                                    combine: true,\r\n                                    items: deps\r\n                                }\r\n                            };\r\n                        } else {\r\n                            return opt.bundleDeps;\r\n                        }\r\n                    })\r\n                    .then(bundleDeps => {\r\n\r\n                        let cores = _.keys(bundleDeps);\r\n                        _.each(_.keys(bundles), n => {\r\n                            let b: IBundleGroup = bundles[n];\r\n                            b.exclude = b.exclude || [];\r\n                            b.exclude = cores.concat(b.exclude);\r\n                            bundleDeps[n] = b;\r\n                        });\r\n\r\n                        return bundleDeps;\r\n                    });\r\n            });\r\n        }\r\n\r\n        return pr.then(bundles => {\r\n            this.bundleConfig = bundles;\r\n            console.log('group bundles setting:\\n', bundles, '---------------------------------\\n');\r\n            return bundles;\r\n        });\r\n\r\n    }\r\n\r\n    private getRelativeSrc(ctx: ITaskContext, src: Src, toModule = false): string[] {\r\n        let baseURL = <string>(<IBundlesConfig>ctx.option).bundleBaseDir;\r\n        if (_.isArray(src)) {\r\n            return _.map(src, s => {\r\n                let filename = ctx.toUrl(baseURL, s);\r\n                return toModule ? this.toModulePath(filename) : filename;\r\n            });\r\n        } else {\r\n            let fn = ctx.toUrl(baseURL, src);\r\n            return [(toModule ? this.toModulePath(fn) : fn)];\r\n        }\r\n    }\r\n\r\n    private toModulePath(filename: string): string {\r\n        if (!filename) {\r\n            return '';\r\n        }\r\n        return filename.substring(0, filename.length - path.extname(filename).length);\r\n    }\r\n\r\n    private initOption(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>_.extend(<IBundlesConfig>{\r\n            baseURL: '',\r\n            bundleBaseDir: '.',\r\n            mainfile: 'bundle.js',\r\n            jspmConfig: '',\r\n            packageFile: 'package.json',\r\n            dest: '',\r\n            file: '',\r\n            systemConfigTempl: '',\r\n            relationToRoot: '',\r\n            bust: '',\r\n            bundles: null,\r\n            bundlePaths(ctx) {\r\n                let paths: any = {};\r\n                let bundleDest = ctx.getDist();\r\n                let rootpath = <string>option.bundleBaseDir;\r\n                ctx.getFolders(rootpath, (f, d) => {\r\n                    if (f !== bundleDest) {\r\n                        let p = d + '/*';\r\n                        paths[p] = ctx.toUrl(ctx.env.root, path.join(rootpath, p));\r\n                    }\r\n                    return '';\r\n                });\r\n                // let jpk = <string>option.jspmPackages;\r\n                // let jp = path.basename(jpk) + '/*';\r\n                // paths[jp] = self.toUrl(rootpath, path.join(jpk, jp));\r\n                console.log('paths: ', paths);\r\n                return paths;\r\n            },\r\n            includePackageFiles: [\r\n                'system-polyfills.src.js',\r\n                'system.src.js'\r\n            ],\r\n            jspmMates: {\r\n                '*.css': {\r\n                    loader: 'css'\r\n                },\r\n                '*.json': {\r\n                    loader: 'json'\r\n                },\r\n                '*.jsx': {\r\n                    loader: 'jsx'\r\n                }\r\n            },\r\n            builder: {\r\n                sfx: false,\r\n                minify: false,\r\n                mangle: false,\r\n                sourceMaps: false,\r\n                separateCSS: false,\r\n                lowResSourceMaps: true\r\n            }\r\n        }, <IBundlesConfig>ctx.option);\r\n\r\n        ctx.option = option;\r\n\r\n        option.baseURL = ctx.toRootPath(ctx.toStr(option.baseURL));\r\n        if (!option.bundleBaseDir && ctx.parent) {\r\n            option.bundleBaseDir = ctx.parent.getDist()\r\n        } else if (option.bundleBaseDir) {\r\n            option.bundleBaseDir = ctx.toRootPath(ctx.toStr(option.bundleBaseDir));\r\n        } else {\r\n            console.log(chalk.red('bundleBaseURL config error!'));\r\n            process.exit(0);\r\n        }\r\n\r\n        if (option.jspmConfig) {\r\n            option.jspmConfig = ctx.toRootSrc(ctx.toSrc(option.jspmConfig));\r\n        }\r\n        option.packageFile = ctx.toRootPath(ctx.toStr(option.packageFile));\r\n        option.mainfile = ctx.toStr(option.mainfile);\r\n        let pkg = ctx.getPackage(<string>option.packageFile);\r\n        if (!option.jspmPackages) {\r\n            if (pkg.jspm.directories && pkg.jspm.directories.packages) {\r\n                option.jspmPackages = <string>pkg.jspm.directories.packages;\r\n            } else {\r\n                option.jspmPackages = 'jspm_packages';\r\n            }\r\n        }\r\n        option.jspmPackages = ctx.toRootPath(ctx.toStr(option.jspmPackages));\r\n\r\n        if (!readdirSync(option.jspmPackages)) {\r\n            console.log(chalk.red('jspm project config error!'));\r\n            process.exit(0);\r\n        }\r\n\r\n        return option;\r\n    }\r\n\r\n    protected getBuildConfig(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (!option.builder.config) {\r\n            option.builder.config = _.extend(option.builder.config || {}, {\r\n                paths: ctx.to<IMap<string>>(option.bundlePaths) || {},\r\n                rootURL: <string>option.bundleBaseDir\r\n            });\r\n        }\r\n\r\n        return option.builder;\r\n    }\r\n\r\n    private restps: Pipe[];\r\n    protected getAssertResetPipe(ctx: ITaskContext) {\r\n        if (!this.restps) {\r\n            let option = <IBundlesConfig>ctx.option;\r\n            if (_.isUndefined(option.resetAsserts)) {\r\n                option.resetAsserts = 'assets';\r\n            }\r\n            if (option.resetAsserts) {\r\n                let folders: string[];\r\n                if (_.isString(option.resetAsserts)) {\r\n                    let pth = ctx.toDistPath(option.resetAsserts, this.getInfo());\r\n                    if (existsSync(pth)) {\r\n                        folders = ctx.getFolders(pth);\r\n                        folders.push(pth);\r\n                    } else {\r\n                        console.log(chalk.yellow('rest css asserts folders:', pth, 'not exists.'))\r\n                    }\r\n                } else {\r\n                    folders = <string[]>ctx.toDistSrc(option.resetAsserts, this.getInfo());\r\n                }\r\n\r\n                folders = folders || [];\r\n\r\n                let ps = [];\r\n                let dist = ctx.getDist(this.getInfo());\r\n                let baseURL = <string>option.baseURL; // ctx.toUrl(ctx.getRootPath(), <string>option.baseURL) || '.';\r\n                let root = ctx.getRootPath();\r\n                _.each(folders, f => {\r\n                    let relp = ctx.toUrl(root, path.join(baseURL, ctx.toUrl(dist, f)));\r\n                    let fm = path.basename(f);\r\n                    console.log('reset css url folder name:', chalk.cyan(fm), 'relate url:', chalk.cyan(relp));\r\n                    let reg = new RegExp(`(url\\\\((..\\\\/)+${fm})|(url\\\\(\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg, `url(${relp}`));\r\n                    let reg2 = new RegExp(`(url\\\\(\\\\'(..\\\\/)+${fm})|(url\\\\(\\\\'\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg2, `url(\\\\'${relp}`));\r\n                    let reg3 = new RegExp(`(url\\\\((\"..\\\\/)+${fm})|(url\\\\(\"\\\\/${fm})`, 'gi');\r\n                    ps.push(() => replace(reg3, `url(\"${relp}`));\r\n                });\r\n                this.restps = ps;\r\n            } else {\r\n                this.restps = [];\r\n            }\r\n        }\r\n        return this.restps;\r\n    }\r\n\r\n\r\n    protected getBundles(ctx: ITaskContext) {\r\n\r\n        let groups = [];\r\n        if (ctx.env.gb) {\r\n            groups = _.uniq(_.isArray(ctx.env.gb) ? ctx.env.gb : (ctx.env.gb || '').split(','));\r\n        }\r\n\r\n        if (groups.length < 1) {\r\n            groups = _.keys(this.bundleConfig);\r\n        } else {\r\n            groups = _.filter(groups, f => f && this.bundleConfig[f]);\r\n        }\r\n        console.log('cmmand group bundle:', chalk.cyan(<any>groups));\r\n        return groups;\r\n    }\r\n\r\n    protected groupBundle(config: ITaskContext, builder, name: string, bundleGp: IBundleGroup, gulp: Gulp): Promise<IBundleTransform | IBundleTransform[]> {\r\n\r\n        let bundleStr = '';\r\n        let bundleDest = '';\r\n\r\n        let bundleItems: string[] = [];\r\n        let minusStr = this.exclusionString(bundleGp.exclude, this.bundleConfig);\r\n\r\n        if (bundleGp.items) {\r\n            bundleItems = _.isArray(bundleItems) ? <string[]>bundleGp.items : _.keys(bundleGp.items);\r\n        }\r\n\r\n        if (bundleGp.combine) {\r\n            bundleDest = this.getBundleDest(config, name, bundleGp);\r\n            bundleStr = bundleItems.join(' + ') + minusStr;\r\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup source:\\n  ${chalk.cyan(bundleStr)}\\n-------------------------------`);\r\n            return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n\r\n        } else {\r\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(<any>bundleItems)}\\n-------------------------------`);\r\n            return Promise.all(bundleItems.map(key => {\r\n                bundleStr = key + minusStr;\r\n                bundleDest = this.getBundleDest(config, key, bundleGp);\r\n                return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n            }));\r\n        }\r\n    }\r\n\r\n    private exclusionString(exclude, groups): string {\r\n        let str = this.exclusionArray(exclude, groups).join(' - ');\r\n        return (str) ? ' - ' + str : '';\r\n    }\r\n\r\n    private exclusionArray(exclude, groups): string[] {\r\n        let minus: string[] = [];\r\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\r\n        _.forEach(exclude, (item: string) => {\r\n            var group = groups[item];\r\n            if (group) {\r\n                // exclude everything from this group\r\n                minus = minus.concat(this.exclusionArray(group.items, groups));\r\n            } else {\r\n                // exclude this item by name\r\n                minus.push(item);\r\n            }\r\n        });\r\n        return minus;\r\n    }\r\n\r\n    private createBundler(config: ITaskContext, builder: any, bundleName: string, bundleStr: string, bundleDest: string, builderCfg: IBuidlerConfig, bundleGp?: IBundleGroup): Promise<IBundleTransform> {\r\n\r\n        let sfx = builderCfg.sfx;\r\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\r\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleGp);\r\n        let filename = path.parse(bundleDest).base;\r\n\r\n        return bundler.bind(builder)(bundleStr, bundleDest, builderCfg)\r\n            .then(output => {\r\n                mkdirp.sync(path.dirname(bundleDest));\r\n                var stream: ITransform = source(filename);\r\n                stream.write(output.source);\r\n                process.nextTick(function () {\r\n                    stream.end();\r\n                });\r\n\r\n                console.log('pipe bundling：', chalk.cyan(bundleName));\r\n                return {\r\n                    stream: stream.pipe(vinylBuffer()),\r\n                    bundle: {\r\n                        path: shortPath,\r\n                        sfx: sfx,\r\n                        bundleName: bundleName,\r\n                        filename: filename,\r\n                        bundleDest: bundleDest,\r\n                        modules: output.modules\r\n                    }\r\n                };\r\n            });\r\n\r\n    }\r\n\r\n    private calcChecksums(option: IBundlesConfig, bundles: any[]): Promise<any> {\r\n        let chksums = {};\r\n\r\n        console.log('Calculating checksums...');\r\n\r\n        return Promise.all(_.map(bundles, (bundle: any) => {\r\n            if (!_.isObject(bundle)) {\r\n                return null;\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                let filepath = path.join(<string>option.bundleBaseDir || '.', bundle.path);\r\n                let filename = path.parse(bundle.path).base;\r\n                chksum.file(filepath, (err, sum) => {\r\n                    if (err) {\r\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\r\n                    }\r\n                    console.log(filename, chalk.cyan(sum));\r\n                    chksums[bundle.path] = sum;\r\n                    resolve(chksums);\r\n                });\r\n            });\r\n\r\n        })).then(() => {\r\n            return chksums;\r\n        });\r\n    }\r\n\r\n    protected updateBundleManifest(ctx: ITaskContext, bundles: any[], chksums?: any) {\r\n\r\n        chksums = chksums || {};\r\n\r\n        var manifest: any = _.defaults(this.getBundleManifest(ctx), {\r\n            bundles: {},\r\n            chksums: {}\r\n        });\r\n\r\n        // console.log(manifest);\r\n\r\n        _.each(bundles, bundle => {\r\n            if (bundle.path) {\r\n                manifest.bundles[bundle.path] = bundle.modules;\r\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\r\n            }\r\n        });\r\n\r\n        return manifest;\r\n\r\n    }\r\n\r\n    private manifestSplit = `/*------bundles infos------*/`;\r\n    private writeBundleManifest(ctx: ITaskContext, manifest, gulp: Gulp): Promise<any> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (!option.mainfile) {\r\n            return Promise.reject('mainfile not configed.');\r\n        }\r\n\r\n\r\n        console.log('Writing manifest...');\r\n\r\n        let baseURL = ctx.toUrl(ctx.getRootPath(), <string>option.baseURL) || '.';\r\n        console.log('system config baseURL: ', chalk.cyan(baseURL));\r\n\r\n        let bust = ctx.toStr(option.bust);\r\n        console.log('system bust: ', chalk.cyan(bust));\r\n\r\n        let output = `\r\nSystem.config({\r\n    baseURL: '${baseURL}',\r\n    defaultJSExtensions: true\r\n});\r\nSystem.bundled = true;\r\nSystem.bust = '${bust}';\r\nif(window != undefined) window.prod = true;\r\n${this.manifestSplit}\r\n`;\r\n        let template = '';\r\n\r\n        if (manifest) {\r\n            // try {\r\n            template = ctx.toStr(option.systemConfigTempl);\r\n\r\n            if (!template) {\r\n                template = (bust) ? `\r\n(function(module) {\r\n    var bust = {};\r\n    var systemLocate = System.locate;\r\n    var systemNormalize = System.normalize;\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var chksums = module.exports.chksums = \\${chksums};\r\n    var bundles = module.exports.bundles = \\${bundles};                    \r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n    System.normalize = function (name, pName, pAddress) {\r\n        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n            var chksum = chksums[name];\r\n            if (chksums[name]) { bust[address] = chksum; }\r\n            return address;\r\n        });\r\n    };\r\n\r\n    System.locate = function (load) {\r\n        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n            var chksum = bust[address];\r\n            return (chksum) ? address + '?' + chksum : address;\r\n        });\r\n    };\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n` : `\r\n(function(module) {\r\n    var bundles = module.exports.bundles = \\${bundles};\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n`;\r\n            }\r\n\r\n\r\n            let maps = {\r\n                css: 'github:systemjs/plugin-css@0.1.20.js',\r\n                json: 'github:systemjs/plugin-json@0.1.2.js'\r\n            };\r\n\r\n            _.each(_.keys(manifest.bundles), n => {\r\n                if (/css.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n                if (/json.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n            });\r\n\r\n            let jspmMetas = option.jspmMates;\r\n            output += _.template(template)({\r\n                maps: JSON.stringify(maps, null, '    '),\r\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\r\n                paths: JSON.stringify(null, null, '    '), // option.builder.config ? option.builder.config.paths :\r\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\r\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\r\n            });\r\n\r\n        }\r\n\r\n\r\n        let includes = option.includes || [];\r\n\r\n        includes = includes.concat(_.map(option.includePackageFiles, f => path.join(option.jspmPackages, f)));\r\n\r\n        return Promise.all(_.map(includes, f => {\r\n            return new Promise<string>((resolve, reject) => {\r\n                readFile(f, 'utf8', (err, data) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    } else {\r\n                        resolve(data);\r\n                    }\r\n                });\r\n            });\r\n        }))\r\n            .then(data => {\r\n                data.push(output);\r\n                let mainfile = ctx.toStr(option.mainfile); // path.relative(this.getBundleManifestPath(ctx), ctx.getDist(this.getInfo()));\r\n                console.log('mainfile:', mainfile);\r\n                mkdirp.sync(path.dirname(mainfile));\r\n                var stream = <NodeJS.ReadWriteStream>source(mainfile);\r\n                stream.write(data.join('\\n'));\r\n                process.nextTick(() => {\r\n                    stream.end();\r\n                });\r\n\r\n                return super.working(stream.pipe(vinylBuffer()), ctx, option, gulp, option.mainfilePipes || [], option.mainfileOutput);\r\n            });\r\n\r\n    }\r\n\r\n    private getBundleManifestPath(ctx: ITaskContext): string {\r\n        return this.getBundleDest(ctx, <string>(<IBundlesConfig>ctx.option).mainfile);\r\n    }\r\n    private getBundleManifest(ctx: ITaskContext): any {\r\n        let data: any = {};\r\n        let mainfile: string = this.getBundleManifestPath(ctx);\r\n        console.log('try to load old bundle in path ', mainfile);\r\n        if (existsSync(mainfile)) {\r\n            try {\r\n                let content = readFileSync(mainfile, 'utf8');\r\n                let idx = content.indexOf(this.manifestSplit);\r\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\r\n                content = content.substring(idx);\r\n                // console.log(content);\r\n                writeFileSync(mainfile, content);\r\n                data = require(mainfile);\r\n                console.log('has old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\r\n            } catch (e) {\r\n                console.log(chalk.red(e));\r\n            }\r\n        } else {\r\n            console.log('no old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    private getBundleShortPath(ctx: ITaskContext, bundleName: string, bundleGp?: IBundleGroup) {\r\n        var fullPath = bundleGp ? this.getBundleDest(ctx, bundleName, bundleGp)\r\n            : path.join(ctx.getDist(), bundleName);\r\n\r\n        return ctx.toUrl(<string>(<IBundlesConfig>ctx.option).bundleBaseDir, fullPath)\r\n\r\n    }\r\n\r\n    private getBundleDest(ctx: ITaskContext, bundleName: string, bundleGp?: IBundleGroup) {\r\n\r\n        let dest = ctx.getDist();\r\n        if (bundleGp) {\r\n            let min = bundleGp.builder.minify;\r\n            let name = bundleGp.items[bundleName] || bundleName;\r\n            let file = name + ((min) ? '.min.js' : '.js');\r\n\r\n            if (bundleGp.combine) {\r\n                dest = path.join(dest, file);\r\n            } else {\r\n                dest = path.join(dest, bundleName, file);\r\n            }\r\n        } else {\r\n            dest = path.join(dest, bundleName);\r\n        }\r\n\r\n        return dest;\r\n    }\r\n}\r\n"]}