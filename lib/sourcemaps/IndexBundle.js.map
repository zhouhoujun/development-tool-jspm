{"version":3,"sources":["IndexBundle.js","IndexBundle.ts"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","_typeof","decorate","i","defineProperty","__metadata","k","v","metadata","development_core_1","require","htmlreplace","IndexBundle","info","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","call","name","_inherits","_development_core_1$P","_createClass","value","ctx","option","gulp","cfgopt","src","index","toRootSrc","pipes","dist","pkg","getPackage","js","toStr","mainfile","bust","version","indexPipes","concat","PipeTask","task","order","oper","Operation","release","deploy","exports"],"mappings":"AAAA,8kCACIA,WAA0C,SAAUC,EAAYC,EAAQC,EAAKC,GAC7E,GAA2HC,GAAvHC,EAAIC,UAAUC,OAAQC,EAAIH,EAAI,EAAIJ,EAAkB,OAATE,EAAgBA,EAAOM,OAAOC,yBAAyBT,EAAQC,GAAOC,CACrH,IAAuB,YAAnB,mBAAOQ,SAAP,YAAAC,QAAOD,WAAoD,kBAArBA,SAAQE,SAAyBL,EAAIG,QAAQE,SAASb,EAAYC,EAAQC,EAAKC,OACpH,KAAK,GAAIW,GAAId,EAAWO,OAAS,EAAGO,GAAK,EAAGA,KAASV,EAAIJ,EAAWc,MAAIN,GAAKH,EAAI,EAAID,EAAEI,GAAKH,EAAI,EAAID,EAAEH,EAAQC,EAAKM,GAAKJ,EAAEH,EAAQC,KAASM,EAChJ,OAAOH,GAAI,GAAKG,GAAKC,OAAOM,eAAed,EAAQC,EAAKM,GAAIA,GAE5DQ,WAA0C,SAAUC,EAAGC,GACvD,GAAuB,YAAnB,mBAAOP,SAAP,YAAAC,QAAOD,WAAoD,kBAArBA,SAAQQ,SAAyB,MAAOR,SAAQQ,SAASF,EAAGC,ICP1GE,mBAAAC,QAA4G,oBAEhGC,YAAWD,QAAM,qBAO7BE,YAAAA,SAAAA,GAEI,QAAAA,GAAYC,GAAgBC,gBAAAC,KAAAH,EAAA,IAAAI,GAAAC,2BAAAF,MAAAH,EAAAM,WAAApB,OAAAqB,eAAAP,IAAAQ,KAAAL,KAClBF,GADkB,OAExBG,GAAKK,KAAO,YAFYL,EAFhC,MAAAM,WAAAV,EAAAW,GAAAC,aAAAZ,IAAArB,IAAA,SAAAkC,MAAA,SAOWC,EAAmBC,EAAqBC,GAC3C,GAAIC,GAAyBH,EAAIC,OAC7BG,EAAAA,MAMJ,OAJIA,GADAD,EAAOE,MACDF,EAAOE,MAEP,iBAEHH,EAAKE,IAAIJ,EAAIM,UAAUF,OAftCvC,IAAA,QAAAkC,MAAA,QAAAQ,GA0BUP,EAAmBQ,EAAmBN,GACxC,GAAID,GAAyBD,EAAIC,OAC7BQ,EAAMT,EAAIU,aACVH,GACA,SAACP,GAAD,MAAuBf,cAAc0B,GAAMX,EAAIY,MAAMX,EAAOY,UAAY,UAAYb,EAAIY,MAAMX,EAAOa,OAASL,EAAIM,YAOtH,OAJId,GAAOe,YAAcf,EAAOe,WAAW9C,OAAS,IAChDqC,EAAQA,EAAMU,OAAOhB,EAAOe,aAGzBT,MArCfrB,GAAiCH,mBAAAmC,SAJjChC,aAAAxB,YAACqB,mBAAAoC,MACGC,MAAO,EACPC,KAAMtC,mBAAAuC,UAAUC,QAAUxC,mBAAAuC,UAAUE,SAuBpC7C,WAAA,qBAAAP,UACAc,aAtBSuC,QAAAvC,YAAWA","file":"../IndexBundle.js","sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nconst development_core_1 = require('development-core');\nconst htmlreplace = require('gulp-html-replace');\nlet IndexBundle = class IndexBundle extends development_core_1.PipeTask {\n    constructor(info) {\n        super(info);\n        this.name = 'mainindex';\n    }\n    source(ctx, option, gulp) {\n        let cfgopt = ctx.option;\n        let src;\n        if (cfgopt.index) {\n            src = cfgopt.index;\n        }\n        else {\n            src = 'src/index.html';\n        }\n        return gulp.src(ctx.toRootSrc(src));\n    }\n    // private packages = {};\n    // public getPackage(option: IBundlesConfig): any {\n    //     if (!this.packages[<string>option.packageFile]) {\n    //         this.packages[<string>option.packageFile] = require(<string>option.packageFile);\n    //     }\n    //     return this.packages[<string>option.packageFile]\n    // }\n    pipes(ctx, dist, gulp) {\n        let option = ctx.option;\n        let pkg = ctx.getPackage();\n        let pipes = [\n                (ctx) => htmlreplace({ 'js': ctx.toStr(option.mainfile) + '?bust=' + (ctx.toStr(option.bust) || pkg.version) })\n        ];\n        if (option.indexPipes && option.indexPipes.length > 0) {\n            pipes = pipes.concat(option.indexPipes);\n        }\n        return pipes; // concat(super.pipes(ctx, dist, gulp));\n    }\n};\nIndexBundle = __decorate([\n    development_core_1.task({\n        order: 1,\n        oper: development_core_1.Operation.release | development_core_1.Operation.deploy\n    }), \n    __metadata('design:paramtypes', [Object])\n], IndexBundle);\nexports.IndexBundle = IndexBundle;\n","import * as _ from 'lodash';\r\nimport { task, Src, ITaskContext, IAssertDist, Pipe, ITaskInfo, TransformSource, Operation, PipeTask } from 'development-core';\r\nimport { Gulp } from 'gulp';\r\nimport * as htmlreplace from 'gulp-html-replace';\r\nimport { IBundlesConfig } from './config';\r\n\r\n@task({\r\n    order: 1,\r\n    oper: Operation.release | Operation.deploy\r\n})\r\nexport class IndexBundle extends PipeTask {\r\n\r\n    constructor(info?: ITaskInfo) {\r\n        super(info);\r\n        this.name = 'mainindex';\r\n    }\r\n\r\n    source(ctx: ITaskContext, option: IAssertDist, gulp: Gulp): TransformSource | Promise<TransformSource> {\r\n        let cfgopt = <IBundlesConfig>ctx.option;\r\n        let src: Src;\r\n        if (cfgopt.index) {\r\n            src = cfgopt.index;\r\n        } else {\r\n            src = 'src/index.html';\r\n        }\r\n        return gulp.src(ctx.toRootSrc(src));\r\n    }\r\n\r\n    // private packages = {};\r\n    // public getPackage(option: IBundlesConfig): any {\r\n    //     if (!this.packages[<string>option.packageFile]) {\r\n    //         this.packages[<string>option.packageFile] = require(<string>option.packageFile);\r\n    //     }\r\n    //     return this.packages[<string>option.packageFile]\r\n    // }\r\n\r\n    pipes(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): Pipe[] {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        let pkg = ctx.getPackage()\r\n        let pipes = <Pipe[]>[\r\n            (ctx: ITaskContext) => htmlreplace({ 'js': ctx.toStr(option.mainfile) + '?bust=' + (ctx.toStr(option.bust) || pkg.version) })\r\n        ];\r\n\r\n        if (option.indexPipes && option.indexPipes.length > 0) {\r\n            pipes = pipes.concat(option.indexPipes);\r\n        }\r\n\r\n        return pipes; // concat(super.pipes(ctx, dist, gulp));\r\n    }\r\n}\r\n"]}