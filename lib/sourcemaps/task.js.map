{"version":3,"sources":["task.js","task.ts"],"names":["__decorate","decorators","target","key","desc","d","c","arguments","length","r","Object","getOwnPropertyDescriptor","Reflect","_typeof","decorate","i","defineProperty","__metadata","k","v","metadata","_","require","development_core_1","path","fs_1","chalk","jspm","source","vinylBuffer","chksum","mkdirp","JspmBundle","info","_classCallCheck","this","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","call","name","runWay","RunWay","sequence","manifestSplit","_inherits","_development_core_1$P","_createClass","value","config","option","jsbuilder","Builder","separateCSS","builder","Promise","resolve","then","jspmConfig","loadConfig","undefined","dist","gulp","_this2","bundles","all","map","getbundles","loadBuilder","bundle","defaults","groupBundle","groups","flatten","sfx","bundler","buildStatic","bind","getSrc","_this3","_get","prototype","bust","calcChecksums","checksums","updateBundleManifest","manifest","writeBundleManifest","console","log","green","_this4","cyan","bundleName","filename","bundleDest","bundlemap","shortPath","modules","push","uniq","isArray","env","gb","split","keys","filter","f","bundleOpts","_this5","bundleStr","bundleItems","minusStr","exclusionString","exclude","items","combine","getBundleDest","join","createBundler","str","exclusionArray","_this6","minus","forEach","item","group","concat","getBundleShortPath","parse","base","buildConfig","toES5","clone","minify","sourceMaps","output","sync","dirname","stream","write","process","nextTick","end","pipe","chksums","isObject","reject","filepath","baseURL","file","err","sum","error","red","getBundleManifest","each","_this7","mainfile","rootUri","template","systemConfigTempl","maps","css","json","n","test","first","jspmMetas","JSON","stringify","jspmMeta","getBundleManifestPath","includes","readFile","data","url","existsSync","content","readFileSync","idx","indexOf","substring","writeFileSync","e","fullPath","spath","relative","replace","getDist","min","PipeTask","task","oper","Operation","release","deploy","exports"],"mappings":"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","file":"../task.js","sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nconst _ = require('lodash');\nconst development_core_1 = require('development-core');\nconst path = require('path');\nconst fs_1 = require('fs');\nconst chalk = require('chalk');\nconst jspm = require('jspm');\nconst source = require('vinyl-source-stream');\nconst vinylBuffer = require('vinyl-buffer');\nconst chksum = require('checksum');\nconst mkdirp = require('mkdirp');\nlet JspmBundle = class JspmBundle extends development_core_1.PipeTask {\n    constructor(info) {\n        super(info);\n        this.name = 'jspm-bundle';\n        this.runWay = development_core_1.RunWay.sequence;\n        this.manifestSplit = `/*------bundles infos------*/`;\n    }\n    getOption(config) {\n        return config.option;\n    }\n    loadBuilder(config) {\n        let option = config.option;\n        let jsbuilder = new jspm.Builder({ separateCSS: option.builder.separateCSS });\n        return Promise.resolve(jsbuilder)\n            .then(builder => {\n            if (option.jspmConfig) {\n                return builder.loadConfig(option.jspmConfig, undefined, true)\n                    .then(() => {\n                    return builder;\n                });\n            }\n            else {\n                return builder;\n            }\n        });\n    }\n    sourceStream(config, dist, gulp) {\n        let option = config.option;\n        if (option.bundles) {\n            return Promise.all(_.map(this.getbundles(config), name => {\n                return this.loadBuilder(config)\n                    .then(builder => {\n                    let bundle = option.bundles[name];\n                    bundle.builder = _.defaults(bundle.builder, option.builder);\n                    return this.groupBundle(config, name, bundle, gulp);\n                });\n            })).then(groups => {\n                return _.flatten(groups);\n            });\n        }\n        else {\n            return this.loadBuilder(config)\n                .then(builder => {\n                builder.config(option.builder.config);\n                let sfx = option.builder.sfx;\n                var bundler = (sfx) ? builder.buildStatic : builder.bundle;\n                return bundler.bind(builder)(config.getSrc(), option.builder);\n            });\n        }\n    }\n    execute(config, gulp) {\n        this.bundles = [];\n        return super.execute(config, gulp)\n            .then(() => {\n            let option = config.option;\n            if (option.bundles) {\n                if (option.bust) {\n                    return this.calcChecksums(option, this.bundles).then((checksums) => {\n                        return this.updateBundleManifest(option, this.bundles, checksums);\n                        ;\n                    });\n                }\n                else {\n                    return this.updateBundleManifest(option, this.bundles);\n                }\n            }\n            else {\n                return null;\n            }\n        }).then(manifest => {\n            if (manifest) {\n                return this.writeBundleManifest(config, manifest, gulp)\n                    .then(() => {\n                    console.log(chalk.green('------ Complete -------------'));\n                });\n            }\n            else {\n                console.log(chalk.green('------ Complete -------------'));\n                return null;\n            }\n        });\n    }\n    working(source, config, option, gulp) {\n        let bundle = source['bundle'];\n        if (bundle.sfx) {\n            console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\n        }\n        else {\n            console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\n        }\n        return super.working(source, config, option, gulp)\n            .then(() => {\n            let bundlemap = {\n                path: bundle.shortPath,\n                modules: bundle.modules\n            };\n            this.bundles.push(bundlemap);\n            return bundlemap;\n        });\n    }\n    getbundles(config) {\n        let option = config.option;\n        let groups = _.uniq(_.isArray(config.env.gb) ? config.env.gb : (config.env.gb || '').split(','));\n        if (groups.length < 1) {\n            groups = _.keys(option.bundles);\n        }\n        else {\n            groups = _.filter(groups, f => f && groups[f]);\n        }\n        return groups;\n    }\n    groupBundle(config, name, bundleOpts, gulp) {\n        let option = config.option;\n        let bundleStr = '';\n        let bundleDest = '';\n        let bundleItems = [];\n        let minusStr = this.exclusionString(bundleOpts.exclude, option.bundles);\n        if (bundleOpts.items) {\n            bundleItems = _.isArray(bundleItems) ? bundleOpts.items : _.keys(bundleOpts.items);\n        }\n        console.log(`-------------------------------\\nBundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(bundleItems)}\\n-------------------------------`);\n        let jsbuilder = new jspm.Builder({ separateCSS: bundleOpts.builder.separateCSS });\n        return Promise.resolve(jsbuilder)\n            .then(builder => {\n            if (option.jspmConfig) {\n                return builder.loadConfig(option.jspmConfig, undefined, true)\n                    .then(() => {\n                    return builder;\n                });\n            }\n            else {\n                return builder;\n            }\n        })\n            .then(builder => {\n            builder.config(bundleOpts.builder.config);\n            if (bundleOpts.combine) {\n                bundleDest = this.getBundleDest(config, name, bundleOpts);\n                bundleStr = bundleItems.join(' + ') + minusStr;\n                return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleOpts, gulp);\n            }\n            else {\n                return Promise.all(bundleItems.map(key => {\n                    bundleStr = key + minusStr;\n                    bundleDest = this.getBundleDest(config, key, bundleOpts);\n                    return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleOpts, gulp);\n                }));\n            }\n        });\n    }\n    exclusionString(exclude, groups) {\n        var str = this.exclusionArray(exclude, groups).join(' - ');\n        return (str) ? ' - ' + str : '';\n    }\n    exclusionArray(exclude, groups) {\n        var minus = [];\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\n        _.forEach(exclude, (item) => {\n            var group = groups[item];\n            if (group) {\n                // exclude everything from this group\n                minus = minus.concat(this.exclusionArray(group.items, groups));\n            }\n            else {\n                // exclude this item by name\n                minus.push(item);\n            }\n        });\n        return minus;\n    }\n    createBundler(config, builder, bundleName, bundleStr, bundleDest, bundleOpts, gulp) {\n        let sfx = bundleOpts.builder.sfx;\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleOpts);\n        let filename = path.parse(bundleDest).base;\n        let buildConfig;\n        if (bundleOpts.toES5) {\n            buildConfig = _.clone(bundleOpts.builder);\n            buildConfig.minify = false;\n            buildConfig.sourceMaps = false;\n        }\n        else {\n            buildConfig = bundleOpts.builder;\n        }\n        return bundler.bind(builder)(bundleStr, bundleDest, buildConfig)\n            .then(output => {\n            mkdirp.sync(path.dirname(bundleDest));\n            var stream = source(filename);\n            stream.write(output.source);\n            process.nextTick(function () {\n                stream.end();\n            });\n            return stream.pipe(vinylBuffer());\n        })\n            .then(output => {\n            output['bundle'] = {\n                path: shortPath,\n                bundleName: bundleName,\n                filename: filename,\n                bundleDest: bundleDest,\n                modules: output.modules\n            };\n            return output;\n        });\n    }\n    calcChecksums(option, bundles) {\n        let chksums = {};\n        console.log('Calculating checksums...');\n        return Promise.all(_.map(bundles, (bundle) => {\n            if (!_.isObject(bundle)) {\n                return null;\n            }\n            return new Promise((resolve, reject) => {\n                let filepath = path.join(option.baseURL, bundle.path);\n                let filename = path.parse(bundle.path).base;\n                chksum.file(filepath, (err, sum) => {\n                    if (err) {\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\n                    }\n                    console.log(filename, chalk.cyan(sum));\n                    chksums[bundle.path] = sum;\n                    resolve(chksums);\n                });\n            });\n        })).then(() => {\n            return chksums;\n        });\n    }\n    updateBundleManifest(option, bundles, chksums) {\n        chksums = chksums || {};\n        var manifest = _.defaults(this.getBundleManifest(option), {\n            bundles: {},\n            chksums: {}\n        });\n        // console.log(manifest);\n        _.each(bundles, bundle => {\n            if (bundle.path) {\n                manifest.bundles[bundle.path] = bundle.modules;\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\n            }\n        });\n        return manifest;\n    }\n    writeBundleManifest(config, manifest, gulp) {\n        let option = config.option;\n        if (!option.mainfile) {\n            return Promise.reject('mainfile not configed.');\n        }\n        console.log('Writing manifest...');\n        let output = `System.config({\r\n            baseURL: '${option.rootUri || '.'}',\r\n            defaultJSExtensions: true\r\n        });\r\n        System.bundled = true;\r\n        System.bust = '${option.bust}';\r\n        if(window != undefined) window.prod = true;\r\n        ${this.manifestSplit}\r\n        `;\n        let template = '';\n        if (manifest) {\n            // try {\n            template = option.systemConfigTempl;\n            if (!template) {\n                template = (option.bust) ?\n                    `\r\n                    (function(module) {\r\n                    var bust = {};\r\n                    var systemLocate = System.locate;\r\n                    var systemNormalize = System.normalize;\r\n\r\n                    var chksums = module.exports.chksums = \\${chksums};\r\n                    var bundles = module.exports.bundles = \\${bundles};                    \r\n                    var maps = \\${ maps };\r\n                    var jspmMeta = \\${ jspmMeta };\r\n\r\n                    System.config({\r\n                         packages: {\r\n                            \"meta\": jspmMeta\r\n                        },\r\n                        map: maps,\r\n                        //paths: paths,\r\n                        bundles: bundles\r\n                    });\r\n\r\n                    System.normalize = function (name, pName, pAddress) {\r\n                        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n                            var chksum = chksums[name];\r\n                            if (chksums[name]) { bust[address] = chksum; }\r\n                            return address;\r\n                        });\r\n                    };\r\n\r\n                    System.locate = function (load) {\r\n                        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n                            var chksum = bust[address];\r\n                            return (chksum) ? address + '?' + chksum : address;\r\n                        });\r\n                    };\r\n\r\n                })((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n                `\n                    :\n                        `\r\n                    (function(module) {\r\n                    var bundles = module.exports.bundles = \\${bundles};\r\n                    var paths =  module.exports.paths = \\${paths};\r\n                    var maps = \\${ maps };\r\n                    var jspmMeta = \\${ jspmMeta };\r\n\r\n                    System.config({\r\n                         packages: {\r\n                            \"meta\": jspmMeta\r\n                        },\r\n                        map: maps,\r\n                        //paths: paths,\r\n                        bundles: bundles\r\n                    });\r\n\r\n                })((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n                `;\n            }\n            // } catch (e) {\n            //     console.log(' X Unable to open manifest template');\n            //     console.log(e);\n            //     return Promise.reject(<any>false);\n            // }\n            let maps = {\n                css: 'github:systemjs/plugin-css@0.1.20.js',\n                json: 'github:systemjs/plugin-json@0.1.2.js'\n            };\n            _.each(_.keys(manifest.bundles), n => {\n                if (/css.min.js$/.test(n)) {\n                    maps.css = _.first(manifest.bundles[n]);\n                }\n                if (/json.min.js$/.test(n)) {\n                    maps.css = _.first(manifest.bundles[n]);\n                }\n            });\n            let jspmMetas = option.jspmMetas;\n            output += _.template(template)({\n                maps: JSON.stringify(maps, null, '    '),\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\n                // paths: JSON.stringify(this.options.builder.config.paths, null, '    '),\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\n            });\n        }\n        let mainfile = this.getBundleManifestPath(option);\n        let includes = option.includes || [\n            './system-polyfills.src.js',\n            './system.src.js'\n        ];\n        return Promise.all(_.map(includes, f => {\n            return new Promise((resolve, reject) => {\n                fs_1.readFile(path.join(option.jspmConfig, f), 'utf8', (err, data) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(data);\n                    }\n                });\n            });\n        }))\n            .then(data => {\n            data.push(output);\n            mkdirp.sync(path.dirname(mainfile));\n            var stream = source(mainfile);\n            stream.write(data.join('\\n'));\n            process.nextTick(() => {\n                stream.end();\n            });\n            return super.working(stream.pipe(vinylBuffer()), config, option, gulp);\n        });\n        // if (!existsSync(mainfile)) {\n        //     mkdirp.sync(path.dirname(mainfile));\n        //     writeFileSync(mainfile, output, { flag: 'wx' });\n        // } else {\n        //     writeFileSync(mainfile, output);\n        // }\n        // console.log(chalk.green('Manifest written'));\n        // return Promise.resolve(true);\n    }\n    getBundleManifestPath(option) {\n        var url = option.baseURL;\n        return path.join(url, option.mainfile);\n    }\n    getBundleManifest(option) {\n        let data = {};\n        let path = this.getBundleManifestPath(option);\n        if (fs_1.existsSync(path)) {\n            try {\n                let content = fs_1.readFileSync(path, 'utf8');\n                let idx = content.indexOf(this.manifestSplit);\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\n                content = content.substring(idx);\n                // console.log(content);\n                fs_1.writeFileSync(path, content);\n                data = require(path);\n                console.log('has old bundle：\\n', chalk.cyan(path)); // , 'data:\\n', data);\n            }\n            catch (e) {\n                console.log(chalk.red(e));\n            }\n        }\n        return data;\n    }\n    getBundleShortPath(config, bundleName, bundleOpts) {\n        var fullPath = this.getBundleDest(config, bundleName, bundleOpts);\n        let spath = path.relative(config.option.baseURL, fullPath);\n        spath = spath.replace(/\\\\/g, '/').replace(/^\\//g, '');\n        return spath;\n    }\n    getBundleDest(config, bundleName, bundleOpts) {\n        var url = path.join(config.option.baseURL, config.getDist());\n        var min = bundleOpts.builder.minify;\n        var name = bundleOpts.items[bundleName] || bundleName;\n        var file = name + ((min) ? '.min.js' : '.js');\n        if (bundleOpts.combine) {\n            url = path.join(url, bundleName, file);\n        }\n        else {\n            url = path.join(url, file);\n        }\n        return url;\n    }\n};\nJspmBundle = __decorate([\n    development_core_1.task({\n        oper: development_core_1.Operation.release | development_core_1.Operation.deploy\n    }), \n    __metadata('design:paramtypes', [Object])\n], JspmBundle);\nexports.JspmBundle = JspmBundle;\n","import * as _ from 'lodash';\r\nimport { task, ITaskConfig, RunWay, IAssertDist, Src, ITaskInfo, TransformSource, ITransform, Operation, PipeTask } from 'development-core';\r\nimport { Gulp } from 'gulp';\r\nimport * as path from 'path';\r\nimport { IJspmTaskConfig, IBundlesConfig, IBundleGroup } from './config';\r\n\r\nimport { readFileSync, readFile, existsSync, writeFileSync } from 'fs';\r\nimport * as chalk from 'chalk';\r\nconst jspm = require('jspm');\r\nconst source = require('vinyl-source-stream');\r\nconst vinylBuffer = require('vinyl-buffer');\r\nconst chksum = require('checksum');\r\nconst mkdirp = require('mkdirp');\r\n// const uglify = require('gulp-uglify');\r\n\r\nexport interface IBundleMap {\r\n    path: string;\r\n    modules: Src\r\n}\r\n\r\n@task({\r\n    oper: Operation.release | Operation.deploy\r\n})\r\nexport class JspmBundle extends PipeTask {\r\n\r\n    name = 'jspm-bundle';\r\n    runWay = RunWay.sequence;\r\n    private bundles: IBundleMap[];\r\n    constructor(info?: ITaskInfo) {\r\n        super(info);\r\n    }\r\n\r\n    protected getOption(config: ITaskConfig): IAssertDist {\r\n        return config.option;\r\n    }\r\n\r\n    protected loadBuilder(config: ITaskConfig): Promise<any> {\r\n\r\n        let option = <IBundlesConfig>config.option;\r\n        let jsbuilder = new jspm.Builder({ separateCSS: option.builder.separateCSS });\r\n\r\n        return Promise.resolve(jsbuilder)\r\n            .then(builder => {\r\n                if (option.jspmConfig) {\r\n                    return builder.loadConfig(option.jspmConfig, undefined, true)\r\n                        .then(() => {\r\n                            return builder;\r\n                        });\r\n                } else {\r\n                    return builder;\r\n                }\r\n            });\r\n    }\r\n\r\n    sourceStream(config: ITaskConfig, dist: IAssertDist, gulp?: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = <IBundlesConfig>config.option;\r\n        if (option.bundles) {\r\n            return Promise.all(_.map(this.getbundles(config), name => {\r\n                return this.loadBuilder(config)\r\n                    .then(builder => {\r\n                        let bundle: IBundleGroup = option.bundles[name];\r\n                        bundle.builder = _.defaults(bundle.builder, option.builder);\r\n                        return this.groupBundle(<IJspmTaskConfig>config, name, bundle, gulp);\r\n                    });\r\n            })).then(groups => {\r\n                return _.flatten(groups);\r\n            });\r\n        } else {\r\n            return this.loadBuilder(config)\r\n                .then(builder => {\r\n                    builder.config(option.builder.config)\r\n                    let sfx = option.builder.sfx;\r\n                    var bundler = (sfx) ? builder.buildStatic : builder.bundle;\r\n                    return bundler.bind(builder)(config.getSrc(), option.builder);\r\n                });\r\n        }\r\n    }\r\n\r\n\r\n    execute(config: ITaskConfig, gulp: Gulp) {\r\n        this.bundles = [];\r\n        return super.execute(config, gulp)\r\n            .then(() => {\r\n                let option = <IBundlesConfig>config.option;\r\n                if (option.bundles) {\r\n                    if (option.bust) {\r\n                        return this.calcChecksums(option, this.bundles).then((checksums) => {\r\n                            return this.updateBundleManifest(option, this.bundles, checksums);;\r\n                        });\r\n                    } else {\r\n                        return this.updateBundleManifest(option, this.bundles);\r\n                    }\r\n                } else {\r\n                    return null;\r\n                }\r\n            }).then(manifest => {\r\n                if (manifest) {\r\n                    return this.writeBundleManifest(<IJspmTaskConfig>config, manifest, gulp)\r\n                        .then(() => {\r\n                            console.log(chalk.green('------ Complete -------------'));\r\n                        });\r\n                } else {\r\n                    console.log(chalk.green('------ Complete -------------'));\r\n                    return null;\r\n                }\r\n            });\r\n    }\r\n\r\n    protected working(source: ITransform, config: ITaskConfig, option: IAssertDist, gulp: Gulp) {\r\n        let bundle = source['bundle'];\r\n        if (bundle.sfx) {\r\n            console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n        } else {\r\n            console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n        }\r\n        return super.working(source, config, option, gulp)\r\n            .then(() => {\r\n                let bundlemap: IBundleMap = {\r\n                    path: bundle.shortPath,\r\n                    modules: bundle.modules\r\n                };\r\n                this.bundles.push(bundlemap);\r\n                return bundlemap;\r\n            });\r\n    }\r\n\r\n    getbundles(config: ITaskConfig) {\r\n        let option = <IBundlesConfig>config.option;\r\n        let groups = _.uniq(_.isArray(config.env.gb) ? config.env.gb : (config.env.gb || '').split(','));\r\n        if (groups.length < 1) {\r\n            groups = _.keys(option.bundles);\r\n        } else {\r\n            groups = _.filter(groups, f => f && groups[f]);\r\n        }\r\n\r\n        return groups;\r\n    }\r\n\r\n    protected groupBundle(config: IJspmTaskConfig, name: string, bundleOpts: IBundleGroup, gulp: Gulp): Promise<any> {\r\n\r\n        let option: IBundlesConfig = config.option;\r\n\r\n        let bundleStr = '';\r\n        let bundleDest = '';\r\n\r\n        let bundleItems: string[] = [];\r\n        let minusStr = this.exclusionString(bundleOpts.exclude, option.bundles);\r\n\r\n        if (bundleOpts.items) {\r\n            bundleItems = _.isArray(bundleItems) ? <string[]>bundleOpts.items : _.keys(bundleOpts.items);\r\n        }\r\n\r\n        console.log(`-------------------------------\\nBundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(<any>bundleItems)}\\n-------------------------------`);\r\n\r\n\r\n        let jsbuilder = new jspm.Builder({ separateCSS: bundleOpts.builder.separateCSS });\r\n\r\n        return Promise.resolve(jsbuilder)\r\n            .then(builder => {\r\n                if (option.jspmConfig) {\r\n                    return builder.loadConfig(option.jspmConfig, undefined, true)\r\n                        .then(() => {\r\n                            return builder;\r\n                        });\r\n                } else {\r\n                    return builder;\r\n                }\r\n            })\r\n            .then(builder => {\r\n                builder.config(bundleOpts.builder.config);\r\n\r\n                if (bundleOpts.combine) {\r\n                    bundleDest = this.getBundleDest(config, name, bundleOpts);\r\n                    bundleStr = bundleItems.join(' + ') + minusStr;\r\n                    return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleOpts, gulp);\r\n\r\n                } else {\r\n                    return Promise.all(bundleItems.map(key => {\r\n                        bundleStr = key + minusStr;\r\n                        bundleDest = this.getBundleDest(config, key, bundleOpts);\r\n                        return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleOpts, gulp);\r\n                    }));\r\n                }\r\n\r\n            });\r\n    }\r\n\r\n    private exclusionString(exclude, groups): string {\r\n        var str = this.exclusionArray(exclude, groups).join(' - ');\r\n        return (str) ? ' - ' + str : '';\r\n    }\r\n\r\n    private exclusionArray(exclude, groups): string[] {\r\n        var minus: string[] = [];\r\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\r\n        _.forEach(exclude, (item: string) => {\r\n            var group = groups[item];\r\n            if (group) {\r\n                // exclude everything from this group\r\n                minus = minus.concat(this.exclusionArray(group.items, groups));\r\n            } else {\r\n                // exclude this item by name\r\n                minus.push(item);\r\n            }\r\n        });\r\n        return minus;\r\n    }\r\n\r\n    private createBundler(config: IJspmTaskConfig, builder: any, bundleName: string, bundleStr: string, bundleDest: string, bundleOpts: IBundleGroup, gulp: Gulp): Promise<any> {\r\n\r\n        let sfx = bundleOpts.builder.sfx;\r\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\r\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleOpts);\r\n        let filename = path.parse(bundleDest).base;\r\n\r\n        let buildConfig;\r\n        if (bundleOpts.toES5) {\r\n            buildConfig = _.clone(bundleOpts.builder);\r\n            buildConfig.minify = false;\r\n            buildConfig.sourceMaps = false;\r\n        } else {\r\n            buildConfig = bundleOpts.builder;\r\n        }\r\n\r\n        return bundler.bind(builder)(bundleStr, bundleDest, buildConfig)\r\n            .then(output => {\r\n                mkdirp.sync(path.dirname(bundleDest));\r\n                var stream: ITransform = source(filename);\r\n                stream.write(output.source);\r\n                process.nextTick(function () {\r\n                    stream.end();\r\n                });\r\n\r\n                return stream.pipe(vinylBuffer());\r\n            })\r\n            .then(output => {\r\n                output['bundle'] = {\r\n                    path: shortPath,\r\n                    bundleName: bundleName,\r\n                    filename: filename,\r\n                    bundleDest: bundleDest,\r\n                    modules: output.modules\r\n                };\r\n                return output;\r\n            });\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    private calcChecksums(option: IBundlesConfig, bundles: any[]): Promise<any> {\r\n        let chksums = {};\r\n\r\n        console.log('Calculating checksums...');\r\n\r\n        return Promise.all(_.map(bundles, (bundle: any) => {\r\n            if (!_.isObject(bundle)) {\r\n                return null;\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                let filepath = path.join(option.baseURL, bundle.path);\r\n                let filename = path.parse(bundle.path).base;\r\n                chksum.file(filepath, (err, sum) => {\r\n                    if (err) {\r\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\r\n                    }\r\n                    console.log(filename, chalk.cyan(sum));\r\n                    chksums[bundle.path] = sum;\r\n                    resolve(chksums);\r\n                });\r\n            });\r\n\r\n        })).then(() => {\r\n            return chksums;\r\n        });\r\n    }\r\n\r\n    protected updateBundleManifest(option: IBundlesConfig, bundles: any[], chksums?: any) {\r\n\r\n        chksums = chksums || {};\r\n\r\n        var manifest: any = _.defaults(this.getBundleManifest(option), {\r\n            bundles: {},\r\n            chksums: {}\r\n        });\r\n\r\n        // console.log(manifest);\r\n\r\n        _.each(bundles, bundle => {\r\n            if (bundle.path) {\r\n                manifest.bundles[bundle.path] = bundle.modules;\r\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\r\n            }\r\n        });\r\n\r\n        return manifest;\r\n\r\n    }\r\n\r\n    private manifestSplit = `/*------bundles infos------*/`;\r\n    private writeBundleManifest(config: IJspmTaskConfig, manifest, gulp: Gulp): Promise<any> {\r\n        let option = config.option;\r\n        if (!option.mainfile) {\r\n            return Promise.reject('mainfile not configed.');\r\n        }\r\n\r\n\r\n        console.log('Writing manifest...');\r\n\r\n\r\n        let output = `System.config({\r\n            baseURL: '${option.rootUri || '.'}',\r\n            defaultJSExtensions: true\r\n        });\r\n        System.bundled = true;\r\n        System.bust = '${option.bust}';\r\n        if(window != undefined) window.prod = true;\r\n        ${this.manifestSplit}\r\n        `;\r\n        let template = '';\r\n\r\n        if (manifest) {\r\n            // try {\r\n            template = option.systemConfigTempl;\r\n\r\n            if (!template) {\r\n                template = (option.bust) ?\r\n                    `\r\n                    (function(module) {\r\n                    var bust = {};\r\n                    var systemLocate = System.locate;\r\n                    var systemNormalize = System.normalize;\r\n\r\n                    var chksums = module.exports.chksums = \\${chksums};\r\n                    var bundles = module.exports.bundles = \\${bundles};                    \r\n                    var maps = \\${ maps };\r\n                    var jspmMeta = \\${ jspmMeta };\r\n\r\n                    System.config({\r\n                         packages: {\r\n                            \"meta\": jspmMeta\r\n                        },\r\n                        map: maps,\r\n                        //paths: paths,\r\n                        bundles: bundles\r\n                    });\r\n\r\n                    System.normalize = function (name, pName, pAddress) {\r\n                        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n                            var chksum = chksums[name];\r\n                            if (chksums[name]) { bust[address] = chksum; }\r\n                            return address;\r\n                        });\r\n                    };\r\n\r\n                    System.locate = function (load) {\r\n                        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n                            var chksum = bust[address];\r\n                            return (chksum) ? address + '?' + chksum : address;\r\n                        });\r\n                    };\r\n\r\n                })((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n                `\r\n                    :\r\n                    `\r\n                    (function(module) {\r\n                    var bundles = module.exports.bundles = \\${bundles};\r\n                    var paths =  module.exports.paths = \\${paths};\r\n                    var maps = \\${ maps };\r\n                    var jspmMeta = \\${ jspmMeta };\r\n\r\n                    System.config({\r\n                         packages: {\r\n                            \"meta\": jspmMeta\r\n                        },\r\n                        map: maps,\r\n                        //paths: paths,\r\n                        bundles: bundles\r\n                    });\r\n\r\n                })((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n                `;\r\n            }\r\n\r\n            // } catch (e) {\r\n\r\n            //     console.log(' X Unable to open manifest template');\r\n            //     console.log(e);\r\n            //     return Promise.reject(<any>false);\r\n\r\n            // }\r\n\r\n\r\n            let maps = {\r\n                css: 'github:systemjs/plugin-css@0.1.20.js',\r\n                json: 'github:systemjs/plugin-json@0.1.2.js'\r\n            };\r\n\r\n            _.each(_.keys(manifest.bundles), n => {\r\n                if (/css.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n                if (/json.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n            });\r\n\r\n            let jspmMetas = option.jspmMetas;\r\n            output += _.template(template)({\r\n                maps: JSON.stringify(maps, null, '    '),\r\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\r\n                // paths: JSON.stringify(this.options.builder.config.paths, null, '    '),\r\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\r\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\r\n            });\r\n\r\n        }\r\n\r\n        let mainfile = this.getBundleManifestPath(option);\r\n\r\n\r\n        let includes = option.includes || [\r\n            './system-polyfills.src.js',\r\n            './system.src.js'\r\n        ]\r\n        return Promise.all(_.map(includes, f => {\r\n            return new Promise<string>((resolve, reject) => {\r\n                readFile(path.join(option.jspmConfig, f), 'utf8', (err, data) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    } else {\r\n                        resolve(data);\r\n                    }\r\n                });\r\n            });\r\n        }))\r\n            .then(data => {\r\n                data.push(output);\r\n                mkdirp.sync(path.dirname(mainfile));\r\n                var stream = <NodeJS.ReadWriteStream>source(mainfile);\r\n                stream.write(data.join('\\n'));\r\n                process.nextTick(() => {\r\n                    stream.end();\r\n                });\r\n\r\n                return super.working(stream.pipe(vinylBuffer()), config, option, gulp);\r\n            });\r\n\r\n        // if (!existsSync(mainfile)) {\r\n        //     mkdirp.sync(path.dirname(mainfile));\r\n\r\n        //     writeFileSync(mainfile, output, { flag: 'wx' });\r\n        // } else {\r\n        //     writeFileSync(mainfile, output);\r\n        // }\r\n\r\n        // console.log(chalk.green('Manifest written'));\r\n\r\n        // return Promise.resolve(true);\r\n\r\n    }\r\n\r\n    private getBundleManifestPath(option: IBundlesConfig): string {\r\n        var url = option.baseURL;\r\n        return path.join(url, option.mainfile);\r\n    }\r\n    private getBundleManifest(option: IBundlesConfig): any {\r\n        let data: any = {};\r\n        let path: string = this.getBundleManifestPath(option);\r\n        if (existsSync(path)) {\r\n            try {\r\n                let content = readFileSync(path, 'utf8');\r\n                let idx = content.indexOf(this.manifestSplit);\r\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\r\n                content = content.substring(idx);\r\n                // console.log(content);\r\n                writeFileSync(path, content);\r\n                data = require(path);\r\n                console.log('has old bundle：\\n', chalk.cyan(path)); // , 'data:\\n', data);\r\n            } catch (e) {\r\n                console.log(chalk.red(e));\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    private getBundleShortPath(config: IJspmTaskConfig, bundleName: string, bundleOpts: IBundleGroup) {\r\n        var fullPath = this.getBundleDest(config, bundleName, bundleOpts);\r\n        let spath: string = path.relative(config.option.baseURL, fullPath);\r\n        spath = spath.replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n        return spath;\r\n    }\r\n\r\n    private getBundleDest(config: IJspmTaskConfig, bundleName: string, bundleOpts: IBundleGroup) {\r\n\r\n        var url = path.join(config.option.baseURL, config.getDist());\r\n        var min = bundleOpts.builder.minify;\r\n        var name = bundleOpts.items[bundleName] || bundleName;\r\n        var file = name + ((min) ? '.min.js' : '.js');\r\n\r\n        if (bundleOpts.combine) {\r\n            url = path.join(url, bundleName, file);\r\n        } else {\r\n            url = path.join(url, file);\r\n        }\r\n\r\n        return url;\r\n    }\r\n}\r\n"]}