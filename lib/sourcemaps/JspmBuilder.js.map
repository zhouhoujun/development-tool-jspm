{"version":3,"sources":["JspmBuilder.js","JspmBuilder.ts"],"names":["_","require","path","gulp","fs_1","chalk","jspm","source","vinylBuffer","uglify","chksum","mkdirp","JspmBuilder","options","_classCallCheck","this","manifestSplit","extend","dest","file","systemConfigTempl","relationToRoot","bust","bundles","jspmMates","*.css","loader","*.json","*.jsx","builder","sfx","minify","mangle","sourceMaps","separateCSS","lowResSourceMaps","root","dirname","module","parent","filename","isAbsolute","baseURL","join","console","log","cyan","name","src","bundlesConfig","Builder","config","bundler","buildStatic","bundle","Promise","resolve","reject","bind","then","output","stream","write","process","nextTick","end","pipe","on","groups","_this","isEmpty","Error","bundlegs","isArray","isString","indexOf","split","length","keys","thenable","allBundles","each","groupBundle","concat","push","calcChecksums","checksums","updateBundleManifest","green","catch","err","error","red","warn","yellow","writeBundleManifest","unbundles","shortPath","forEach","groupName","bundleOpts","getBundleOpts","combine","getBundleShortPath","items","item","removeFromBundleManifest","_this2","bundleStr","bundleDest","bundleItems","minusStr","exclusionString","exclude","jsbuilder","jspmConfig","loadConfig","undefined","getBundleDest","createBundler","all","map","key","str","exclusionArray","_this3","minus","group","bundleName","parse","base","buildConfig","toES5","clone","sync","writeFileSync","modules","_this4","chksums","isObject","filepath","sum","manifest","defaults","getBundleManifest","_this5","baseUri","template","maps","css","json","n","test","first","jspmMetas","JSON","stringify","jspmMeta","mainfile","getBundleManifestPath","existsSync","flag","url","String","data","content","readFileSync","idx","substring","e","fullPath","spath","relative","replace","min","exports"],"mappings":"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","file":"../JspmBuilder.js","sourcesContent":["\"use strict\";\nconst _ = require('lodash');\nconst path = require('path');\nconst gulp = require('gulp');\nconst fs_1 = require('fs');\nconst chalk = require('chalk');\n// const babel = require('gulp-babel');\nconst jspm = require('jspm');\nconst source = require('vinyl-source-stream');\nconst vinylBuffer = require('vinyl-buffer');\n// const ngAnnotate = require('gulp-ng-annotate');\n// const sourcemaps = require('gulp-sourcemaps');\nconst uglify = require('gulp-uglify');\nconst chksum = require('checksum');\nconst mkdirp = require('mkdirp');\n/**\n * jspm builder.\n *\n * @export\n * @class JspmBuilder\n */\nclass JspmBuilder {\n    constructor(options) {\n        this.options = options;\n        this.manifestSplit = `/*------bundles infos------*/`;\n        this.options = _.extend({\n            dest: '',\n            file: '',\n            systemConfigTempl: '',\n            relationToRoot: '',\n            bust: '',\n            bundles: {},\n            jspmMates: {\n                '*.css': {\n                    loader: 'css'\n                },\n                '*.json': {\n                    loader: 'json'\n                },\n                '*.jsx': {\n                    loader: 'jsx'\n                }\n            },\n            // babelOption: {\n            //     presets: ['es2015']\n            // }\n            builder: {\n                sfx: false,\n                minify: false,\n                mangle: false,\n                sourceMaps: false,\n                separateCSS: false,\n                lowResSourceMaps: true\n            }\n        }, this.options);\n        // console.log(this.options.bundles);\n        let root = (path.dirname(module.parent.filename) + '/');\n        this.options.root = this.options.root || root;\n        if (!path.isAbsolute(this.options.baseURL)) {\n            this.options.baseURL = path.join(this.options.root, this.options.baseURL, '/') || root;\n        }\n        console.log('bundles config:', chalk.cyan(this.options));\n    }\n    bundleAll(name, src, dest, bundlesConfig) {\n        bundlesConfig = bundlesConfig || this.options;\n        let builder = new jspm.Builder({ separateCSS: bundlesConfig.builder.separateCSS });\n        builder.config(bundlesConfig.builder.config);\n        let sfx = bundlesConfig.builder.sfx;\n        var bundler = (sfx) ? builder.buildStatic : builder.bundle;\n        return new Promise((resolve, reject) => {\n            bundler.bind(builder)(src, bundlesConfig.builder)\n                .then(function (output) {\n                var stream = source(name);\n                stream.write(output.source);\n                process.nextTick(function () {\n                    stream.end();\n                });\n                return stream.pipe(vinylBuffer())\n                    .pipe(uglify())\n                    .pipe(gulp.dest(dest))\n                    .on('end', resolve)\n                    .on('error', reject);\n            }, reject);\n        });\n    }\n    /**\n     * Create bundles using the bundle configuration. If no bundles are\n     * specified, all groups will be bundles.\n     *\n     * Example:\n     * bundler.bundle(['app', 'routes']);\n     *\n     * @param {Array} groups\n     * @returns {Promise}\n     */\n    bundle(groups) {\n        if (_.isEmpty(this.options.bundles)) {\n            throw new Error('Cant bundle until bundles are defined');\n        }\n        let bundlegs = [];\n        if (groups) {\n            if ((_.isArray(groups))) {\n                bundlegs = groups;\n            }\n            else if (_.isString(groups)) {\n                bundlegs = groups.indexOf(',') > 0 ? groups.split(',') : [groups];\n            }\n        }\n        if (bundlegs.length < 1) {\n            bundlegs = _.keys(this.options.bundles);\n        }\n        console.log(`bundles: ${bundlegs}`);\n        let thenable = Promise.resolve(this.options);\n        let allBundles = [];\n        _.each(bundlegs, name => {\n            thenable = thenable.then(() => {\n                return this.groupBundle(name)\n                    .then((bundles) => {\n                    if (_.isArray(bundles)) {\n                        allBundles = allBundles.concat(bundles);\n                    }\n                    else {\n                        allBundles.push(bundles);\n                    }\n                    return allBundles;\n                });\n            });\n        });\n        return thenable.then((bundles) => {\n            if (this.options.bust) {\n                return this.calcChecksums(bundles).then((checksums) => {\n                    return this.updateBundleManifest(bundles, checksums).then(function () {\n                        console.log(chalk.green('------ Complete -------------'));\n                    });\n                });\n            }\n            else {\n                return this.updateBundleManifest(bundles).then(function () {\n                    console.log(chalk.green('------ Complete -------------'));\n                });\n            }\n        })\n            .catch(err => {\n            console.error(chalk.red(err));\n        });\n    }\n    unbundle(groups) {\n        console.log('------ Unbundling -----------');\n        if (!groups) {\n            console.warn(chalk.yellow('Removing all bundles...'));\n            return this.writeBundleManifest(null);\n        }\n        let bundlegs;\n        if ((_.isArray(groups))) {\n            bundlegs = groups;\n        }\n        else if (_.isString(groups)) {\n            bundlegs = groups.indexOf(',') > 0 ? groups.split(',') : [groups];\n        }\n        var unbundles = [];\n        var shortPath = '';\n        _.forEach(bundlegs, function (groupName) {\n            var bundleOpts = this.getBundleOpts(groupName);\n            if (bundleOpts.combine) {\n                shortPath = this.getBundleShortPath(groupName, bundleOpts);\n                unbundles.push({ path: shortPath });\n                console.log('Success removed:', chalk.cyan(shortPath));\n            }\n            else {\n                _.forEach(bundleOpts.items, function (item) {\n                    shortPath = this.getBundleShortPath(item, bundleOpts);\n                    unbundles.push({ path: shortPath });\n                    console.log('Success removed:', chalk.cyan(shortPath));\n                });\n            }\n        });\n        return this.removeFromBundleManifest(unbundles);\n    }\n    groupBundle(name) {\n        let bundleOpts = this.getBundleOpts(name);\n        if (!bundleOpts) {\n            return Promise.reject(('Unable to find group: ' + name));\n        }\n        let bundleStr = '';\n        let bundleDest = '';\n        let bundleItems = [];\n        let minusStr = this.exclusionString(bundleOpts.exclude, this.options.bundles);\n        if (bundleOpts.items) {\n            bundleItems = _.isArray(bundleItems) ? bundleOpts.items : _.keys(bundleOpts.items);\n        }\n        console.log(`-------------------------------\\nBundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(bundleItems)}\\n-------------------------------`);\n        let jsbuilder = new jspm.Builder({ separateCSS: bundleOpts.builder.separateCSS });\n        return Promise.resolve(jsbuilder)\n            .then(builder => {\n            if (this.options.jspmConfig) {\n                return builder.loadConfig(this.options.jspmConfig, undefined, true)\n                    .then(() => {\n                    return builder;\n                });\n            }\n            else {\n                return builder;\n            }\n        })\n            .then(builder => {\n            builder.config(bundleOpts.builder.config);\n            if (bundleOpts.combine) {\n                bundleDest = this.getBundleDest(name, bundleOpts);\n                bundleStr = bundleItems.join(' + ') + minusStr;\n                return this.createBundler(builder, name, bundleStr, bundleDest, bundleOpts);\n            }\n            else {\n                return Promise.all(bundleItems.map(key => {\n                    bundleStr = key + minusStr;\n                    bundleDest = this.getBundleDest(key, bundleOpts);\n                    return this.createBundler(builder, key, bundleStr, bundleDest, bundleOpts);\n                }));\n            }\n        });\n    }\n    exclusionString(exclude, groups) {\n        var str = this.exclusionArray(exclude, groups).join(' - ');\n        return (str) ? ' - ' + str : '';\n    }\n    exclusionArray(exclude, groups) {\n        var minus = [];\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\n        _.forEach(exclude, (item) => {\n            var group = groups[item];\n            if (group) {\n                // exclude everything from this group\n                minus = minus.concat(this.exclusionArray(group.items, groups));\n            }\n            else {\n                // exclude this item by name\n                minus.push(item);\n            }\n        });\n        return minus;\n    }\n    createBundler(builder, bundleName, bundleStr, bundleDest, bundleOpts) {\n        let sfx = bundleOpts.builder.sfx;\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\n        let shortPath = this.getBundleShortPath(bundleName, bundleOpts);\n        let filename = path.parse(bundleDest).base;\n        let buildConfig;\n        if (bundleOpts.toES5) {\n            buildConfig = _.clone(bundleOpts.builder);\n            buildConfig.minify = false;\n            buildConfig.sourceMaps = false;\n        }\n        else {\n            buildConfig = bundleOpts.builder;\n        }\n        return bundler.bind(builder)(bundleStr, bundleDest, buildConfig)\n            .then(output => {\n            mkdirp.sync(path.dirname(bundleDest));\n            if (bundleOpts.toES5) {\n                return new Promise((resolve, reject) => {\n                    var stream = source(filename);\n                    stream.write(output.source);\n                    process.nextTick(function () {\n                        stream.end();\n                    });\n                    return stream.pipe(vinylBuffer())\n                        .pipe(uglify())\n                        .pipe(gulp.dest(path.dirname(bundleDest)))\n                        .on('end', () => {\n                        resolve(output);\n                    })\n                        .on('error', reject);\n                });\n            }\n            else {\n                fs_1.writeFileSync(bundleDest, output.source);\n                return output;\n            }\n        })\n            .then(output => {\n            if (sfx) {\n                console.log(`Built sfx package: ${chalk.cyan(bundleName)} -> ${chalk.cyan(filename)}\\n   dest: ${chalk.cyan(bundleDest)}`);\n            }\n            else {\n                console.log(`Bundled package: ${chalk.cyan(bundleName)} -> ${chalk.cyan(filename)}\\n   dest: ${chalk.cyan(bundleDest)}`);\n            }\n            return {\n                path: shortPath,\n                modules: output.modules\n            };\n        });\n    }\n    calcChecksums(bundles) {\n        let chksums = {};\n        console.log('Calculating checksums...');\n        return Promise.all(_.map(bundles, (bundle) => {\n            if (!_.isObject(bundle)) {\n                return null;\n            }\n            return new Promise((resolve, reject) => {\n                let filepath = path.join(this.options.baseURL, bundle.path);\n                let filename = path.parse(bundle.path).base;\n                chksum.file(filepath, (err, sum) => {\n                    if (err) {\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\n                    }\n                    console.log(filename, chalk.cyan(sum));\n                    chksums[bundle.path] = sum;\n                    resolve(chksums);\n                });\n            });\n        })).then(() => {\n            return chksums;\n        });\n    }\n    updateBundleManifest(bundles, chksums) {\n        chksums = chksums || {};\n        var manifest = _.defaults(this.getBundleManifest(), {\n            bundles: {},\n            chksums: {}\n        });\n        // console.log(manifest);\n        _.each(bundles, bundle => {\n            if (bundle.path) {\n                manifest.bundles[bundle.path] = bundle.modules;\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\n            }\n        });\n        return this.writeBundleManifest(manifest);\n    }\n    removeFromBundleManifest(bundles) {\n        var manifest = _.defaults(this.getBundleManifest(), {\n            bundles: {},\n            chksums: {}\n        });\n        _.forEach(bundles, function (bundle) {\n            delete manifest.bundles[bundle.path];\n            delete manifest.chksums[bundle.path];\n        });\n        return this.writeBundleManifest(manifest);\n    }\n    writeBundleManifest(manifest) {\n        if (!this.options.file) {\n            return Promise.resolve(true);\n        }\n        console.log('Writing manifest...');\n        let options = this.options;\n        let output = `System.config({\r\n            baseURL: '${options.baseUri || '.'}',\r\n            defaultJSExtensions: true\r\n        });\r\n        System.bundled = true;\r\n        System.bust = '${options.bust}';\r\n        if(window != undefined) window.prod = true;\r\n        ${this.manifestSplit}\r\n        `;\n        let template = '';\n        if (manifest) {\n            // try {\n            template = this.options.systemConfigTempl;\n            if (!template) {\n                template = (this.options.bust) ?\n                    `\r\n                    (function(module) {\r\n                    var bust = {};\r\n                    var systemLocate = System.locate;\r\n                    var systemNormalize = System.normalize;\r\n\r\n                    var chksums = module.exports.chksums = \\${chksums};\r\n                    var bundles = module.exports.bundles = \\${bundles};                    \r\n                    var maps = \\${ maps };\r\n                    var jspmMeta = \\${ jspmMeta };\r\n\r\n                    System.config({\r\n                         packages: {\r\n                            \"meta\": jspmMeta\r\n                        },\r\n                        map: maps,\r\n                        //paths: paths,\r\n                        bundles: bundles\r\n                    });\r\n\r\n                    System.normalize = function (name, pName, pAddress) {\r\n                        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n                            var chksum = chksums[name];\r\n                            if (chksums[name]) { bust[address] = chksum; }\r\n                            return address;\r\n                        });\r\n                    };\r\n\r\n                    System.locate = function (load) {\r\n                        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n                            var chksum = bust[address];\r\n                            return (chksum) ? address + '?' + chksum : address;\r\n                        });\r\n                    };\r\n\r\n                })((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n                `\n                    :\n                        `\r\n                    (function(module) {\r\n                    var bundles = module.exports.bundles = \\${bundles};\r\n                    var paths =  module.exports.paths = \\${paths};\r\n                    var maps = \\${ maps };\r\n                    var jspmMeta = \\${ jspmMeta };\r\n\r\n                    System.config({\r\n                         packages: {\r\n                            \"meta\": jspmMeta\r\n                        },\r\n                        map: maps,\r\n                        //paths: paths,\r\n                        bundles: bundles\r\n                    });\r\n\r\n                })((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n                `;\n            }\n            // } catch (e) {\n            //     console.log(' X Unable to open manifest template');\n            //     console.log(e);\n            //     return Promise.reject(<any>false);\n            // }\n            let maps = {\n                css: 'github:systemjs/plugin-css@0.1.20.js',\n                json: 'github:systemjs/plugin-json@0.1.2.js'\n            };\n            _.each(_.keys(manifest.bundles), n => {\n                if (/css.min.js$/.test(n)) {\n                    maps.css = _.first(manifest.bundles[n]);\n                }\n                if (/json.min.js$/.test(n)) {\n                    maps.css = _.first(manifest.bundles[n]);\n                }\n            });\n            let jspmMetas = this.options.jspmMetas;\n            output += _.template(template)({\n                maps: JSON.stringify(maps, null, '    '),\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\n                // paths: JSON.stringify(this.options.builder.config.paths, null, '    '),\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\n            });\n        }\n        let mainfile = this.getBundleManifestPath();\n        if (!fs_1.existsSync(mainfile)) {\n            mkdirp.sync(path.dirname(mainfile));\n            fs_1.writeFileSync(mainfile, output, { flag: 'wx' });\n        }\n        else {\n            fs_1.writeFileSync(mainfile, output);\n        }\n        console.log(chalk.green('Manifest written'));\n        return Promise.resolve(true);\n    }\n    getBundleManifestPath() {\n        var url = this.options.baseURL;\n        return String(path.join(url, this.options.file));\n    }\n    getBundleManifest() {\n        let data = {};\n        let path = this.getBundleManifestPath();\n        if (fs_1.existsSync(path)) {\n            try {\n                let content = fs_1.readFileSync(path, 'utf8');\n                let idx = content.indexOf(this.manifestSplit);\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\n                content = content.substring(idx);\n                // console.log(content);\n                fs_1.writeFileSync(path, content);\n                data = require(path);\n                console.log('has old bundle：\\n', chalk.cyan(path)); // , 'data:\\n', data);\n            }\n            catch (e) {\n                console.log(chalk.red(e));\n            }\n        }\n        return data;\n    }\n    getBundleOpts(name) {\n        let bundleOpts = this.options.bundles[name];\n        if (bundleOpts) {\n            bundleOpts.builder = _.defaults(bundleOpts.builder, this.options.builder);\n            return bundleOpts;\n        }\n        else {\n            return null;\n        }\n    }\n    getBundleShortPath(bundleName, bundleOpts) {\n        var fullPath = this.getBundleDest(bundleName, bundleOpts);\n        let spath = path.relative(this.options.baseURL, fullPath);\n        spath = spath.replace(/\\\\/g, '/').replace(/^\\//g, '');\n        return spath;\n    }\n    getBundleDest(bundleName, bundleOpts) {\n        var url = path.join(this.options.baseURL, this.options.dest);\n        var min = bundleOpts.builder.minify;\n        var name = bundleOpts.items[bundleName] || bundleName;\n        var file = name + ((min) ? '.min.js' : '.js');\n        if (bundleOpts.combine) {\n            url = path.join(url, bundleName, file);\n        }\n        else {\n            url = path.join(url, file);\n        }\n        return url;\n    }\n}\nexports.JspmBuilder = JspmBuilder;\n","import * as _ from 'lodash';\r\nimport * as path from 'path';\r\nimport * as gulp from 'gulp';\r\nimport { readFileSync, existsSync, writeFileSync } from 'fs';\r\nimport * as chalk from 'chalk';\r\n// const babel = require('gulp-babel');\r\nconst jspm = require('jspm');\r\nconst source = require('vinyl-source-stream');\r\nconst vinylBuffer = require('vinyl-buffer');\r\n// const ngAnnotate = require('gulp-ng-annotate');\r\n// const sourcemaps = require('gulp-sourcemaps');\r\nconst uglify = require('gulp-uglify');\r\nconst chksum = require('checksum');\r\nconst mkdirp = require('mkdirp');\r\n\r\nimport { IBundlesConfig, IBuidlerConfig, IBundleGroup, IBuilder } from './config';\r\n\r\n/**\r\n * jspm builder.\r\n * \r\n * @export\r\n * @class JspmBuilder\r\n */\r\nexport class JspmBuilder implements IBuilder {\r\n    constructor(private options: IBundlesConfig) {\r\n\r\n        this.options = _.extend(<IBundlesConfig>{\r\n            dest: '',\r\n            file: '',\r\n            systemConfigTempl: '',\r\n            relationToRoot: '',\r\n            bust: '',\r\n            bundles: {},\r\n            jspmMates: {\r\n                '*.css': {\r\n                    loader: 'css'\r\n                },\r\n                '*.json': {\r\n                    loader: 'json'\r\n                },\r\n                '*.jsx': {\r\n                    loader: 'jsx'\r\n                }\r\n            },\r\n            // babelOption: {\r\n            //     presets: ['es2015']\r\n            // }\r\n            builder: {\r\n                sfx: false,\r\n                minify: false,\r\n                mangle: false,\r\n                sourceMaps: false,\r\n                separateCSS: false,\r\n                lowResSourceMaps: true\r\n            }\r\n        }, this.options);\r\n\r\n        // console.log(this.options.bundles);\r\n        let root = (path.dirname(module.parent.filename) + '/');\r\n        this.options.root = this.options.root || root;\r\n\r\n        if (!path.isAbsolute(this.options.baseURL)) {\r\n            this.options.baseURL = path.join(this.options.root, this.options.baseURL, '/') || root;\r\n        }\r\n\r\n        console.log('bundles config:', chalk.cyan(<any>this.options));\r\n    }\r\n\r\n    bundleAll(name: string, src: string | string[], dest: string, bundlesConfig?: IBundlesConfig): Promise<any> {\r\n        bundlesConfig = bundlesConfig || this.options;\r\n\r\n        let builder = new jspm.Builder({ separateCSS: bundlesConfig.builder.separateCSS });\r\n\r\n        builder.config(bundlesConfig.builder.config);\r\n\r\n        let sfx = bundlesConfig.builder.sfx;\r\n        var bundler = (sfx) ? builder.buildStatic : builder.bundle;\r\n\r\n        return new Promise<any>((resolve, reject) => {\r\n            bundler.bind(builder)(src, bundlesConfig.builder)\r\n                .then(function (output) {\r\n                    var stream = source(name);\r\n\r\n                    stream.write(output.source);\r\n                    process.nextTick(function () {\r\n                        stream.end();\r\n                    });\r\n\r\n                    return stream.pipe(vinylBuffer())\r\n                        // .pipe(sourcemaps.init())\r\n                        // .pipe(babel(bundlesConfig.bundleOption))\r\n                        // .pipe(ngAnnotate({\r\n                        //     sourceMap: true,\r\n                        //     gulpWarnings: false\r\n                        // }))\r\n                        .pipe(uglify())\r\n                        // .pipe(rename({ suffix: '.min' }))\r\n                        // .pipe(sourcemaps.write())\r\n                        .pipe(gulp.dest(dest))\r\n                        .on('end', resolve)\r\n                        .on('error', reject);\r\n                }, reject);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Create bundles using the bundle configuration. If no bundles are\r\n     * specified, all groups will be bundles.\r\n     *\r\n     * Example:\r\n     * bundler.bundle(['app', 'routes']);\r\n     *\r\n     * @param {Array} groups\r\n     * @returns {Promise}\r\n     */\r\n    bundle(groups?: string | string[]): Promise<any> {\r\n\r\n\r\n        if (_.isEmpty(this.options.bundles)) {\r\n            throw new Error('Cant bundle until bundles are defined');\r\n        }\r\n\r\n        let bundlegs: string[] = [];\r\n\r\n        if (groups) {\r\n            if ((_.isArray(groups))) {\r\n                bundlegs = <string[]>groups;\r\n            } else if (_.isString(groups)) {\r\n                bundlegs = groups.indexOf(',') > 0 ? (<string>groups).split(',') : [<string>groups];\r\n            }\r\n        }\r\n\r\n        if (bundlegs.length < 1) {\r\n            bundlegs = _.keys(this.options.bundles);\r\n        }\r\n\r\n        console.log(`bundles: ${bundlegs}`);\r\n\r\n        let thenable: Promise<any> = Promise.resolve(this.options);\r\n\r\n        let allBundles = [];\r\n        _.each(bundlegs, name => {\r\n            thenable = thenable.then(() => {\r\n                return this.groupBundle(name)\r\n                    .then((bundles: any) => {\r\n                        if (_.isArray(bundles)) {\r\n                            allBundles = allBundles.concat(<any[]>bundles);\r\n                        } else {\r\n                            allBundles.push(bundles);\r\n                        }\r\n                        return allBundles;\r\n                    });\r\n            });\r\n        });\r\n\r\n        return thenable.then((bundles: any[]) => {\r\n            if (this.options.bust) {\r\n                return this.calcChecksums(bundles).then((checksums) => {\r\n                    return this.updateBundleManifest(bundles, checksums).then(function () {\r\n                        console.log(chalk.green('------ Complete -------------'));\r\n                    });\r\n                });\r\n            } else {\r\n                return this.updateBundleManifest(bundles).then(function () {\r\n                    console.log(chalk.green('------ Complete -------------'));\r\n                });\r\n            }\r\n        })\r\n            .catch(err => {\r\n                console.error(chalk.red(err));\r\n            });\r\n    }\r\n\r\n\r\n    unbundle(groups?: string | string[]): Promise<any> {\r\n\r\n        console.log('------ Unbundling -----------');\r\n\r\n        if (!groups) {\r\n            console.warn(chalk.yellow('Removing all bundles...'));\r\n            return this.writeBundleManifest(null);\r\n        }\r\n\r\n        let bundlegs: string[];\r\n\r\n        if ((_.isArray(groups))) {\r\n            bundlegs = <string[]>groups;\r\n        } else if (_.isString(groups)) {\r\n            bundlegs = groups.indexOf(',') > 0 ? (<string>groups).split(',') : [<string>groups];\r\n        }\r\n\r\n\r\n        var unbundles = [];\r\n        var shortPath = '';\r\n\r\n        _.forEach(bundlegs, function (groupName) {\r\n\r\n            var bundleOpts = this.getBundleOpts(groupName);\r\n\r\n            if (bundleOpts.combine) {\r\n\r\n                shortPath = this.getBundleShortPath(groupName, bundleOpts);\r\n                unbundles.push({ path: shortPath });\r\n                console.log('Success removed:', chalk.cyan(shortPath));\r\n\r\n            } else {\r\n\r\n                _.forEach(bundleOpts.items, function (item) {\r\n                    shortPath = this.getBundleShortPath(item, bundleOpts);\r\n                    unbundles.push({ path: shortPath });\r\n                    console.log('Success removed:', chalk.cyan(shortPath));\r\n                });\r\n\r\n            }\r\n\r\n        });\r\n\r\n        return this.removeFromBundleManifest(unbundles);\r\n\r\n    }\r\n\r\n    groupBundle(name: string): Promise<any> {\r\n\r\n        let bundleOpts = this.getBundleOpts(name);\r\n        if (!bundleOpts) {\r\n            return Promise.reject(<any>('Unable to find group: ' + name));\r\n\r\n        }\r\n\r\n\r\n\r\n        let bundleStr = '';\r\n        let bundleDest = '';\r\n\r\n        let bundleItems: string[] = [];\r\n        let minusStr = this.exclusionString(bundleOpts.exclude, this.options.bundles);\r\n\r\n        if (bundleOpts.items) {\r\n            bundleItems = _.isArray(bundleItems) ? <string[]>bundleOpts.items : _.keys(bundleOpts.items);\r\n        }\r\n\r\n        console.log(`-------------------------------\\nBundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(<any>bundleItems)}\\n-------------------------------`);\r\n\r\n\r\n        let jsbuilder = new jspm.Builder({ separateCSS: bundleOpts.builder.separateCSS });\r\n\r\n        return Promise.resolve(jsbuilder)\r\n            .then(builder => {\r\n                if (this.options.jspmConfig) {\r\n                    return builder.loadConfig(this.options.jspmConfig, undefined, true)\r\n                        .then(() => {\r\n                            return builder;\r\n                        });\r\n                } else {\r\n                    return builder;\r\n                }\r\n            })\r\n            .then(builder => {\r\n                builder.config(bundleOpts.builder.config);\r\n\r\n                if (bundleOpts.combine) {\r\n                    bundleDest = this.getBundleDest(name, bundleOpts);\r\n                    bundleStr = bundleItems.join(' + ') + minusStr;\r\n                    return this.createBundler(builder, name, bundleStr, bundleDest, bundleOpts);\r\n\r\n                } else {\r\n                    return Promise.all(bundleItems.map(key => {\r\n                        bundleStr = key + minusStr;\r\n                        bundleDest = this.getBundleDest(key, bundleOpts);\r\n                        return this.createBundler(builder, key, bundleStr, bundleDest, bundleOpts);\r\n                    }));\r\n                }\r\n\r\n            });\r\n    }\r\n\r\n    private exclusionString(exclude, groups): string {\r\n        var str = this.exclusionArray(exclude, groups).join(' - ');\r\n        return (str) ? ' - ' + str : '';\r\n    }\r\n\r\n    private exclusionArray(exclude, groups): string[] {\r\n        var minus: string[] = [];\r\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\r\n        _.forEach(exclude, (item: string) => {\r\n            var group = groups[item];\r\n            if (group) {\r\n                // exclude everything from this group\r\n                minus = minus.concat(this.exclusionArray(group.items, groups));\r\n            } else {\r\n                // exclude this item by name\r\n                minus.push(item);\r\n            }\r\n        });\r\n        return minus;\r\n    }\r\n\r\n    private createBundler(builder: any, bundleName: string, bundleStr: string, bundleDest: string, bundleOpts: IBundleGroup): Promise<any> {\r\n\r\n        let sfx = bundleOpts.builder.sfx;\r\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\r\n        let shortPath = this.getBundleShortPath(bundleName, bundleOpts);\r\n        let filename = path.parse(bundleDest).base;\r\n\r\n        let buildConfig;\r\n        if (bundleOpts.toES5) {\r\n            buildConfig = _.clone(bundleOpts.builder);\r\n            buildConfig.minify = false;\r\n            buildConfig.sourceMaps = false;\r\n        } else {\r\n            buildConfig = bundleOpts.builder;\r\n        }\r\n\r\n        return bundler.bind(builder)(bundleStr, bundleDest, buildConfig)\r\n            .then(output => {\r\n\r\n                mkdirp.sync(path.dirname(bundleDest));\r\n\r\n                if (bundleOpts.toES5) {\r\n                    return new Promise<any>((resolve, reject) => {\r\n                        var stream = source(filename);\r\n\r\n                        stream.write(output.source);\r\n                        process.nextTick(function () {\r\n                            stream.end();\r\n                        });\r\n\r\n                        return stream.pipe(vinylBuffer())\r\n                            // .pipe(sourcemaps.init())\r\n                            // .pipe(ngAnnotate())\r\n                            .pipe(uglify())\r\n                            // .pipe(rename({ suffix: '.min' }))\r\n                            // .pipe(sourcemaps.write('.'))\r\n                            .pipe(gulp.dest(path.dirname(bundleDest)))\r\n                            .on('end', () => {\r\n                                resolve(output);\r\n                            })\r\n                            .on('error', reject);\r\n                    });\r\n\r\n                } else {\r\n\r\n                    writeFileSync(bundleDest, output.source);\r\n                    return output;\r\n                }\r\n            })\r\n            .then(output => {\r\n                if (sfx) {\r\n                    console.log(`Built sfx package: ${chalk.cyan(bundleName)} -> ${chalk.cyan(filename)}\\n   dest: ${chalk.cyan(bundleDest)}`);\r\n                } else {\r\n                    console.log(`Bundled package: ${chalk.cyan(bundleName)} -> ${chalk.cyan(filename)}\\n   dest: ${chalk.cyan(bundleDest)}`);\r\n                }\r\n                return {\r\n                    path: shortPath,\r\n                    modules: output.modules\r\n                };\r\n            });\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    private calcChecksums(bundles: any[]): Promise<any> {\r\n\r\n        let chksums = {};\r\n\r\n        console.log('Calculating checksums...');\r\n\r\n        return Promise.all(_.map(bundles, (bundle: any) => {\r\n            if (!_.isObject(bundle)) {\r\n                return null;\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                let filepath = path.join(this.options.baseURL, bundle.path);\r\n                let filename = path.parse(bundle.path).base;\r\n                chksum.file(filepath, (err, sum) => {\r\n                    if (err) {\r\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\r\n                    }\r\n                    console.log(filename, chalk.cyan(sum));\r\n                    chksums[bundle.path] = sum;\r\n                    resolve(chksums);\r\n                });\r\n            });\r\n\r\n        })).then(() => {\r\n            return chksums;\r\n        });\r\n    }\r\n\r\n    protected updateBundleManifest(bundles: any[], chksums?: any) {\r\n\r\n        chksums = chksums || {};\r\n\r\n        var manifest: any = _.defaults(this.getBundleManifest(), {\r\n            bundles: {},\r\n            chksums: {}\r\n        });\r\n\r\n        // console.log(manifest);\r\n\r\n        _.each(bundles, bundle => {\r\n            if (bundle.path) {\r\n                manifest.bundles[bundle.path] = bundle.modules;\r\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\r\n            }\r\n        });\r\n\r\n        return this.writeBundleManifest(manifest);\r\n\r\n    }\r\n\r\n    protected removeFromBundleManifest(bundles): Promise<any> {\r\n\r\n        var manifest: any = _.defaults(this.getBundleManifest(), {\r\n            bundles: {},\r\n            chksums: {}\r\n        });\r\n\r\n        _.forEach(bundles, function (bundle) {\r\n            delete manifest.bundles[bundle.path];\r\n            delete manifest.chksums[bundle.path];\r\n        });\r\n\r\n        return this.writeBundleManifest(manifest);\r\n\r\n    }\r\n\r\n    private manifestSplit = `/*------bundles infos------*/`;\r\n    private writeBundleManifest(manifest): Promise<any> {\r\n        if (!this.options.file) {\r\n            return Promise.resolve(true);\r\n        }\r\n\r\n\r\n        console.log('Writing manifest...');\r\n\r\n        let options = this.options;\r\n\r\n        let output = `System.config({\r\n            baseURL: '${options.baseUri || '.'}',\r\n            defaultJSExtensions: true\r\n        });\r\n        System.bundled = true;\r\n        System.bust = '${options.bust}';\r\n        if(window != undefined) window.prod = true;\r\n        ${this.manifestSplit}\r\n        `;\r\n        let template = '';\r\n\r\n        if (manifest) {\r\n            // try {\r\n            template = this.options.systemConfigTempl;\r\n\r\n            if (!template) {\r\n                template = (this.options.bust) ?\r\n                    `\r\n                    (function(module) {\r\n                    var bust = {};\r\n                    var systemLocate = System.locate;\r\n                    var systemNormalize = System.normalize;\r\n\r\n                    var chksums = module.exports.chksums = \\${chksums};\r\n                    var bundles = module.exports.bundles = \\${bundles};                    \r\n                    var maps = \\${ maps };\r\n                    var jspmMeta = \\${ jspmMeta };\r\n\r\n                    System.config({\r\n                         packages: {\r\n                            \"meta\": jspmMeta\r\n                        },\r\n                        map: maps,\r\n                        //paths: paths,\r\n                        bundles: bundles\r\n                    });\r\n\r\n                    System.normalize = function (name, pName, pAddress) {\r\n                        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n                            var chksum = chksums[name];\r\n                            if (chksums[name]) { bust[address] = chksum; }\r\n                            return address;\r\n                        });\r\n                    };\r\n\r\n                    System.locate = function (load) {\r\n                        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n                            var chksum = bust[address];\r\n                            return (chksum) ? address + '?' + chksum : address;\r\n                        });\r\n                    };\r\n\r\n                })((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n                `\r\n                    :\r\n                    `\r\n                    (function(module) {\r\n                    var bundles = module.exports.bundles = \\${bundles};\r\n                    var paths =  module.exports.paths = \\${paths};\r\n                    var maps = \\${ maps };\r\n                    var jspmMeta = \\${ jspmMeta };\r\n\r\n                    System.config({\r\n                         packages: {\r\n                            \"meta\": jspmMeta\r\n                        },\r\n                        map: maps,\r\n                        //paths: paths,\r\n                        bundles: bundles\r\n                    });\r\n\r\n                })((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n                `;\r\n            }\r\n\r\n            // } catch (e) {\r\n\r\n            //     console.log(' X Unable to open manifest template');\r\n            //     console.log(e);\r\n            //     return Promise.reject(<any>false);\r\n\r\n            // }\r\n\r\n\r\n            let maps = {\r\n                css: 'github:systemjs/plugin-css@0.1.20.js',\r\n                json: 'github:systemjs/plugin-json@0.1.2.js'\r\n            };\r\n\r\n            _.each(_.keys(manifest.bundles), n => {\r\n                if (/css.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n                if (/json.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n            });\r\n\r\n            let jspmMetas = this.options.jspmMetas;\r\n            output += _.template(template)({\r\n                maps: JSON.stringify(maps, null, '    '),\r\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\r\n                // paths: JSON.stringify(this.options.builder.config.paths, null, '    '),\r\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\r\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\r\n            });\r\n\r\n        }\r\n\r\n        let mainfile = this.getBundleManifestPath();\r\n        if (!existsSync(mainfile)) {\r\n            mkdirp.sync(path.dirname(mainfile));\r\n\r\n            writeFileSync(mainfile, output, { flag: 'wx' });\r\n        } else {\r\n            writeFileSync(mainfile, output);\r\n        }\r\n\r\n        console.log(chalk.green('Manifest written'));\r\n\r\n        return Promise.resolve(true);\r\n\r\n    }\r\n\r\n    private getBundleManifestPath(): string {\r\n        var url = this.options.baseURL;\r\n        return String(path.join(url, this.options.file));\r\n    }\r\n    private getBundleManifest(): any {\r\n        let data: any = {};\r\n        let path: string = this.getBundleManifestPath();\r\n        if (existsSync(path)) {\r\n            try {\r\n                let content = readFileSync(path, 'utf8');\r\n                let idx = content.indexOf(this.manifestSplit);\r\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\r\n                content = content.substring(idx);\r\n                // console.log(content);\r\n                writeFileSync(path, content);\r\n                data = require(path);\r\n                console.log('has old bundle：\\n', chalk.cyan(path)); // , 'data:\\n', data);\r\n            } catch (e) {\r\n                console.log(chalk.red(e));\r\n            }\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    private getBundleOpts(name: string): IBundleGroup {\r\n        let bundleOpts = this.options.bundles[name];\r\n        if (bundleOpts) {\r\n            bundleOpts.builder = <IBuidlerConfig>_.defaults(bundleOpts.builder, this.options.builder);\r\n            return bundleOpts;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    private getBundleShortPath(bundleName: string, bundleOpts: IBundleGroup) {\r\n        var fullPath = this.getBundleDest(bundleName, bundleOpts);\r\n        let spath: string = path.relative(this.options.baseURL, fullPath);\r\n        spath = spath.replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n        return spath;\r\n    }\r\n\r\n    private getBundleDest(bundleName: string, bundleOpts: IBundleGroup) {\r\n\r\n        var url = path.join(this.options.baseURL, this.options.dest);\r\n        var min = bundleOpts.builder.minify;\r\n        var name = bundleOpts.items[bundleName] || bundleName;\r\n        var file = name + ((min) ? '.min.js' : '.js');\r\n\r\n        if (bundleOpts.combine) {\r\n            url = path.join(url, bundleName, file);\r\n        } else {\r\n            url = path.join(url, file);\r\n        }\r\n\r\n        return url;\r\n    }\r\n}\r\n"]}