{"version":3,"sources":["JspmBuilder.ts"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAIA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA","file":"../JspmBuilder.js","sourcesContent":["// import * as _ from 'lodash';\r\n// import * as path from 'path';\r\n// import * as gulp from 'gulp';\r\n// import { readFileSync, existsSync, writeFileSync } from 'fs';\r\n// import * as chalk from 'chalk';\r\n// // const babel = require('gulp-babel');\r\n// const jspm = require('jspm');\r\n// const source = require('vinyl-source-stream');\r\n// const vinylBuffer = require('vinyl-buffer');\r\n// // const ngAnnotate = require('gulp-ng-annotate');\r\n// // const sourcemaps = require('gulp-sourcemaps');\r\n// const uglify = require('gulp-uglify');\r\n// const chksum = require('checksum');\r\n// const mkdirp = require('mkdirp');\r\n\r\n// import { bindingConfig } from 'development-core';\r\n// import { IJspmTaskConfig, IBundlesConfig, IBuidlerConfig, IBundleGroup, IBuilder } from './config';\r\n\r\n// /**\r\n//  * jspm builder.\r\n//  * \r\n//  * @export\r\n//  * @class JspmBuilder\r\n//  */\r\n// export class JspmBuilder implements IBuilder {\r\n//     constructor(private config: IJspmTaskConfig) {\r\n//         this.init();\r\n//     }\r\n\r\n//     private init() {\r\n\r\n//         if (!this.config.getDist) {\r\n//             this.config = <IJspmTaskConfig>bindingConfig(this.config);\r\n//         }\r\n//         let option = _.extend(<IBundlesConfig>{\r\n//             baseURL: '',\r\n//             jspmConfig: 'jspm.conf.js',\r\n//             dest: '',\r\n//             file: '',\r\n//             systemConfigTempl: '',\r\n//             relationToRoot: '',\r\n//             bust: '',\r\n//             bundles: {},\r\n//             jspmMates: {\r\n//                 '*.css': {\r\n//                     loader: 'css'\r\n//                 },\r\n//                 '*.json': {\r\n//                     loader: 'json'\r\n//                 },\r\n//                 '*.jsx': {\r\n//                     loader: 'jsx'\r\n//                 }\r\n//             },\r\n//             builder: {\r\n//                 sfx: false,\r\n//                 minify: false,\r\n//                 mangle: false,\r\n//                 sourceMaps: false,\r\n//                 separateCSS: false,\r\n//                 lowResSourceMaps: true\r\n//             }\r\n//         }, this.config.option);\r\n\r\n//         // console.log(this.options.bundles);\r\n//         this.config.env.root = this.config.env.root || (path.dirname(module.parent.filename) + '/');\r\n\r\n//         if (!path.isAbsolute(option.baseURL)) {\r\n//             option.baseURL = path.join(this.config.env.root, option.baseURL, '/');\r\n//         }\r\n\r\n//         if (!path.isAbsolute(option.jspmConfig)) {\r\n//             option.jspmConfig = path.join(this.config.env.root, option.jspmConfig);\r\n//         }\r\n\r\n//         if (_.isFunction(option.bundles)) {\r\n//             option.bundles = option.bundles(this.config);\r\n//         }\r\n\r\n//         this.config.option = option;\r\n//         console.log('bundles config:', chalk.cyan(<any>this.config));\r\n//     }\r\n\r\n//     bundleAll(name: string, src: string | string[], dest: string, bundlesConfig?: IBundlesConfig): Promise<any> {\r\n//         bundlesConfig = bundlesConfig || this.config.option;\r\n\r\n//         let builder = new jspm.Builder({ separateCSS: bundlesConfig.builder.separateCSS });\r\n\r\n//         builder.config(bundlesConfig.builder.config);\r\n\r\n//         let sfx = bundlesConfig.builder.sfx;\r\n//         var bundler = (sfx) ? builder.buildStatic : builder.bundle;\r\n\r\n//         return new Promise<any>((resolve, reject) => {\r\n//             bundler.bind(builder)(src, bundlesConfig.builder)\r\n//                 .then(function (output) {\r\n//                     var stream = source(name);\r\n\r\n//                     stream.write(output.source);\r\n//                     process.nextTick(function () {\r\n//                         stream.end();\r\n//                     });\r\n\r\n//                     return stream.pipe(vinylBuffer())\r\n//                         // .pipe(sourcemaps.init())\r\n//                         // .pipe(babel(bundlesConfig.bundleOption))\r\n//                         // .pipe(ngAnnotate({\r\n//                         //     sourceMap: true,\r\n//                         //     gulpWarnings: false\r\n//                         // }))\r\n//                         .pipe(uglify())\r\n//                         // .pipe(rename({ suffix: '.min' }))\r\n//                         // .pipe(sourcemaps.write())\r\n//                         .pipe(gulp.dest(dest))\r\n//                         .on('end', resolve)\r\n//                         .on('error', reject);\r\n//                 }, reject);\r\n//         });\r\n//     }\r\n\r\n//     /**\r\n//      * Create bundles using the bundle configuration. If no bundles are\r\n//      * specified, all groups will be bundles.\r\n//      *\r\n//      * Example:\r\n//      * bundler.bundle(['app', 'routes']);\r\n//      *\r\n//      * @param {Array} groups\r\n//      * @returns {Promise}\r\n//      */\r\n//     bundle(groups?: string | string[]): Promise<any> {\r\n\r\n//         let option = this.config.option;\r\n\r\n//         if (_.isEmpty(option.bundles)) {\r\n//             throw new Error('Cant bundle until bundles are defined');\r\n//         }\r\n\r\n//         let bundlegs: string[] = [];\r\n\r\n//         if (groups) {\r\n//             if ((_.isArray(groups))) {\r\n//                 bundlegs = <string[]>groups;\r\n//             } else if (_.isString(groups)) {\r\n//                 bundlegs = groups.indexOf(',') > 0 ? (<string>groups).split(',') : [<string>groups];\r\n//             }\r\n//         }\r\n\r\n//         if (bundlegs.length < 1) {\r\n//             bundlegs = _.keys(option.bundles);\r\n//         }\r\n\r\n//         console.log(`bundles: ${bundlegs}`);\r\n\r\n//         let thenable: Promise<any> = Promise.resolve(this.config);\r\n\r\n//         let allBundles = [];\r\n//         _.each(bundlegs, name => {\r\n//             thenable = thenable.then(() => {\r\n//                 return this.groupBundle(name)\r\n//                     .then((bundles: any) => {\r\n//                         if (_.isArray(bundles)) {\r\n//                             allBundles = allBundles.concat(<any[]>bundles);\r\n//                         } else {\r\n//                             allBundles.push(bundles);\r\n//                         }\r\n//                         return allBundles;\r\n//                     });\r\n//             });\r\n//         });\r\n\r\n//         return thenable.then((bundles: any[]) => {\r\n//             if (option.bust) {\r\n//                 return this.calcChecksums(bundles).then((checksums) => {\r\n//                     return this.updateBundleManifest(bundles, checksums).then(function () {\r\n//                         console.log(chalk.green('------ Complete -------------'));\r\n//                     });\r\n//                 });\r\n//             } else {\r\n//                 return this.updateBundleManifest(bundles).then(function () {\r\n//                     console.log(chalk.green('------ Complete -------------'));\r\n//                 });\r\n//             }\r\n//         })\r\n//             .catch(err => {\r\n//                 console.error(chalk.red(err));\r\n//             });\r\n//     }\r\n\r\n\r\n//     unbundle(groups?: string | string[]): Promise<any> {\r\n\r\n//         console.log('------ Unbundling -----------');\r\n\r\n//         if (!groups) {\r\n//             console.warn(chalk.yellow('Removing all bundles...'));\r\n//             return this.writeBundleManifest(null);\r\n//         }\r\n\r\n//         let bundlegs: string[];\r\n\r\n//         if ((_.isArray(groups))) {\r\n//             bundlegs = <string[]>groups;\r\n//         } else if (_.isString(groups)) {\r\n//             bundlegs = groups.indexOf(',') > 0 ? (<string>groups).split(',') : [<string>groups];\r\n//         }\r\n\r\n\r\n//         var unbundles = [];\r\n//         var shortPath = '';\r\n\r\n//         _.forEach(bundlegs, function (groupName) {\r\n\r\n//             var bundleOpts = this.getBundleOpts(groupName);\r\n\r\n//             if (bundleOpts.combine) {\r\n\r\n//                 shortPath = this.getBundleShortPath(groupName, bundleOpts);\r\n//                 unbundles.push({ path: shortPath });\r\n//                 console.log('Success removed:', chalk.cyan(shortPath));\r\n\r\n//             } else {\r\n\r\n//                 _.forEach(bundleOpts.items, function (item) {\r\n//                     shortPath = this.getBundleShortPath(item, bundleOpts);\r\n//                     unbundles.push({ path: shortPath });\r\n//                     console.log('Success removed:', chalk.cyan(shortPath));\r\n//                 });\r\n\r\n//             }\r\n\r\n//         });\r\n\r\n//         return this.removeFromBundleManifest(unbundles);\r\n\r\n//     }\r\n\r\n//     protected groupBundle(name: string): Promise<any> {\r\n//         let option = this.config.option;\r\n\r\n//         let bundleOpts = this.getBundleOpts(name);\r\n//         if (!bundleOpts) {\r\n//             return Promise.reject(<any>('Unable to find group: ' + name));\r\n\r\n//         }\r\n\r\n\r\n\r\n//         let bundleStr = '';\r\n//         let bundleDest = '';\r\n\r\n//         let bundleItems: string[] = [];\r\n//         let minusStr = this.exclusionString(bundleOpts.exclude, option.bundles);\r\n\r\n//         if (bundleOpts.items) {\r\n//             bundleItems = _.isArray(bundleItems) ? <string[]>bundleOpts.items : _.keys(bundleOpts.items);\r\n//         }\r\n\r\n//         console.log(`-------------------------------\\nBundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(<any>bundleItems)}\\n-------------------------------`);\r\n\r\n\r\n//         let jsbuilder = new jspm.Builder({ separateCSS: bundleOpts.builder.separateCSS });\r\n\r\n//         return Promise.resolve(jsbuilder)\r\n//             .then(builder => {\r\n//                 if (option.jspmConfig) {\r\n//                     return builder.loadConfig(option.jspmConfig, undefined, true)\r\n//                         .then(() => {\r\n//                             return builder;\r\n//                         });\r\n//                 } else {\r\n//                     return builder;\r\n//                 }\r\n//             })\r\n//             .then(builder => {\r\n//                 builder.config(bundleOpts.builder.config);\r\n\r\n//                 if (bundleOpts.combine) {\r\n//                     bundleDest = this.getBundleDest(name, bundleOpts);\r\n//                     bundleStr = bundleItems.join(' + ') + minusStr;\r\n//                     return this.createBundler(builder, name, bundleStr, bundleDest, bundleOpts);\r\n\r\n//                 } else {\r\n//                     return Promise.all(bundleItems.map(key => {\r\n//                         bundleStr = key + minusStr;\r\n//                         bundleDest = this.getBundleDest(key, bundleOpts);\r\n//                         return this.createBundler(builder, key, bundleStr, bundleDest, bundleOpts);\r\n//                     }));\r\n//                 }\r\n\r\n//             });\r\n//     }\r\n\r\n//     private exclusionString(exclude, groups): string {\r\n//         var str = this.exclusionArray(exclude, groups).join(' - ');\r\n//         return (str) ? ' - ' + str : '';\r\n//     }\r\n\r\n//     private exclusionArray(exclude, groups): string[] {\r\n//         var minus: string[] = [];\r\n//         exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\r\n//         _.forEach(exclude, (item: string) => {\r\n//             var group = groups[item];\r\n//             if (group) {\r\n//                 // exclude everything from this group\r\n//                 minus = minus.concat(this.exclusionArray(group.items, groups));\r\n//             } else {\r\n//                 // exclude this item by name\r\n//                 minus.push(item);\r\n//             }\r\n//         });\r\n//         return minus;\r\n//     }\r\n\r\n//     private createBundler(builder: any, bundleName: string, bundleStr: string, bundleDest: string, bundleOpts: IBundleGroup): Promise<any> {\r\n\r\n//         let sfx = bundleOpts.builder.sfx;\r\n//         let bundler = (sfx) ? builder.buildStatic : builder.bundle;\r\n//         let shortPath = this.getBundleShortPath(bundleName, bundleOpts);\r\n//         let filename = path.parse(bundleDest).base;\r\n\r\n//         let buildConfig;\r\n//         if (bundleOpts.toES5) {\r\n//             buildConfig = _.clone(bundleOpts.builder);\r\n//             buildConfig.minify = false;\r\n//             buildConfig.sourceMaps = false;\r\n//         } else {\r\n//             buildConfig = bundleOpts.builder;\r\n//         }\r\n\r\n//         return bundler.bind(builder)(bundleStr, bundleDest, buildConfig)\r\n//             .then(output => {\r\n\r\n//                 mkdirp.sync(path.dirname(bundleDest));\r\n\r\n//                 if (bundleOpts.toES5) {\r\n//                     return new Promise<any>((resolve, reject) => {\r\n//                         var stream = source(filename);\r\n\r\n//                         stream.write(output.source);\r\n//                         process.nextTick(function () {\r\n//                             stream.end();\r\n//                         });\r\n\r\n//                         return stream.pipe(vinylBuffer())\r\n//                             // .pipe(sourcemaps.init())\r\n//                             // .pipe(ngAnnotate())\r\n//                             .pipe(uglify())\r\n//                             // .pipe(rename({ suffix: '.min' }))\r\n//                             // .pipe(sourcemaps.write('.'))\r\n//                             .pipe(gulp.dest(path.dirname(bundleDest)))\r\n//                             .on('end', () => {\r\n//                                 resolve(output);\r\n//                             })\r\n//                             .on('error', reject);\r\n//                     });\r\n\r\n//                 } else {\r\n\r\n//                     writeFileSync(bundleDest, output.source);\r\n//                     return output;\r\n//                 }\r\n//             })\r\n//             .then(output => {\r\n//                 if (sfx) {\r\n//                     console.log(`Built sfx package: ${chalk.cyan(bundleName)} -> ${chalk.cyan(filename)}\\n   dest: ${chalk.cyan(bundleDest)}`);\r\n//                 } else {\r\n//                     console.log(`Bundled package: ${chalk.cyan(bundleName)} -> ${chalk.cyan(filename)}\\n   dest: ${chalk.cyan(bundleDest)}`);\r\n//                 }\r\n//                 return {\r\n//                     path: shortPath,\r\n//                     modules: output.modules\r\n//                 };\r\n//             });\r\n\r\n\r\n//     }\r\n\r\n\r\n\r\n//     private calcChecksums(bundles: any[]): Promise<any> {\r\n//         let chksums = {};\r\n\r\n//         console.log('Calculating checksums...');\r\n\r\n//         return Promise.all(_.map(bundles, (bundle: any) => {\r\n//             if (!_.isObject(bundle)) {\r\n//                 return null;\r\n//             }\r\n\r\n//             return new Promise((resolve, reject) => {\r\n//                 let filepath = path.join(this.config.option.baseURL, bundle.path);\r\n//                 let filename = path.parse(bundle.path).base;\r\n//                 chksum.file(filepath, (err, sum) => {\r\n//                     if (err) {\r\n//                         console.error(chalk.red(' Checksum Error:'), chalk.red(err));\r\n//                     }\r\n//                     console.log(filename, chalk.cyan(sum));\r\n//                     chksums[bundle.path] = sum;\r\n//                     resolve(chksums);\r\n//                 });\r\n//             });\r\n\r\n//         })).then(() => {\r\n//             return chksums;\r\n//         });\r\n//     }\r\n\r\n//     protected updateBundleManifest(bundles: any[], chksums?: any) {\r\n\r\n//         chksums = chksums || {};\r\n\r\n//         var manifest: any = _.defaults(this.getBundleManifest(), {\r\n//             bundles: {},\r\n//             chksums: {}\r\n//         });\r\n\r\n//         // console.log(manifest);\r\n\r\n//         _.each(bundles, bundle => {\r\n//             if (bundle.path) {\r\n//                 manifest.bundles[bundle.path] = bundle.modules;\r\n//                 manifest.chksums[bundle.path] = chksums[bundle.path] || '';\r\n//             }\r\n//         });\r\n\r\n//         return this.writeBundleManifest(manifest);\r\n\r\n//     }\r\n\r\n//     protected removeFromBundleManifest(bundles): Promise<any> {\r\n\r\n//         var manifest: any = _.defaults(this.getBundleManifest(), {\r\n//             bundles: {},\r\n//             chksums: {}\r\n//         });\r\n\r\n//         _.forEach(bundles, function (bundle) {\r\n//             delete manifest.bundles[bundle.path];\r\n//             delete manifest.chksums[bundle.path];\r\n//         });\r\n\r\n//         return this.writeBundleManifest(manifest);\r\n\r\n//     }\r\n\r\n//     private manifestSplit = `/*------bundles infos------*/`;\r\n//     private writeBundleManifest(manifest): Promise<any> {\r\n\r\n//         let option = this.config.option;\r\n\r\n//         if (!option.file) {\r\n//             return Promise.resolve(true);\r\n//         }\r\n\r\n\r\n//         console.log('Writing manifest...');\r\n\r\n//         let options = option;\r\n\r\n//         let output = `System.config({\r\n//             baseURL: '${options.rootUri || '.'}',\r\n//             defaultJSExtensions: true\r\n//         });\r\n//         System.bundled = true;\r\n//         System.bust = '${options.bust}';\r\n//         if(window != undefined) window.prod = true;\r\n//         ${this.manifestSplit}\r\n//         `;\r\n//         let template = '';\r\n\r\n//         if (manifest) {\r\n//             // try {\r\n//             template = option.systemConfigTempl;\r\n\r\n//             if (!template) {\r\n//                 template = (option.bust) ?\r\n//                     `\r\n//                     (function(module) {\r\n//                     var bust = {};\r\n//                     var systemLocate = System.locate;\r\n//                     var systemNormalize = System.normalize;\r\n\r\n//                     var chksums = module.exports.chksums = \\${chksums};\r\n//                     var bundles = module.exports.bundles = \\${bundles};                    \r\n//                     var maps = \\${ maps };\r\n//                     var jspmMeta = \\${ jspmMeta };\r\n\r\n//                     System.config({\r\n//                          packages: {\r\n//                             \"meta\": jspmMeta\r\n//                         },\r\n//                         map: maps,\r\n//                         //paths: paths,\r\n//                         bundles: bundles\r\n//                     });\r\n\r\n//                     System.normalize = function (name, pName, pAddress) {\r\n//                         return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n//                             var chksum = chksums[name];\r\n//                             if (chksums[name]) { bust[address] = chksum; }\r\n//                             return address;\r\n//                         });\r\n//                     };\r\n\r\n//                     System.locate = function (load) {\r\n//                         return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n//                             var chksum = bust[address];\r\n//                             return (chksum) ? address + '?' + chksum : address;\r\n//                         });\r\n//                     };\r\n\r\n//                 })((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n//                 `\r\n//                     :\r\n//                     `\r\n//                     (function(module) {\r\n//                     var bundles = module.exports.bundles = \\${bundles};\r\n//                     var paths =  module.exports.paths = \\${paths};\r\n//                     var maps = \\${ maps };\r\n//                     var jspmMeta = \\${ jspmMeta };\r\n\r\n//                     System.config({\r\n//                          packages: {\r\n//                             \"meta\": jspmMeta\r\n//                         },\r\n//                         map: maps,\r\n//                         //paths: paths,\r\n//                         bundles: bundles\r\n//                     });\r\n\r\n//                 })((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n//                 `;\r\n//             }\r\n\r\n//             // } catch (e) {\r\n\r\n//             //     console.log(' X Unable to open manifest template');\r\n//             //     console.log(e);\r\n//             //     return Promise.reject(<any>false);\r\n\r\n//             // }\r\n\r\n\r\n//             let maps = {\r\n//                 css: 'github:systemjs/plugin-css@0.1.20.js',\r\n//                 json: 'github:systemjs/plugin-json@0.1.2.js'\r\n//             };\r\n\r\n//             _.each(_.keys(manifest.bundles), n => {\r\n//                 if (/css.min.js$/.test(n)) {\r\n//                     maps.css = <string>_.first(manifest.bundles[n]);\r\n//                 }\r\n//                 if (/json.min.js$/.test(n)) {\r\n//                     maps.css = <string>_.first(manifest.bundles[n]);\r\n//                 }\r\n//             });\r\n\r\n//             let jspmMetas = option.jspmMetas;\r\n//             output += _.template(template)({\r\n//                 maps: JSON.stringify(maps, null, '    '),\r\n//                 jspmMeta: JSON.stringify(jspmMetas, null, '    '),\r\n//                 // paths: JSON.stringify(this.options.builder.config.paths, null, '    '),\r\n//                 chksums: JSON.stringify(manifest.chksums, null, '    '),\r\n//                 bundles: JSON.stringify(manifest.bundles, null, '    '),\r\n//             });\r\n\r\n//         }\r\n\r\n//         let mainfile = this.getBundleManifestPath();\r\n//         if (!existsSync(mainfile)) {\r\n//             mkdirp.sync(path.dirname(mainfile));\r\n\r\n//             writeFileSync(mainfile, output, { flag: 'wx' });\r\n//         } else {\r\n//             writeFileSync(mainfile, output);\r\n//         }\r\n\r\n//         console.log(chalk.green('Manifest written'));\r\n\r\n//         return Promise.resolve(true);\r\n\r\n//     }\r\n\r\n//     private getBundleManifestPath(): string {\r\n//         var url = this.config.option.baseURL;\r\n//         return path.join(url, this.config.option.file);\r\n//     }\r\n//     private getBundleManifest(): any {\r\n//         let data: any = {};\r\n//         let path: string = this.getBundleManifestPath();\r\n//         if (existsSync(path)) {\r\n//             try {\r\n//                 let content = readFileSync(path, 'utf8');\r\n//                 let idx = content.indexOf(this.manifestSplit);\r\n//                 idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\r\n//                 content = content.substring(idx);\r\n//                 // console.log(content);\r\n//                 writeFileSync(path, content);\r\n//                 data = require(path);\r\n//                 console.log('has old bundleï¼š\\n', chalk.cyan(path)); // , 'data:\\n', data);\r\n//             } catch (e) {\r\n//                 console.log(chalk.red(e));\r\n//             }\r\n//         }\r\n\r\n//         return data;\r\n//     }\r\n\r\n//     private getBundleOpts(name: string): IBundleGroup {\r\n//         let bundleOpts = this.config.option.bundles[name];\r\n//         if (bundleOpts) {\r\n//             bundleOpts.builder = <IBuidlerConfig>_.defaults(bundleOpts.builder, this.config.option.builder);\r\n//             return bundleOpts;\r\n//         } else {\r\n//             return null;\r\n//         }\r\n//     }\r\n\r\n//     private getBundleShortPath(bundleName: string, bundleOpts: IBundleGroup) {\r\n//         var fullPath = this.getBundleDest(bundleName, bundleOpts);\r\n//         let spath: string = path.relative(this.config.option.baseURL, fullPath);\r\n//         spath = spath.replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n//         return spath;\r\n//     }\r\n\r\n//     private getBundleDest(bundleName: string, bundleOpts: IBundleGroup) {\r\n\r\n//         var url = path.join(this.config.option.baseURL, this.config.getDist());\r\n//         var min = bundleOpts.builder.minify;\r\n//         var name = bundleOpts.items[bundleName] || bundleName;\r\n//         var file = name + ((min) ? '.min.js' : '.js');\r\n\r\n//         if (bundleOpts.combine) {\r\n//             url = path.join(url, bundleName, file);\r\n//         } else {\r\n//             url = path.join(url, file);\r\n//         }\r\n\r\n//         return url;\r\n//     }\r\n// }\r\n"]}