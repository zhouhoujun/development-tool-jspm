{"version":3,"sources":["JspmBundle.js","JspmBundle.ts"],"names":["__decorate","decorators","target","key","desc","c","arguments","length","r","Object","getOwnPropertyDescriptor","d","Reflect","decorate","i","defineProperty","__metadata","k","v","metadata","_","require","development_core_1","path","fs_1","chalk","jspm","source","vinylBuffer","chksum","mkdirp","JspmBundle","info","name","runWay","RunWay","sequence","packages","manifestSplit","config","option","ctx","setPackagePath","dirname","packageFile","jsbuilder","Builder","separateCSS","builder","Promise","resolve","then","jspmConfig","loadConfig","undefined","trans","isArray","map","t","stream","bundle","opt","pr","isFunction","bundles","bundleDeps","pkg","getPackage","console","log","red","process","exit","deps","keys","dependencies","depsExclude","exclude","filter","indexOf","isBoolean","deplibs","combine","items","cores","each","values","b","concat","bundleConfig","dist","gulp","initBundles","all","getBundles","loadBuilder","defaults","groupBundle","translate","flatten","groups","src","getSrc","getInfo","cyan","fileFilter","files","getRelativeSrc","mainfile","getBundleManifestPath","createBundler","join","toModule","baseURL","filename","relative","s","replace","toModulePath","fn","substring","extname","extend","dest","file","systemConfigTempl","relationToRoot","bust","bundleFolder","includePackageFiles","jspmMates","loader","sfx","minify","mangle","sourceMaps","lowResSourceMaps","toRootPath","jspmPackages","directories","readdirSync","context","bundleMaps","calcChecksums","checksums","updateBundleManifest","manifest","writeBundleManifest","green","initOption","pipes","output","bundlemap","modules","push","bundleName","bundleDest","env","gb","uniq","split","f","bundleGp","bundleStr","bundleItems","minusStr","exclusionString","getBundleDest","str","exclusionArray","minus","forEach","item","group","builderCfg","bundler","buildStatic","shortPath","getBundleShortPath","parse","base","bind","sync","write","nextTick","end","pipe","chksums","isObject","reject","filepath","err","sum","error","getBundleManifest","root","template","maps","css","json","test","n","first","jspmMetas","JSON","stringify","jspmMeta","paths","includes","readFile","data","mainfilePipes","mainfileOutput","existsSync","content","readFileSync","idx","writeFileSync","e","fullPath","getDist","spath","min","PipeTask","task","oper","Operation","release","deploy","exports"],"mappings":"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","file":"../JspmBundle.js","sourcesContent":["\"use strict\";\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nconst _ = require('lodash');\nconst development_core_1 = require('development-core');\nconst path = require('path');\nconst fs_1 = require('fs');\nconst chalk = require('chalk');\n// const globby = require('globby');\nconst jspm = require('jspm');\nconst source = require('vinyl-source-stream');\nconst vinylBuffer = require('vinyl-buffer');\nconst chksum = require('checksum');\nconst mkdirp = require('mkdirp');\n// const uglify = require('gulp-uglify');\nlet JspmBundle = class JspmBundle extends development_core_1.PipeTask {\n    constructor(info) {\n        super(info);\n        this.name = 'jspm-bundle';\n        this.runWay = development_core_1.RunWay.sequence;\n        this.packages = {};\n        this.manifestSplit = `/*------bundles infos------*/`;\n    }\n    getOption(config) {\n        return config.option;\n    }\n    loadBuilder(ctx) {\n        let option = ctx.option;\n        jspm.setPackagePath(path.dirname(option.packageFile));\n        let jsbuilder = new jspm.Builder({ separateCSS: option.builder.separateCSS });\n        return Promise.resolve(jsbuilder)\n            .then(builder => {\n            if (option.jspmConfig) {\n                return builder.loadConfig(option.jspmConfig, undefined, true)\n                    .then(() => {\n                    return builder;\n                });\n            }\n            else {\n                return builder;\n            }\n        });\n    }\n    translate(trans) {\n        if (_.isArray(trans)) {\n            return _.map(trans, t => {\n                t.stream['bundle'] = t.bundle;\n                return t.stream;\n            });\n        }\n        else {\n            trans.stream['bundle'] = trans.bundle;\n            return trans.stream;\n        }\n    }\n    initBundles(ctx) {\n        let opt = ctx.option;\n        let pr = Promise.resolve(null)\n            .then(() => {\n            if (_.isFunction(opt.bundles)) {\n                // opt['_bundlesFunc'] = opt.bundles;\n                return opt.bundles(ctx);\n            }\n            else {\n                return opt.bundles;\n            }\n        });\n        if (opt.bundleDeps) {\n            pr = pr.then(bundles => {\n                let pkg = this.getPackage(opt);\n                if (!pkg) {\n                    console.log(chalk.red('can not found package.json file.'));\n                    process.exit(0);\n                }\n                if (!pkg.jspm) {\n                    console.log(chalk.red('jspm not init in package.json file.'));\n                    process.exit(0);\n                }\n                let deps = _.keys(pkg.jspm.dependencies);\n                if (opt.depsExclude) {\n                    let exclude = _.isFunction(opt.depsExclude) ? opt.depsExclude(ctx, deps) : opt.depsExclude;\n                    deps = _.filter(deps, d => exclude.indexOf(d) < 0);\n                }\n                return Promise.resolve()\n                    .then(() => {\n                    if (_.isFunction(opt.bundleDeps)) {\n                        // opt['_bundleDepsFunc'] = opt.bundleDeps;\n                        return opt.bundleDeps(ctx, deps);\n                    }\n                    else if (_.isBoolean(opt.bundleDeps)) {\n                        return {\n                            deplibs: {\n                                combine: true,\n                                items: deps\n                            }\n                        };\n                    }\n                    else {\n                        return opt.bundleDeps;\n                    }\n                })\n                    .then(bundleDeps => {\n                    let cores = _.keys(bundleDeps);\n                    _.each(_.values(bundles), (b) => {\n                        b.exclude = b.exclude || [];\n                        b.exclude = cores.concat(b.exclude);\n                    });\n                    return bundles;\n                });\n            });\n        }\n        return pr.then(bundles => {\n            this.bundleConfig = bundles;\n            return bundles;\n        });\n    }\n    source(ctx, dist, gulp) {\n        let option = ctx.option;\n        if (option.bundles) {\n            return this.initBundles(ctx)\n                .then(() => {\n                return Promise.all(_.map(this.getBundles(ctx), name => {\n                    return this.loadBuilder(ctx)\n                        .then(builder => {\n                        let bundle = this.bundleConfig[name];\n                        bundle.builder = _.defaults(bundle.builder, option.builder);\n                        if (option.builder.config) {\n                            builder.config(bundle.builder.config);\n                        }\n                        return this.groupBundle(ctx, builder, name, bundle, gulp)\n                            .then(trans => this.translate(trans));\n                    });\n                }));\n            }).then(groups => {\n                return _.flatten(groups);\n            });\n        }\n        else {\n            return this.loadBuilder(ctx)\n                .then(builder => {\n                let src = ctx.getSrc(this.getInfo());\n                console.log('start bundle all src : ', chalk.cyan(src));\n                if (option.builder.config) {\n                    builder.config(option.builder.config);\n                }\n                return Promise.resolve(ctx.fileFilter(src))\n                    .then(files => {\n                    files = this.getRelativeSrc(files, ctx);\n                    console.log('bundle files:', chalk.cyan(files));\n                    let mainfile = this.getBundleManifestPath(ctx);\n                    return this.createBundler(ctx, builder, 'bundle', files.join(' + '), mainfile, option.builder)\n                        .then(trans => this.translate(trans));\n                });\n            });\n        }\n    }\n    getRelativeSrc(src, config, toModule = false) {\n        // console.log(option.baseURL);\n        let baseURL = config.option.baseURL;\n        if (_.isArray(src)) {\n            return _.map(src, s => {\n                let filename = path.relative(baseURL, s).replace(/\\\\/g, '/').replace(/^\\//g, '');\n                return toModule ? this.toModulePath(filename) : filename;\n            });\n        }\n        else {\n            let fn = path.relative(baseURL, src).replace(/\\\\/g, '/').replace(/^\\//g, '');\n            return [(toModule ? this.toModulePath(fn) : fn)];\n        }\n    }\n    toModulePath(filename) {\n        if (!filename) {\n            return '';\n        }\n        return filename.substring(0, filename.length - path.extname(filename).length);\n    }\n    initOption(ctx) {\n        let option = _.extend({\n            baseURL: '',\n            mainfile: 'bundle.js',\n            jspmConfig: '',\n            packageFile: 'package.json',\n            dest: '',\n            file: '',\n            systemConfigTempl: '',\n            relationToRoot: '',\n            bust: '',\n            bundles: null,\n            bundleFolder: './',\n            includePackageFiles: [\n                'system-polyfills.src.js',\n                'system.src.js'\n            ],\n            jspmMates: {\n                '*.css': {\n                    loader: 'css'\n                },\n                '*.json': {\n                    loader: 'json'\n                },\n                '*.jsx': {\n                    loader: 'jsx'\n                }\n            },\n            builder: {\n                sfx: false,\n                minify: false,\n                mangle: false,\n                sourceMaps: false,\n                separateCSS: false,\n                lowResSourceMaps: true\n            }\n        }, ctx.option);\n        option.baseURL = ctx.toRootPath(option.baseURL);\n        if (option.jspmConfig) {\n            option.jspmConfig = ctx.toRootPath(option.jspmConfig);\n        }\n        option.packageFile = ctx.toRootPath(option.packageFile);\n        let pkg = this.getPackage(option);\n        if (!option.jspmPackages) {\n            if (pkg.jspm.directories && pkg.jspm.directories.packages) {\n                option.jspmPackages = pkg.jspm.directories.packages;\n            }\n            else {\n                option.jspmPackages = 'jspm_packages';\n            }\n        }\n        option.jspmPackages = ctx.toRootPath(option.jspmPackages);\n        if (!fs_1.readdirSync(option.jspmPackages)) {\n            console.log(chalk.red('jspm project config error!'));\n            process.exit(0);\n        }\n        return option;\n    }\n    execute(context, gulp) {\n        this.bundleMaps = [];\n        let ctx = context;\n        return super.execute(ctx, gulp)\n            .then(() => {\n            let option = ctx.option;\n            if (option.bundles) {\n                return this.calcChecksums(option, this.bundleMaps).then((checksums) => {\n                    return this.updateBundleManifest(ctx, this.bundleMaps, checksums);\n                });\n            }\n            else {\n                return null;\n            }\n        }).then(manifest => {\n            if (manifest) {\n                return this.writeBundleManifest(ctx, manifest, gulp)\n                    .then(() => {\n                    console.log(chalk.green('------ Complete -------------'));\n                });\n            }\n            else {\n                console.log(chalk.green('------ Complete -------------'));\n                return null;\n            }\n        });\n    }\n    setup(ctx, gulp) {\n        ctx.option = this.initOption(ctx);\n        return super.setup(ctx, gulp);\n    }\n    working(source, ctx, option, gulp, pipes, output) {\n        let bundle = source['bundle'];\n        return super.working(source, ctx, option, gulp, pipes, output)\n            .then(() => {\n            let bundlemap = {\n                path: bundle.path,\n                modules: bundle.modules\n            };\n            this.bundleMaps.push(bundlemap);\n            if (bundle.sfx) {\n                console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\n            }\n            else {\n                console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\n            }\n            return;\n        });\n    }\n    getBundles(ctx) {\n        let groups = [];\n        if (ctx.env.gb) {\n            groups = _.uniq(_.isArray(ctx.env.gb) ? ctx.env.gb : (ctx.env.gb || '').split(','));\n        }\n        if (groups.length < 1) {\n            groups = _.keys(this.bundleConfig);\n        }\n        else {\n            groups = _.filter(groups, f => f && groups[f]);\n        }\n        console.log('cmmand group bundle:', chalk.cyan(groups));\n        return groups;\n    }\n    groupBundle(config, builder, name, bundleGp, gulp) {\n        let bundleStr = '';\n        let bundleDest = '';\n        let bundleItems = [];\n        let minusStr = this.exclusionString(bundleGp.exclude, this.bundleConfig);\n        if (bundleGp.items) {\n            bundleItems = _.isArray(bundleItems) ? bundleGp.items : _.keys(bundleGp.items);\n        }\n        if (bundleGp.combine) {\n            bundleDest = this.getBundleDest(config, name, bundleGp);\n            bundleStr = bundleItems.join(' + ') + minusStr;\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup source:\\n  ${chalk.cyan(bundleStr)}\\n-------------------------------`);\n            return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleGp.builder, bundleGp);\n        }\n        else {\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(bundleItems)}\\n-------------------------------`);\n            return Promise.all(bundleItems.map(key => {\n                bundleStr = key + minusStr;\n                bundleDest = this.getBundleDest(config, key, bundleGp);\n                return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleGp.builder, bundleGp);\n            }));\n        }\n    }\n    exclusionString(exclude, groups) {\n        let str = this.exclusionArray(exclude, groups).join(' - ');\n        return (str) ? ' - ' + str : '';\n    }\n    exclusionArray(exclude, groups) {\n        let minus = [];\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\n        _.forEach(exclude, (item) => {\n            var group = groups[item];\n            if (group) {\n                // exclude everything from this group\n                minus = minus.concat(this.exclusionArray(group.items, groups));\n            }\n            else {\n                // exclude this item by name\n                minus.push(item);\n            }\n        });\n        return minus;\n    }\n    createBundler(config, builder, bundleName, bundleStr, bundleDest, builderCfg, bundleGp) {\n        let sfx = builderCfg.sfx;\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleGp);\n        let filename = path.parse(bundleDest).base;\n        return bundler.bind(builder)(bundleStr, bundleDest, builderCfg)\n            .then(output => {\n            mkdirp.sync(path.dirname(bundleDest));\n            var stream = source(filename);\n            stream.write(output.source);\n            process.nextTick(function () {\n                stream.end();\n            });\n            return {\n                stream: stream.pipe(vinylBuffer()),\n                bundle: {\n                    path: shortPath,\n                    sfx: sfx,\n                    bundleName: bundleName,\n                    filename: filename,\n                    bundleDest: bundleDest,\n                    modules: output.modules\n                }\n            };\n        });\n    }\n    getPackage(option) {\n        if (!this.packages[option.packageFile]) {\n            this.packages[option.packageFile] = require(option.packageFile);\n        }\n        return this.packages[option.packageFile];\n    }\n    calcChecksums(option, bundles) {\n        let chksums = {};\n        console.log('Calculating checksums...');\n        return Promise.all(_.map(bundles, (bundle) => {\n            if (!_.isObject(bundle)) {\n                return null;\n            }\n            return new Promise((resolve, reject) => {\n                let filepath = path.join(option.baseURL || '.', bundle.path);\n                let filename = path.parse(bundle.path).base;\n                chksum.file(filepath, (err, sum) => {\n                    if (err) {\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\n                    }\n                    console.log(filename, chalk.cyan(sum));\n                    chksums[bundle.path] = sum;\n                    resolve(chksums);\n                });\n            });\n        })).then(() => {\n            return chksums;\n        });\n    }\n    updateBundleManifest(ctx, bundles, chksums) {\n        chksums = chksums || {};\n        var manifest = _.defaults(this.getBundleManifest(ctx), {\n            bundles: {},\n            chksums: {}\n        });\n        // console.log(manifest);\n        _.each(bundles, bundle => {\n            if (bundle.path) {\n                manifest.bundles[bundle.path] = bundle.modules;\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\n            }\n        });\n        return manifest;\n    }\n    writeBundleManifest(ctx, manifest, gulp) {\n        let option = ctx.option;\n        if (!option.mainfile) {\n            return Promise.reject('mainfile not configed.');\n        }\n        console.log('Writing manifest...');\n        let output = `\r\nSystem.config({\r\n    baseURL: '${path.relative(option.baseURL, ctx.env.root) || '.'}',\r\n    defaultJSExtensions: true\r\n});\r\nSystem.bundled = true;\r\nSystem.bust = '${option.bust}';\r\nif(window != undefined) window.prod = true;\r\n${this.manifestSplit}\r\n`;\n        let template = '';\n        if (manifest) {\n            // try {\n            template = option.systemConfigTempl;\n            if (!template) {\n                template = (option.bust) ? `\r\n(function(module) {\r\n    var bust = {};\r\n    var systemLocate = System.locate;\r\n    var systemNormalize = System.normalize;\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var chksums = module.exports.chksums = \\${chksums};\r\n    var bundles = module.exports.bundles = \\${bundles};                    \r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n    System.normalize = function (name, pName, pAddress) {\r\n        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n            var chksum = chksums[name];\r\n            if (chksums[name]) { bust[address] = chksum; }\r\n            return address;\r\n        });\r\n    };\r\n\r\n    System.locate = function (load) {\r\n        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n            var chksum = bust[address];\r\n            return (chksum) ? address + '?' + chksum : address;\r\n        });\r\n    };\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n` : `\r\n(function(module) {\r\n    var bundles = module.exports.bundles = \\${bundles};\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n`;\n            }\n            let maps = {\n                css: 'github:systemjs/plugin-css@0.1.20.js',\n                json: 'github:systemjs/plugin-json@0.1.2.js'\n            };\n            _.each(_.keys(manifest.bundles), n => {\n                if (/css.min.js$/.test(n)) {\n                    maps.css = _.first(manifest.bundles[n]);\n                }\n                if (/json.min.js$/.test(n)) {\n                    maps.css = _.first(manifest.bundles[n]);\n                }\n            });\n            let jspmMetas = option.jspmMates;\n            output += _.template(template)({\n                maps: JSON.stringify(maps, null, '    '),\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\n                paths: JSON.stringify(ctx.option.builder.config ? ctx.option.builder.config.paths : null, null, '    '),\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\n            });\n        }\n        let includes = option.includes || [];\n        includes = includes.concat(_.map(option.includePackageFiles, f => path.join(option.jspmPackages, f)));\n        return Promise.all(_.map(includes, f => {\n            return new Promise((resolve, reject) => {\n                fs_1.readFile(path.join(option.jspmConfig, f), 'utf8', (err, data) => {\n                    if (err) {\n                        reject(err);\n                    }\n                    else {\n                        resolve(data);\n                    }\n                });\n            });\n        }))\n            .then(data => {\n            data.push(output);\n            let mainfile = option.mainfile; // path.relative(this.getBundleManifestPath(ctx), ctx.getDist(this.getInfo()));\n            console.log('mainfile:', mainfile);\n            mkdirp.sync(path.dirname(mainfile));\n            var stream = source(mainfile);\n            stream.write(data.join('\\n'));\n            process.nextTick(() => {\n                stream.end();\n            });\n            return super.working(stream.pipe(vinylBuffer()), ctx, option, gulp, option.mainfilePipes || [], option.mainfileOutput);\n        });\n    }\n    getBundleManifestPath(ctx) {\n        return this.getBundleDest(ctx, ctx.option.mainfile);\n    }\n    getBundleManifest(ctx) {\n        let data = {};\n        let mainfile = this.getBundleManifestPath(ctx);\n        console.log('try to load old bundle in path ', mainfile);\n        if (fs_1.existsSync(mainfile)) {\n            try {\n                let content = fs_1.readFileSync(mainfile, 'utf8');\n                let idx = content.indexOf(this.manifestSplit);\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\n                content = content.substring(idx);\n                // console.log(content);\n                fs_1.writeFileSync(mainfile, content);\n                data = require(mainfile);\n                console.log('has old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\n            }\n            catch (e) {\n                console.log(chalk.red(e));\n            }\n        }\n        else {\n            console.log('no old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\n        }\n        return data;\n    }\n    getBundleShortPath(config, bundleName, bundleGp) {\n        var fullPath = bundleGp ? this.getBundleDest(config, bundleName, bundleGp)\n            : path.join(config.getDist(), bundleName);\n        let spath = path.relative(config.option.baseURL, fullPath);\n        spath = spath.replace(/\\\\/g, '/').replace(/^\\//g, '');\n        return spath;\n    }\n    getBundleDest(config, bundleName, bundleGp) {\n        let dest = path.join(config.getDist(), config.option.bundleFolder);\n        if (bundleGp) {\n            let min = bundleGp.builder.minify;\n            let name = bundleGp.items[bundleName] || bundleName;\n            let file = name + ((min) ? '.min.js' : '.js');\n            if (bundleGp.combine) {\n                dest = path.join(dest, file);\n            }\n            else {\n                dest = path.join(dest, bundleName, file);\n            }\n        }\n        else {\n            dest = path.join(dest, bundleName);\n        }\n        return dest;\n    }\n};\nJspmBundle = __decorate([\n    development_core_1.task({\n        oper: development_core_1.Operation.release | development_core_1.Operation.deploy\n    }), \n    __metadata('design:paramtypes', [Object])\n], JspmBundle);\nexports.JspmBundle = JspmBundle;\n","import * as _ from 'lodash';\r\nimport { IMap, task, RunWay, IAssertDist, ITaskContext, Src, Pipe, OutputPipe, ITaskInfo, TransformSource, ITransform, Operation, PipeTask, bindingConfig } from 'development-core';\r\nimport { Gulp } from 'gulp';\r\nimport * as path from 'path';\r\nimport { IJspmTaskContext, IBundlesConfig, IBundleGroup, IBuidlerConfig, IBundleMap, IBundleTransform } from './config';\r\n\r\nimport { readFileSync, readFile, existsSync, writeFileSync, readdirSync } from 'fs';\r\nimport * as chalk from 'chalk';\r\n// const globby = require('globby');\r\nconst jspm = require('jspm');\r\nconst source = require('vinyl-source-stream');\r\nconst vinylBuffer = require('vinyl-buffer');\r\nconst chksum = require('checksum');\r\nconst mkdirp = require('mkdirp');\r\n// const uglify = require('gulp-uglify');\r\n\r\n\r\n@task({\r\n    oper: Operation.release | Operation.deploy\r\n})\r\nexport class JspmBundle extends PipeTask {\r\n\r\n    name = 'jspm-bundle';\r\n    runWay = RunWay.sequence;\r\n    private bundleMaps: IBundleMap[];\r\n    constructor(info?: ITaskInfo) {\r\n        super(info);\r\n    }\r\n\r\n    protected getOption(config: ITaskContext): IAssertDist {\r\n        return config.option;\r\n    }\r\n\r\n    protected loadBuilder(ctx: ITaskContext): Promise<any> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        jspm.setPackagePath(path.dirname(option.packageFile));\r\n        let jsbuilder = new jspm.Builder({ separateCSS: option.builder.separateCSS });\r\n\r\n        return Promise.resolve(jsbuilder)\r\n            .then(builder => {\r\n                if (option.jspmConfig) {\r\n                    return builder.loadConfig(option.jspmConfig, undefined, true)\r\n                        .then(() => {\r\n                            return builder;\r\n                        });\r\n                } else {\r\n                    return builder;\r\n                }\r\n            });\r\n    }\r\n\r\n    private translate(trans: IBundleTransform | IBundleTransform[]): ITransform | ITransform[] {\r\n        if (_.isArray(trans)) {\r\n            return _.map(trans, t => {\r\n                t.stream['bundle'] = t.bundle;\r\n                return t.stream;\r\n            });\r\n        } else {\r\n            trans.stream['bundle'] = trans.bundle;\r\n            return trans.stream;\r\n        }\r\n    }\r\n\r\n    private bundleConfig: IMap<IBundleGroup>;\r\n    initBundles(ctx: IJspmTaskContext): Promise<IMap<IBundleGroup>> {\r\n        let opt = ctx.option;\r\n        let pr = Promise.resolve<IMap<IBundleGroup>>(null)\r\n            .then(() => {\r\n                if (_.isFunction(opt.bundles)) {\r\n                    // opt['_bundlesFunc'] = opt.bundles;\r\n                    return opt.bundles(ctx);\r\n                } else {\r\n                    return opt.bundles;\r\n                }\r\n            });\r\n\r\n        if (opt.bundleDeps) {\r\n            pr = pr.then(bundles => {\r\n                let pkg = this.getPackage(opt);\r\n                if (!pkg) {\r\n                    console.log(chalk.red('can not found package.json file.'));\r\n                    process.exit(0);\r\n                }\r\n                if (!pkg.jspm) {\r\n                    console.log(chalk.red('jspm not init in package.json file.'));\r\n                    process.exit(0);\r\n                }\r\n                let deps = _.keys(pkg.jspm.dependencies);\r\n                if (opt.depsExclude) {\r\n                    let exclude = _.isFunction(opt.depsExclude) ? opt.depsExclude(ctx, deps) : opt.depsExclude;\r\n                    deps = _.filter(deps, d => exclude.indexOf(d) < 0);\r\n                }\r\n\r\n                return Promise.resolve()\r\n                    .then(() => {\r\n                        if (_.isFunction(opt.bundleDeps)) {\r\n                            // opt['_bundleDepsFunc'] = opt.bundleDeps;\r\n                            return opt.bundleDeps(ctx, deps);\r\n                        } else if (_.isBoolean(opt.bundleDeps)) {\r\n                            return {\r\n                                deplibs: {\r\n                                    combine: true,\r\n                                    items: deps\r\n                                }\r\n                            };\r\n                        } else {\r\n                            return opt.bundleDeps;\r\n                        }\r\n                    })\r\n                    .then(bundleDeps => {\r\n\r\n                        let cores = _.keys(bundleDeps);\r\n                        _.each(_.values(bundles), (b: IBundleGroup) => {\r\n                            b.exclude = b.exclude || [];\r\n                            b.exclude = cores.concat(b.exclude);\r\n                        });\r\n\r\n                        return bundles;\r\n                    });\r\n            });\r\n        }\r\n\r\n        return pr.then(bundles => {\r\n            this.bundleConfig = bundles;\r\n            return bundles;\r\n        });\r\n\r\n    }\r\n\r\n    source(ctx: ITaskContext, dist: IAssertDist, gulp?: Gulp): TransformSource | Promise<TransformSource> {\r\n        let option = <IBundlesConfig>ctx.option;\r\n        if (option.bundles) {\r\n            return this.initBundles(<IJspmTaskContext>ctx)\r\n                .then(() => {\r\n                    return Promise.all(_.map(this.getBundles(ctx), name => {\r\n                        return this.loadBuilder(ctx)\r\n                            .then(builder => {\r\n                                let bundle: IBundleGroup = this.bundleConfig[name];\r\n                                bundle.builder = <IBuidlerConfig>_.defaults(bundle.builder, option.builder);\r\n                                if (option.builder.config) {\r\n                                    builder.config(bundle.builder.config);\r\n                                }\r\n                                return this.groupBundle(<IJspmTaskContext>ctx, builder, name, bundle, gulp)\r\n                                    .then(trans => this.translate(trans));\r\n                            });\r\n                    }))\r\n                }).then(groups => {\r\n                    return _.flatten(groups);\r\n                });\r\n        } else {\r\n            return this.loadBuilder(ctx)\r\n                .then(builder => {\r\n                    let src = ctx.getSrc(this.getInfo());\r\n                    console.log('start bundle all src : ', chalk.cyan(<any>src));\r\n                    if (option.builder.config) {\r\n                        builder.config(option.builder.config)\r\n                    }\r\n\r\n                    return Promise.resolve<string[]>(ctx.fileFilter(src))\r\n                        .then(files => {\r\n                            files = this.getRelativeSrc(files, <IJspmTaskContext>ctx);\r\n                            console.log('bundle files:', chalk.cyan(<any>files));\r\n                            let mainfile = this.getBundleManifestPath(<IJspmTaskContext>ctx);\r\n                            return this.createBundler(<IJspmTaskContext>ctx, builder, 'bundle', files.join(' + '),  mainfile, option.builder)\r\n                                .then(trans => this.translate(trans));\r\n                        });\r\n                });\r\n        }\r\n    }\r\n\r\n    private getRelativeSrc(src: Src, config: IJspmTaskContext, toModule = false): string[] {\r\n        // console.log(option.baseURL);\r\n        let baseURL = config.option.baseURL\r\n        if (_.isArray(src)) {\r\n            return _.map(src, s => {\r\n                let filename = path.relative(baseURL, s).replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n                return toModule ? this.toModulePath(filename) : filename;\r\n            });\r\n        } else {\r\n            let fn = path.relative(baseURL, src).replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n            return [(toModule ? this.toModulePath(fn) : fn)];\r\n        }\r\n    }\r\n\r\n    private toModulePath(filename: string): string {\r\n        if (!filename) {\r\n            return '';\r\n        }\r\n        return filename.substring(0, filename.length - path.extname(filename).length);\r\n    }\r\n\r\n    private initOption(ctx: ITaskContext) {\r\n        let option = <IBundlesConfig>_.extend(<IBundlesConfig>{\r\n            baseURL: '',\r\n            mainfile: 'bundle.js',\r\n            jspmConfig: '',\r\n            packageFile: 'package.json',\r\n            dest: '',\r\n            file: '',\r\n            systemConfigTempl: '',\r\n            relationToRoot: '',\r\n            bust: '',\r\n            bundles: null,\r\n            bundleFolder: './',\r\n            includePackageFiles: [\r\n                'system-polyfills.src.js',\r\n                'system.src.js'\r\n            ],\r\n            jspmMates: {\r\n                '*.css': {\r\n                    loader: 'css'\r\n                },\r\n                '*.json': {\r\n                    loader: 'json'\r\n                },\r\n                '*.jsx': {\r\n                    loader: 'jsx'\r\n                }\r\n            },\r\n            builder: {\r\n                sfx: false,\r\n                minify: false,\r\n                mangle: false,\r\n                sourceMaps: false,\r\n                separateCSS: false,\r\n                lowResSourceMaps: true\r\n            }\r\n        }, <IBundlesConfig>ctx.option);\r\n\r\n        option.baseURL = ctx.toRootPath(option.baseURL);\r\n        if (option.jspmConfig) {\r\n            option.jspmConfig = ctx.toRootPath(option.jspmConfig);\r\n        }\r\n        option.packageFile = ctx.toRootPath(option.packageFile);\r\n\r\n        let pkg = this.getPackage(option);\r\n        if (!option.jspmPackages) {\r\n            if (pkg.jspm.directories && pkg.jspm.directories.packages) {\r\n                option.jspmPackages = <string>pkg.jspm.directories.packages;\r\n            } else {\r\n                option.jspmPackages = 'jspm_packages';\r\n            }\r\n        }\r\n        option.jspmPackages = ctx.toRootPath(option.jspmPackages);\r\n\r\n        if (!readdirSync(option.jspmPackages)) {\r\n            console.log(chalk.red('jspm project config error!'));\r\n            process.exit(0);\r\n        }\r\n\r\n        return option;\r\n    }\r\n\r\n\r\n    execute(context: ITaskContext, gulp: Gulp) {\r\n        this.bundleMaps = [];\r\n        let ctx = <IJspmTaskContext>context;\r\n        return super.execute(ctx, gulp)\r\n            .then(() => {\r\n                let option = <IBundlesConfig>ctx.option;\r\n                if (option.bundles) {\r\n                    return this.calcChecksums(option, this.bundleMaps).then((checksums) => {\r\n                        return this.updateBundleManifest(ctx, this.bundleMaps, checksums);\r\n                    });\r\n                } else {\r\n                    return null;\r\n                }\r\n            }).then(manifest => {\r\n                if (manifest) {\r\n                    return this.writeBundleManifest(ctx, manifest, gulp)\r\n                        .then(() => {\r\n                            console.log(chalk.green('------ Complete -------------'));\r\n                        });\r\n                } else {\r\n                    console.log(chalk.green('------ Complete -------------'));\r\n                    return null;\r\n                }\r\n            });\r\n    }\r\n\r\n    setup(ctx: ITaskContext, gulp: Gulp) {\r\n        ctx.option = this.initOption(ctx);\r\n        return super.setup(ctx, gulp);\r\n    }\r\n\r\n    protected working(source: ITransform, ctx: ITaskContext, option: IAssertDist, gulp: Gulp, pipes?: Pipe[], output?: OutputPipe[]) {\r\n        let bundle = <IBundleMap>source['bundle'];\r\n        return super.working(source, ctx, option, gulp, pipes, output)\r\n            .then(() => {\r\n                let bundlemap: IBundleMap = {\r\n                    path: bundle.path,\r\n                    modules: bundle.modules\r\n                };\r\n                this.bundleMaps.push(bundlemap);\r\n                if (bundle.sfx) {\r\n                    console.log(`Built sfx package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                } else {\r\n                    console.log(`Bundled package: ${chalk.cyan(bundle.bundleName)} -> ${chalk.cyan(bundle.filename)}\\n   dest: ${chalk.cyan(bundle.bundleDest)}`);\r\n                }\r\n                return;\r\n            });\r\n    }\r\n\r\n    getBundles(ctx: ITaskContext) {\r\n\r\n        let groups = [];\r\n        if (ctx.env.gb) {\r\n            groups = _.uniq(_.isArray(ctx.env.gb) ? ctx.env.gb : (ctx.env.gb || '').split(','));\r\n        }\r\n\r\n        if (groups.length < 1) {\r\n            groups = _.keys(this.bundleConfig);\r\n        } else {\r\n            groups = _.filter(groups, f => f && groups[f]);\r\n        }\r\n        console.log('cmmand group bundle:', chalk.cyan(<any>groups));\r\n        return groups;\r\n    }\r\n\r\n    protected groupBundle(config: IJspmTaskContext, builder, name: string, bundleGp: IBundleGroup, gulp: Gulp): Promise<IBundleTransform | IBundleTransform[]> {\r\n\r\n        let bundleStr = '';\r\n        let bundleDest = '';\r\n\r\n        let bundleItems: string[] = [];\r\n        let minusStr = this.exclusionString(bundleGp.exclude, this.bundleConfig);\r\n\r\n        if (bundleGp.items) {\r\n            bundleItems = _.isArray(bundleItems) ? <string[]>bundleGp.items : _.keys(bundleGp.items);\r\n        }\r\n\r\n        if (bundleGp.combine) {\r\n            bundleDest = this.getBundleDest(config, name, bundleGp);\r\n            bundleStr = bundleItems.join(' + ') + minusStr;\r\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup source:\\n  ${chalk.cyan(bundleStr)}\\n-------------------------------`);\r\n            return this.createBundler(config, builder, name, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n\r\n        } else {\r\n            console.log(`Bundling group: ${chalk.cyan(name)} ... \\ngroup items:\\n  ${chalk.cyan(<any>bundleItems)}\\n-------------------------------`);\r\n            return Promise.all(bundleItems.map(key => {\r\n                bundleStr = key + minusStr;\r\n                bundleDest = this.getBundleDest(config, key, bundleGp);\r\n                return this.createBundler(config, builder, key, bundleStr, bundleDest, bundleGp.builder, bundleGp);\r\n            }));\r\n        }\r\n    }\r\n\r\n    private exclusionString(exclude, groups): string {\r\n        let str = this.exclusionArray(exclude, groups).join(' - ');\r\n        return (str) ? ' - ' + str : '';\r\n    }\r\n\r\n    private exclusionArray(exclude, groups): string[] {\r\n        let minus: string[] = [];\r\n        exclude = (_.isArray(exclude)) ? exclude : _.keys(exclude);\r\n        _.forEach(exclude, (item: string) => {\r\n            var group = groups[item];\r\n            if (group) {\r\n                // exclude everything from this group\r\n                minus = minus.concat(this.exclusionArray(group.items, groups));\r\n            } else {\r\n                // exclude this item by name\r\n                minus.push(item);\r\n            }\r\n        });\r\n        return minus;\r\n    }\r\n\r\n    private createBundler(config: IJspmTaskContext, builder: any, bundleName: string, bundleStr: string, bundleDest: string, builderCfg: IBuidlerConfig, bundleGp?: IBundleGroup): Promise<IBundleTransform> {\r\n\r\n        let sfx = builderCfg.sfx;\r\n        let bundler = (sfx) ? builder.buildStatic : builder.bundle;\r\n        let shortPath = this.getBundleShortPath(config, bundleName, bundleGp);\r\n        let filename = path.parse(bundleDest).base;\r\n\r\n        return bundler.bind(builder)(bundleStr, bundleDest, builderCfg)\r\n            .then(output => {\r\n                mkdirp.sync(path.dirname(bundleDest));\r\n                var stream: ITransform = source(filename);\r\n                stream.write(output.source);\r\n                process.nextTick(function () {\r\n                    stream.end();\r\n                });\r\n\r\n                return {\r\n                    stream: stream.pipe(vinylBuffer()),\r\n                    bundle: {\r\n                        path: shortPath,\r\n                        sfx: sfx,\r\n                        bundleName: bundleName,\r\n                        filename: filename,\r\n                        bundleDest: bundleDest,\r\n                        modules: output.modules\r\n                    }\r\n                };\r\n            });\r\n\r\n    }\r\n\r\n    private packages = {};\r\n    public getPackage(option: IBundlesConfig): any {\r\n        if (!this.packages[option.packageFile]) {\r\n            this.packages[option.packageFile] = require(option.packageFile);\r\n        }\r\n        return this.packages[option.packageFile]\r\n    }\r\n\r\n    private calcChecksums(option: IBundlesConfig, bundles: any[]): Promise<any> {\r\n        let chksums = {};\r\n\r\n        console.log('Calculating checksums...');\r\n\r\n        return Promise.all(_.map(bundles, (bundle: any) => {\r\n            if (!_.isObject(bundle)) {\r\n                return null;\r\n            }\r\n\r\n            return new Promise((resolve, reject) => {\r\n                let filepath = path.join(option.baseURL || '.', bundle.path);\r\n                let filename = path.parse(bundle.path).base;\r\n                chksum.file(filepath, (err, sum) => {\r\n                    if (err) {\r\n                        console.error(chalk.red(' Checksum Error:'), chalk.red(err));\r\n                    }\r\n                    console.log(filename, chalk.cyan(sum));\r\n                    chksums[bundle.path] = sum;\r\n                    resolve(chksums);\r\n                });\r\n            });\r\n\r\n        })).then(() => {\r\n            return chksums;\r\n        });\r\n    }\r\n\r\n    protected updateBundleManifest(ctx: IJspmTaskContext, bundles: any[], chksums?: any) {\r\n\r\n        chksums = chksums || {};\r\n\r\n        var manifest: any = _.defaults(this.getBundleManifest(ctx), {\r\n            bundles: {},\r\n            chksums: {}\r\n        });\r\n\r\n        // console.log(manifest);\r\n\r\n        _.each(bundles, bundle => {\r\n            if (bundle.path) {\r\n                manifest.bundles[bundle.path] = bundle.modules;\r\n                manifest.chksums[bundle.path] = chksums[bundle.path] || '';\r\n            }\r\n        });\r\n\r\n        return manifest;\r\n\r\n    }\r\n\r\n    private manifestSplit = `/*------bundles infos------*/`;\r\n    private writeBundleManifest(ctx: IJspmTaskContext, manifest, gulp: Gulp): Promise<any> {\r\n        let option = ctx.option;\r\n        if (!option.mainfile) {\r\n            return Promise.reject('mainfile not configed.');\r\n        }\r\n\r\n\r\n        console.log('Writing manifest...');\r\n\r\n\r\n        let output = `\r\nSystem.config({\r\n    baseURL: '${ path.relative(option.baseURL, ctx.env.root) || '.'}',\r\n    defaultJSExtensions: true\r\n});\r\nSystem.bundled = true;\r\nSystem.bust = '${option.bust}';\r\nif(window != undefined) window.prod = true;\r\n${this.manifestSplit}\r\n`;\r\n        let template = '';\r\n\r\n        if (manifest) {\r\n            // try {\r\n            template = option.systemConfigTempl;\r\n\r\n            if (!template) {\r\n                template = (option.bust) ? `\r\n(function(module) {\r\n    var bust = {};\r\n    var systemLocate = System.locate;\r\n    var systemNormalize = System.normalize;\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var chksums = module.exports.chksums = \\${chksums};\r\n    var bundles = module.exports.bundles = \\${bundles};                    \r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n    System.normalize = function (name, pName, pAddress) {\r\n        return systemNormalize.call(this, name, pName, pAddress).then(function (address) {\r\n            var chksum = chksums[name];\r\n            if (chksums[name]) { bust[address] = chksum; }\r\n            return address;\r\n        });\r\n    };\r\n\r\n    System.locate = function (load) {\r\n        return Promise.resolve(systemLocate.call(this, load)).then(function (address) {\r\n            var chksum = bust[address];\r\n            return (chksum) ? address + '?' + chksum : address;\r\n        });\r\n    };\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n` : `\r\n(function(module) {\r\n    var bundles = module.exports.bundles = \\${bundles};\r\n    var paths =  module.exports.paths = \\${paths} || {};\r\n    var maps = \\${ maps };\r\n    var jspmMeta = \\${ jspmMeta };\r\n\r\n    System.config({\r\n            packages: {\r\n            \"meta\": jspmMeta\r\n        },\r\n        map: maps,\r\n        paths: paths,\r\n        bundles: bundles\r\n    });\r\n\r\n})((typeof module !== 'undefined') ? module : {exports: {}}, this);\r\n`;\r\n            }\r\n\r\n\r\n            let maps = {\r\n                css: 'github:systemjs/plugin-css@0.1.20.js',\r\n                json: 'github:systemjs/plugin-json@0.1.2.js'\r\n            };\r\n\r\n            _.each(_.keys(manifest.bundles), n => {\r\n                if (/css.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n                if (/json.min.js$/.test(n)) {\r\n                    maps.css = <string>_.first(manifest.bundles[n]);\r\n                }\r\n            });\r\n\r\n            let jspmMetas = option.jspmMates;\r\n            output += _.template(template)({\r\n                maps: JSON.stringify(maps, null, '    '),\r\n                jspmMeta: JSON.stringify(jspmMetas, null, '    '),\r\n                paths: JSON.stringify(ctx.option.builder.config ? ctx.option.builder.config.paths : null, null, '    '),\r\n                chksums: JSON.stringify(manifest.chksums, null, '    '),\r\n                bundles: JSON.stringify(manifest.bundles, null, '    '),\r\n            });\r\n\r\n        }\r\n\r\n\r\n        let includes = option.includes || [];\r\n\r\n        includes = includes.concat(_.map(option.includePackageFiles, f => path.join(option.jspmPackages, f)));\r\n\r\n        return Promise.all(_.map(includes, f => {\r\n            return new Promise<string>((resolve, reject) => {\r\n                readFile(path.join(option.jspmConfig, f), 'utf8', (err, data) => {\r\n                    if (err) {\r\n                        reject(err);\r\n                    } else {\r\n                        resolve(data);\r\n                    }\r\n                });\r\n            });\r\n        }))\r\n            .then(data => {\r\n                data.push(output);\r\n                let mainfile = option.mainfile; // path.relative(this.getBundleManifestPath(ctx), ctx.getDist(this.getInfo()));\r\n                console.log('mainfile:', mainfile);\r\n                mkdirp.sync(path.dirname(mainfile));\r\n                var stream = <NodeJS.ReadWriteStream>source(mainfile);\r\n                stream.write(data.join('\\n'));\r\n                process.nextTick(() => {\r\n                    stream.end();\r\n                });\r\n\r\n                return super.working(stream.pipe(vinylBuffer()), ctx, option, gulp, option.mainfilePipes || [], option.mainfileOutput);\r\n            });\r\n\r\n    }\r\n\r\n    private getBundleManifestPath(ctx: IJspmTaskContext): string {\r\n        return this.getBundleDest(ctx, ctx.option.mainfile);\r\n    }\r\n    private getBundleManifest(ctx: IJspmTaskContext): any {\r\n        let data: any = {};\r\n        let mainfile: string = this.getBundleManifestPath(ctx);\r\n        console.log('try to load old bundle in path ', mainfile);\r\n        if (existsSync(mainfile)) {\r\n            try {\r\n                let content = readFileSync(mainfile, 'utf8');\r\n                let idx = content.indexOf(this.manifestSplit);\r\n                idx = idx > 0 ? (idx + this.manifestSplit.length) : 0;\r\n                content = content.substring(idx);\r\n                // console.log(content);\r\n                writeFileSync(mainfile, content);\r\n                data = require(mainfile);\r\n                console.log('has old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\r\n            } catch (e) {\r\n                console.log(chalk.red(e));\r\n            }\r\n        } else {\r\n            console.log('no old bundle：\\n', chalk.cyan(mainfile)); // , 'data:\\n', data);\r\n        }\r\n\r\n        return data;\r\n    }\r\n\r\n    private getBundleShortPath(config: IJspmTaskContext, bundleName: string, bundleGp?: IBundleGroup) {\r\n        var fullPath = bundleGp ? this.getBundleDest(config, bundleName, bundleGp)\r\n            : path.join(config.getDist(), bundleName);\r\n\r\n        let spath: string = path.relative(config.option.baseURL, fullPath);\r\n        spath = spath.replace(/\\\\/g, '/').replace(/^\\//g, '');\r\n        return spath;\r\n    }\r\n\r\n    private getBundleDest(config: IJspmTaskContext, bundleName: string, bundleGp?: IBundleGroup) {\r\n\r\n        let dest = path.join(config.getDist(), config.option.bundleFolder);\r\n        if (bundleGp) {\r\n            let min = bundleGp.builder.minify;\r\n            let name = bundleGp.items[bundleName] || bundleName;\r\n            let file = name + ((min) ? '.min.js' : '.js');\r\n\r\n            if (bundleGp.combine) {\r\n                dest = path.join(dest, file);\r\n            } else {\r\n                dest = path.join(dest, bundleName, file);\r\n            }\r\n        } else {\r\n            dest = path.join(dest, bundleName);\r\n        }\r\n\r\n        return dest;\r\n    }\r\n}\r\n"]}